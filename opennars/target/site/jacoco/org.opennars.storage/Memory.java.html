<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Memory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.storage</a> &gt; <span class="el_source">Memory.java</span></div><h1>Memory.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.storage;
 
import org.opennars.control.concept.ProcessTask;
import org.opennars.control.DerivationContext;
import org.opennars.control.GeneralInferenceControl;
import org.opennars.control.TemporalInferenceControl;
import org.opennars.entity.*;
import org.opennars.inference.BudgetFunctions;
import org.opennars.interfaces.Resettable;
import org.opennars.interfaces.Timable;
import org.opennars.io.Symbols;
import org.opennars.io.events.EventEmitter;
import org.opennars.io.events.Events;
import org.opennars.io.events.Events.ResetEnd;
import org.opennars.io.events.Events.ResetStart;
import org.opennars.io.events.Events.TaskRemove;
import org.opennars.io.events.OutputHandler.IN;
import org.opennars.io.events.OutputHandler.OUT;
import org.opennars.io.events.OutputHandler.DEBUG;
import org.opennars.language.CompoundTerm;
import org.opennars.language.Interval;
import org.opennars.language.Tense;
import org.opennars.language.Term;
import org.opennars.main.Nar;
import org.opennars.main.Parameters;
import org.opennars.operator.Operation;
import org.opennars.operator.Operator;
import org.opennars.plugin.mental.Emotions;
import org.opennars.main.Debug;

import java.io.Serializable;
import java.util.*;
import org.opennars.entity.Stamp.BaseEntry;

import static org.opennars.inference.BudgetFunctions.truthToQuality;
import org.opennars.plugin.mental.InternalExperience;


/**
 * Memory consists of the run-time state of a Nar, including:
 *   * term and concept memory
 *   * reasoner state
 *   * etc.
 * &lt;br&gt;
 * Excluding input/output channels which are managed by a Nar.
 * &lt;br&gt;
 * A memory is controlled by zero or one Nar's at a given time.
 * &lt;br&gt;
 * Memory is serializable so it can be persisted and transported.
 */
public class Memory implements Serializable, Iterable&lt;Concept&gt;, Resettable {
    
     /* Nar parameters */
    public final Parameters narParameters;
    
<span class="fc" id="L79">    public long narId = 0;</span>
    //emotion meter keeping track of global emotion
<span class="fc" id="L81">    public Emotions emotion = null;   </span>
<span class="fc" id="L82">    public InternalExperience internalExperience = null;</span>
<span class="fc" id="L83">    public Task lastDecision = null;</span>
<span class="fc" id="L84">    public boolean allowExecution = true;</span>

<span class="fc" id="L86">    public final long randomSeed = 1;</span>
<span class="fc" id="L87">    public final Random randomNumber = new Random(randomSeed);</span>
    
    //todo make sense of this class and de-obfuscate
    public final Bag&lt;Concept,Term&gt; concepts;
    public transient EventEmitter event;
    
    /* InnateOperator registry. Containing all registered operators of the system */
    public final Map&lt;CharSequence, Operator&gt; operators;
    
    /* a mutex for novel and new taskks*/
<span class="fc" id="L97">    private final Boolean tasksMutex = Boolean.TRUE;</span>
    
    /* New tasks with novel composed terms, for delayed and selective processing*/
    public final Bag&lt;Task&lt;Term&gt;,Sentence&lt;Term&gt;&gt; novelTasks;
    
    /* Input event tasks that were either input events or derived sequences*/
    public final Bag&lt;Task&lt;Term&gt;,Sentence&lt;Term&gt;&gt; seq_current;
    public final Bag&lt;Task&lt;Term&gt;,Sentence&lt;Term&gt;&gt; recent_operations;
    
    //Boolean localInferenceMutex = false;


<span class="fc" id="L109">    boolean checked=false;</span>
<span class="fc" id="L110">    boolean isjUnit=false;</span>
    
    /* ---------- Constructor ---------- */
    /**
     * Create a new memory
     */
    public Memory(final Parameters narParameters, final Bag&lt;Concept,Term&gt; concepts, final Bag&lt;Task&lt;Term&gt;,Sentence&lt;Term&gt;&gt; novelTasks,
                  final Bag&lt;Task&lt;Term&gt;,Sentence&lt;Term&gt;&gt; seq_current,
<span class="fc" id="L118">                  final Bag&lt;Task&lt;Term&gt;,Sentence&lt;Term&gt;&gt; recent_operations) {</span>
<span class="fc" id="L119">        this.narParameters = narParameters;</span>
<span class="fc" id="L120">        this.event = new EventEmitter();</span>
<span class="fc" id="L121">        this.concepts = concepts;</span>
<span class="fc" id="L122">        this.novelTasks = novelTasks;                </span>
<span class="fc" id="L123">        this.recent_operations = recent_operations;</span>
<span class="fc" id="L124">        this.seq_current = seq_current;</span>
<span class="fc" id="L125">        this.operators = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L126">        reset();</span>
<span class="fc" id="L127">    }</span>
    
    public void reset() {
<span class="fc" id="L130">        event.emit(ResetStart.class);</span>
<span class="fc" id="L131">        synchronized (concepts) {</span>
<span class="fc" id="L132">            concepts.clear();</span>
<span class="fc" id="L133">        }</span>
<span class="fc" id="L134">        synchronized (tasksMutex) {</span>
<span class="fc" id="L135">            novelTasks.clear();</span>
<span class="fc" id="L136">        }</span>
<span class="fc" id="L137">        synchronized(this.seq_current) {</span>
<span class="fc" id="L138">            this.seq_current.clear();</span>
<span class="fc" id="L139">        }</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if(emotion != null) {</span>
<span class="fc" id="L141">            emotion.resetEmotions();</span>
        }
<span class="fc" id="L143">        this.lastDecision = null;</span>
<span class="fc" id="L144">        randomNumber.setSeed(randomSeed);</span>
<span class="fc" id="L145">        event.emit(ResetEnd.class);</span>
<span class="fc" id="L146">    }</span>

    /* ---------- conversion utilities ---------- */
    /**
     * Get an existing Concept for a given name
     * &lt;p&gt;
     * called from Term and ConceptWindow.
     *
     * @param t the name of a concept
     * @return a Concept or null
     */
    public Concept concept(final Term t) {
<span class="fc" id="L158">        synchronized (concepts) {</span>
<span class="fc" id="L159">            return concepts.get(CompoundTerm.replaceIntervals(t));</span>
        }
    }

    /**
     * Get the Concept associated to a Term, or create it.
     * 
     *   Existing concept: apply tasklink activation (remove from bag, adjust budget, reinsert)
     *   New concept: set initial activation, insert
     *   Subconcept: extract from cache, apply activation, insert
     * 
     * If failed to insert as a result of null bag, returns null
     *
     * A displaced Concept resulting from insert is forgotten (but may be stored in optional  subconcept memory
     * 
     * @param term indicating the concept
     * @return an existing Concept, or a new one, or null 
     */
    public Concept conceptualize(final BudgetValue budget, Term term) {   
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if(term instanceof Interval) {</span>
<span class="fc" id="L179">            return null;</span>
        }
<span class="fc" id="L181">        term = CompoundTerm.replaceIntervals(term);</span>

        final Concept displaced;
        Concept concept;

<span class="fc" id="L186">        synchronized (concepts) {</span>
<span class="fc" id="L187">            concept = concepts.pickOut(term);</span>

            //see if concept is active
<span class="fc bfc" id="L190" title="All 2 branches covered.">            if (concept == null) {</span>
                //create new concept, with the applied budget
<span class="fc" id="L192">                concept = new Concept(budget, term, this);</span>
                //if (memory.logic!=null)
                //    memory.logic.CONCEPT_NEW.commit(term.getComplexity());
<span class="fc" id="L195">                emit(Events.ConceptNew.class, concept);</span>
            }
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            else if (concept!=null) {</span>
                //apply budget to existing concept
                //memory.logic.CONCEPT_ACTIVATE.commit(term.getComplexity());
<span class="fc" id="L200">                BudgetFunctions.activate(concept.budget, budget, BudgetFunctions.Activating.TaskLink);</span>
            }
            else {
                //unable to create, ex: has variables
<span class="nc" id="L204">                return null;</span>
            }

<span class="fc" id="L207">            displaced = concepts.putBack(concept, cycles(narParameters.CONCEPT_FORGET_DURATIONS), this);</span>
<span class="fc" id="L208">        }</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (displaced == null) {</span>
            //added without replacing anything
<span class="fc" id="L212">            return concept;</span>
        }        
<span class="fc bfc" id="L214" title="All 2 branches covered.">        else if (displaced == concept) {</span>
            //not able to insert
<span class="fc" id="L216">            conceptRemoved(displaced);</span>
<span class="fc" id="L217">            return null;</span>
        }        
        else {
<span class="fc" id="L220">            conceptRemoved(displaced);</span>
<span class="fc" id="L221">            return concept;</span>
        }
    }
    
    /* ---------- new task entries ---------- */
    /**
     * add new task that waits to be processed in the next cycleMemory
     */
    public void addNewTask(final Task t, final String reason) {
<span class="fc" id="L230">        synchronized (tasksMutex) {</span>
<span class="fc" id="L231">            novelTasks.putIn(t);</span>
<span class="fc" id="L232">        }</span>
      //  logic.TASK_ADD_NEW.commit(t.getPriority());
<span class="fc" id="L234">        emit(Events.TaskAdd.class, t, reason);</span>
<span class="fc" id="L235">        output(t);</span>
<span class="fc" id="L236">    }</span>

    public static boolean isJUnitTest() {
<span class="fc" id="L239">        final StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</span>
<span class="fc" id="L240">        final StackTraceElement[] list = stackTrace;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (final StackTraceElement element : list) {</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (element.getClassName().startsWith(&quot;org.junit.&quot;)) {</span>
<span class="fc" id="L243">                return true;</span>
            }           
        }
<span class="fc" id="L246">        return false;</span>
    }
    

    /**
     * Input task processing. Invoked by the outside or inside environment.
     * Outside: StringParser (addInput);
     * Inside: InnateOperator (feedback).
     *
     * @param time indirection to retrieve time
     * @param task The addInput task
     */
    /* There are several types of new tasks, all added into the
     * newTasks list, to be processed in the next cycleMemory.
     * Some of them are reported and/or logged. */
    /*
     * Input tasks with low priority are ignored, and the others are put into task buffer.
     */
    public void inputTask(final Timable time, final Task task, final boolean emitIn) {
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if(!checked) {</span>
<span class="fc" id="L266">            checked=true;</span>
<span class="fc" id="L267">            isjUnit=isJUnitTest();</span>
        }
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (task != null) {</span>
<span class="fc" id="L270">            final Stamp s = task.sentence.stamp;</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (s.getCreationTime()==-1)</span>
<span class="fc" id="L272">                s.setCreationTime(time.time(), narParameters.DURATION);</span>

<span class="fc bfc" id="L274" title="All 2 branches covered.">            if(emitIn) {</span>
<span class="fc" id="L275">                emit(IN.class, task);</span>
            }

<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            if (task.budget.aboveThreshold()) {</span>
<span class="fc" id="L279">                addNewTask(task, &quot;Perceived&quot;);</span>
            } else {
<span class="nc" id="L281">                removeTask(task, &quot;Neglected&quot;);</span>
            }
        }
<span class="fc" id="L284">    }</span>

    /**
     * @param time indirection to retrieve time
     */
    public void inputTask(final Timable time, final Task t) {
<span class="fc" id="L290">        inputTask(time, t, true);</span>
<span class="fc" id="L291">    }</span>

    public void removeTask(final Task task, final String reason) {        
<span class="fc" id="L294">        emit(TaskRemove.class, task, reason);    </span>
<span class="fc" id="L295">    }</span>
    
    /**
     * ExecutedTask called in Operator.call
     *
     * @param operation The operation just executed
     * @param time indirection to retrieve time
     */
    public void executedTask(final Timable time, final Operation operation, final TruthValue truth) {
<span class="fc" id="L304">        final Task opTask = operation.getTask();</span>
       // logic.TASK_EXECUTED.commit(opTask.budget.getPriority());
                
<span class="fc" id="L307">        final Stamp stamp = new Stamp(time, this, Tense.Present);</span>
<span class="fc" id="L308">        final Sentence sentence = new Sentence(</span>
            operation,
            Symbols.JUDGMENT_MARK,
            truth,
            stamp);

<span class="fc" id="L314">        final BudgetValue budgetForNewTask = new BudgetValue(narParameters.DEFAULT_FEEDBACK_PRIORITY,</span>
            narParameters.DEFAULT_FEEDBACK_DURABILITY,
<span class="fc" id="L316">            truthToQuality(sentence.getTruth()), narParameters);</span>
<span class="fc" id="L317">        final Task newTask = new Task(sentence, budgetForNewTask, Task.EnumType.INPUT);</span>

<span class="fc" id="L319">        newTask.setElemOfSequenceBuffer(true);</span>
<span class="fc" id="L320">        addNewTask(newTask, &quot;Executed&quot;);</span>
<span class="fc" id="L321">    }</span>

    public void output(final Task t) {
        
<span class="fc" id="L325">        final float budget = t.budget.summary();</span>
<span class="fc" id="L326">        final float noiseLevel = 1.0f - (narParameters.VOLUME / 100.0f);</span>
        
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (budget &gt;= noiseLevel) {  // only report significant derived Tasks</span>
<span class="fc" id="L329">            emit(OUT.class, t);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if (Debug.PARENTS) {</span>
<span class="nc" id="L331">                emit(DEBUG.class, &quot;Parent Belief\t&quot; + t.parentBelief);</span>
<span class="nc" id="L332">                emit(DEBUG.class, &quot;Parent Task\t&quot; + t.parentTask + &quot;\n\n&quot;);</span>
            }
        }        
<span class="fc" id="L335">    }</span>
    
    final public void emit(final Class c, final Object... signal) {        
<span class="fc" id="L338">        event.emit(c, signal);</span>
<span class="fc" id="L339">    }</span>

    final public boolean emitting(final Class channel) {
<span class="fc" id="L342">        return event.isActive(channel);</span>
    }
    
    public void conceptRemoved(final Concept c) {
<span class="fc" id="L346">        emit(Events.ConceptForget.class, c);</span>
<span class="fc" id="L347">    }</span>
    
    public void cycle(final Nar nar) {
    
<span class="fc" id="L351">        event.emit(Events.CycleStart.class);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        for(int i=0; i&lt;nar.narParameters.NOVEL_TASK_BAG_SELECTIONS; i++) {</span>
<span class="fc" id="L353">            this.processNovelTask(nar.narParameters, nar);</span>
        }
    //if(noResult()) //newTasks empty
<span class="fc" id="L356">        GeneralInferenceControl.selectConceptForInference(this, nar.narParameters, nar);</span>
        
<span class="fc" id="L358">        event.emit(Events.CycleEnd.class);</span>
<span class="fc" id="L359">        event.synch();</span>
<span class="fc" id="L360">    }</span>

    /**
     *
     * @param task task to be processed
     * @param narParameters parameters for the Reasoner instance
     * @param time indirection to retrieve time
     */
    public void localInference(final Task task, Parameters narParameters, final Timable time) {
        //synchronized (localInferenceMutex) {
<span class="fc" id="L370">            final DerivationContext cont = new DerivationContext(this, narParameters, time);</span>
<span class="fc" id="L371">            cont.setCurrentTask(task);</span>
<span class="fc" id="L372">            cont.setCurrentTerm(task.getTerm());</span>
<span class="fc" id="L373">            cont.setCurrentConcept(conceptualize(task.budget, cont.getCurrentTerm()));</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (cont.getCurrentConcept() != null) {</span>
<span class="fc" id="L375">                final boolean processed = ProcessTask.processTask(cont.getCurrentConcept(), cont, task, time);</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">                if (processed) {</span>
<span class="fc" id="L377">                    event.emit(Events.ConceptDirectProcessedTask.class, task);</span>
                }
            }

<span class="fc bfc" id="L381" title="All 4 branches covered.">            if (!task.sentence.isEternal() &amp;&amp; !(task.sentence.term instanceof Operation)) {</span>
<span class="fc" id="L382">                TemporalInferenceControl.eventInference(task, cont);</span>
            }

            //memory.logic.TASK_IMMEDIATE_PROCESS.commit();
<span class="fc" id="L386">            emit(Events.TaskImmediateProcess.class, task, cont);</span>
        //}
<span class="fc" id="L388">    }</span>

    /**
     * Select a novel task to process
     *
     * @param narParameters parameters for the Reasoner instance
     * @param time indirection to retrieve time
     */
    public void processNovelTask(Parameters narParameters, final Timable time) {
<span class="fc" id="L397">        synchronized (tasksMutex) {</span>
<span class="fc" id="L398">            final Task task = novelTasks.takeOut();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">            if (task != null) {            </span>
<span class="fc" id="L400">                localInference(task, narParameters, time);</span>
            }
<span class="fc" id="L402">        }</span>
<span class="fc" id="L403">    }</span>

     public Operator getOperator(final String op) {
<span class="fc" id="L406">        return operators.get(op);</span>
     }
     
     public Operator addOperator(final Operator op) {
<span class="fc" id="L410">         operators.put(op.name(), op);</span>
<span class="fc" id="L411">         return op;</span>
     }
     
     public Operator removeOperator(final Operator op) {
<span class="nc" id="L415">         return operators.remove(op.name());</span>
     }

<span class="fc" id="L418">    private long currentStampSerial = 0;</span>
    public BaseEntry newStampSerial() {
<span class="fc" id="L420">        return new BaseEntry(this.narId, currentStampSerial++);</span>
    }   

    /** converts durations to cycles */
    public final float cycles(final double durations) {
<span class="fc" id="L425">        return narParameters.DURATION * (float) durations;</span>
    }

    @Override
    public Iterator&lt;Concept&gt; iterator() {
<span class="nc" id="L430">        return concepts.iterator();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>