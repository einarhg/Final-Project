<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Bag.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.storage</a> &gt; <span class="el_source">Bag.java</span></div><h1>Bag.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.storage;

import org.opennars.entity.Item;
import java.io.Serializable;
import java.util.*;
import org.opennars.inference.BudgetFunctions;
import org.opennars.main.Parameters;

/**
 * Original Bag implementation which distributes items into
 * discrete levels (queues) according to priority
 */
public class Bag&lt;Type extends Item&lt;K&gt;,K&gt; implements Serializable, Iterable&lt;Type&gt;  {
    
       /** priority levels */
    private final int TOTAL_LEVEL;
    /** firing threshold */
    private final int THRESHOLD;
    /** shared DISTRIBUTOR that produce the probability distribution */
    private final Distributor DISTRIBUTOR;
    /** mapping from key to item */
    private HashMap&lt;K, Type&gt; nameTable;
    /** array of lists of items, for items on different level */
    private ArrayList&lt;ArrayList&lt;Type&gt;&gt; itemTable;
    /** defined in different bags */
    private final int capacity;
    /** current sum of occupied level */
    private int mass;
    /** index to get next level, kept in individual objects */
    private int levelIndex;
    /** current take out level */
    private int currentLevel;
    /** maximum number of items to be taken out at current level */
    private int currentCounter;
    
    public Bag(final int levels, final int capacity, Parameters narParameters) {
<span class="fc" id="L60">        this(levels, capacity, (int) (narParameters.BAG_THRESHOLD * levels));</span>
<span class="fc" id="L61">    }</span>

    /** thresholdLevel = 0 disables &quot;fire level completely&quot; threshold effect */
<span class="fc" id="L64">    public Bag(final int levels, final int capacity, final int thresholdLevel) {</span>
<span class="fc" id="L65">        this.TOTAL_LEVEL = levels;</span>
<span class="fc" id="L66">        DISTRIBUTOR = new Distributor(TOTAL_LEVEL); </span>
<span class="fc" id="L67">        this.THRESHOLD = thresholdLevel;</span>
<span class="fc" id="L68">        this.capacity = capacity;</span>
<span class="fc" id="L69">        clear();</span>
<span class="fc" id="L70">    }</span>
    
     public void clear() {
<span class="fc" id="L73">        itemTable = new ArrayList&lt;ArrayList&lt;Type&gt;&gt;(TOTAL_LEVEL);</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">        for (int i = 0; i &lt; TOTAL_LEVEL; i++) {</span>
<span class="fc" id="L75">            itemTable.add(new ArrayList&lt;Type&gt;());</span>
        }
<span class="fc" id="L77">        nameTable = new LinkedHashMap&lt;K, Type&gt;();</span>
<span class="fc" id="L78">        currentLevel = TOTAL_LEVEL - 1;</span>
<span class="fc" id="L79">        levelIndex = capacity % TOTAL_LEVEL; // so that different bags start at different point</span>
<span class="fc" id="L80">        mass = 0;</span>
<span class="fc" id="L81">        currentCounter = 0;</span>
<span class="fc" id="L82">    }</span>

    /**
     * Get the average priority of Items
     * @return The average priority of Items in the bag
     */
    public float getAveragePriority() {
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (nameTable.isEmpty()) {</span>
<span class="nc" id="L90">            return 0.01f;</span>
        }
<span class="fc" id="L92">        float f = (float) mass / (nameTable.size() * TOTAL_LEVEL);</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (f &gt; 1) {</span>
<span class="fc" id="L94">            return 1.0f;</span>
        }
<span class="fc" id="L96">        return f;</span>
    }

    /**
     * Check if an item is in the bag
     * @param it An item
     * @return Whether the Item is in the Bag
     */
    public boolean contains(Type it) {
<span class="nc" id="L105">        return nameTable.containsValue(it);</span>
    }

    /**
     * Get an Item by key
     * @param key The key of the Item
     * @return The Item with the given key
     */
    public Type get(K key) {
<span class="fc" id="L114">        return nameTable.get(key);</span>
    }

    /**
     * Add a new Item into the Bag
     * @param newItem The new Item
     * @return Whether the new Item is added into the Bag
     */
    public Type putIn(Type newItem) {
<span class="fc" id="L123">        K newKey = newItem.name();</span>
<span class="fc" id="L124">        Type oldItem = nameTable.put(newKey, newItem);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (oldItem != null) {                  // merge duplications</span>
<span class="fc" id="L126">            outOfBase(oldItem);</span>
<span class="fc" id="L127">            newItem.merge(oldItem);</span>
        }
<span class="fc" id="L129">        Type overflowItem = intoBase(newItem);  // put the (new or merged) item into itemTable</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (overflowItem != null) {             // remove overflow</span>
<span class="fc" id="L131">            K overflowKey = overflowItem.name();</span>
<span class="fc" id="L132">            nameTable.remove(overflowKey);</span>
<span class="fc" id="L133">            return overflowItem;</span>
        } else {
<span class="fc" id="L135">            return null;</span>
        }
    }
    
    /**
     * Put an item back into the itemTable
     * &lt;p&gt;
     * The only place where the forgetting rate is applied
     *
     * @param oldItem The Item to put back
     * @param m related memory
     * @return the item which was removed, or null if none removed
     */    
    public Type putBack(final Type oldItem, final float forgetCycles, final Memory m) {
<span class="fc" id="L149">        final float relativeThreshold = m.narParameters.FORGET_QUALITY_RELATIVE;</span>
<span class="fc" id="L150">        BudgetFunctions.applyForgetting(oldItem.budget, forgetCycles, relativeThreshold);</span>
<span class="fc" id="L151">        return putIn(oldItem);</span>
    }

    /**
     * Choose an Item according to priority distribution and take it out of the Bag
     * @return The selected Item
     */
    public Type takeOut() {
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (nameTable.isEmpty()) { // empty bag</span>
<span class="fc" id="L160">            return null;</span>
        }
<span class="fc bfc" id="L162" title="All 4 branches covered.">        if (emptyLevel(currentLevel) || (currentCounter == 0)) { // done with the current level</span>
<span class="fc" id="L163">            currentLevel = DISTRIBUTOR.pick(levelIndex);</span>
<span class="fc" id="L164">            levelIndex = DISTRIBUTOR.next(levelIndex);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            while (emptyLevel(currentLevel)) {          // look for a non-empty level</span>
<span class="fc" id="L166">                currentLevel = DISTRIBUTOR.pick(levelIndex);</span>
<span class="fc" id="L167">                levelIndex = DISTRIBUTOR.next(levelIndex);</span>
            }
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">            if (currentLevel &lt; THRESHOLD) { // for dormant levels, take one item</span>
<span class="fc" id="L170">                currentCounter = 1;</span>
            } else {                  // for active levels, take all current items
<span class="nc" id="L172">                currentCounter = itemTable.get(currentLevel).size();</span>
            }
        }
<span class="fc" id="L175">        Type selected = takeOutFirst(currentLevel); // take out the first item in the level</span>
<span class="fc" id="L176">        int belongingLevel = getLevel(selected);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if(currentLevel != belongingLevel) {</span>
<span class="fc" id="L178">            intoBase(selected);</span>
<span class="fc" id="L179">            return takeOut();</span>
        }
<span class="fc" id="L181">        currentCounter--;</span>
<span class="fc" id="L182">        nameTable.remove(selected.name());</span>
<span class="fc" id="L183">        return selected;</span>
    }

    /**
     * Pick an item by key, then remove it from the bag
     * @param key The given key
     * @return The Item with the key
     */
    public Type pickOut(K key) {
<span class="fc" id="L192">        Type picked = nameTable.get(key);</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (picked != null) {</span>
<span class="fc" id="L194">            outOfBase(picked);</span>
<span class="fc" id="L195">            nameTable.remove(key);</span>
        }
<span class="fc" id="L197">        return picked;</span>
    }
    public Type pickOut(Type val) {
<span class="fc" id="L200">        return pickOut(val.name());</span>
    }

    /**
     * Check whether a level is empty
     * @param n The level index
     * @return Whether that level is empty
     */
    protected boolean emptyLevel(int n) {
<span class="fc" id="L209">        return itemTable.get(n).isEmpty();</span>
    }

    /**
     * Decide the put-in level according to priority
     * @param item The Item to put in
     * @return The put-in level
     */
    private int getLevel(Type item) {
<span class="fc" id="L218">        float fl = item.getPriority() * TOTAL_LEVEL;</span>
<span class="fc" id="L219">        int level = (int) Math.ceil(fl) - 1;</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        return (level &lt; 0) ? 0 : level;     // cannot be -1</span>
    }

    /**
     * Insert an item into the itemTable, and return the overflow
     * @param newItem The Item to put in
     * @return The overflow Item
     */
    private Type intoBase(Type newItem) {
<span class="fc" id="L229">        Type oldItem = null;</span>
<span class="fc" id="L230">        int inLevel = getLevel(newItem);</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (nameTable.size() &gt; capacity) {      // the bag is full</span>
<span class="fc" id="L232">            int outLevel = 0;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">            while (emptyLevel(outLevel)) {</span>
<span class="fc" id="L234">                outLevel++;</span>
            }
<span class="fc bfc" id="L236" title="All 2 branches covered.">            if (outLevel &gt; inLevel) {           // ignore the item and exit</span>
<span class="fc" id="L237">                return newItem;</span>
            } else {                            // remove an old item in the lowest non-empty level
<span class="fc" id="L239">                oldItem = takeOutFirst(outLevel);</span>
            }
        }
<span class="fc" id="L242">        itemTable.get(inLevel).add(newItem);        // FIFO</span>
<span class="fc" id="L243">        mass += (inLevel + 1);                  // increase total mass</span>
<span class="fc" id="L244">        return oldItem;		// TODO return null is a bad smell</span>
    }

    /**
     * Take out the first or last Type in a level from the itemTable
     * @param level The current level
     * @return The first Item
     */
    private Type takeOutFirst(int level) {
<span class="fc" id="L253">        Type selected = itemTable.get(level).get(0);</span>
<span class="fc" id="L254">        itemTable.get(level).remove(0);</span>
<span class="fc" id="L255">        mass -= (level + 1);</span>
<span class="fc" id="L256">        return selected;</span>
    }

    /**
     * Remove an item from itemTable, then adjust mass
     * @param oldItem The Item to be removed
     */
    protected void outOfBase(Type oldItem) {
<span class="fc" id="L264">        int level = getLevel(oldItem);</span>
<span class="fc" id="L265">        itemTable.get(level).remove(oldItem);</span>
<span class="fc" id="L266">        mass -= (level + 1);</span>
<span class="fc" id="L267">    }</span>

    /**
     * Collect Bag content into a String for display
     */
    @Override
    public String toString() {
<span class="nc" id="L274">        StringBuffer buf = new StringBuffer(&quot; &quot;);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">	for (int i = TOTAL_LEVEL; i &gt;= 0 ; i--) {</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (!emptyLevel(i - 1)) {</span>
<span class="nc" id="L277">                buf = buf.append(&quot;\n --- Level &quot; + i + &quot;:\n &quot;);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">                for (int j = 0; j &lt; itemTable.get(i - 1).size(); j++) {</span>
<span class="nc" id="L279">                    buf = buf.append(itemTable.get(i - 1).get(j).toString() + &quot;\n &quot;);</span>
                }
            }
        }
<span class="nc" id="L283">        return buf.toString();</span>
    }
    
    /** TODO bad paste from preceding */
    public String toStringLong() {
<span class="nc" id="L288">        StringBuffer buf = new StringBuffer(&quot; BAG &quot; + getClass().getSimpleName() );</span>
<span class="nc" id="L289">        buf.append(&quot; &quot;).append( showSizes() );</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">		for (int i = TOTAL_LEVEL; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (!emptyLevel(i - 1)) {</span>
<span class="nc" id="L292">                buf = buf.append(&quot;\n --- LEVEL &quot; + i + &quot;:\n &quot;);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                for (int j = 0; j &lt; itemTable.get(i - 1).size(); j++) {</span>
<span class="nc" id="L294">                    buf = buf.append(itemTable.get(i - 1).get(j).toStringLong() + &quot;\n &quot;);</span>
                }
            }
        }
<span class="nc" id="L298">		buf.append(&quot;&gt;&gt;&gt;&gt; end of Bag&quot;).append( getClass().getSimpleName() );</span>
<span class="nc" id="L299">        return buf.toString();</span>
    }
    
    String showSizes() {
<span class="nc" id="L303">        StringBuilder buf = new StringBuilder(&quot; &quot;);</span>
<span class="nc" id="L304">    	int levels = 0;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">    	for ( ArrayList&lt;Type&gt; items : itemTable) {</span>
<span class="nc bnc" id="L306" title="All 4 branches missed.">            if ((items != null) &amp;&amp; ! items.isEmpty()) {</span>
<span class="nc" id="L307">				levels++;</span>
<span class="nc" id="L308">				buf.append( items.size() ).append( &quot; &quot; );</span>
            }
<span class="nc" id="L310">		}</span>
<span class="nc" id="L311">    	return &quot;Levels: &quot; + Integer.toString( levels ) + &quot;, sizes: &quot; + buf;</span>
    }
    
    public int size() { 
<span class="fc" id="L315">        return nameTable.size();</span>
    }

    @Override
    public Iterator&lt;Type&gt; iterator() {
<span class="fc" id="L320">        return nameTable.values().iterator();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>