<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StructuralRules.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.inference</a> &gt; <span class="el_source">StructuralRules.java</span></div><h1>StructuralRules.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.inference;

import org.opennars.control.DerivationContext;
import org.opennars.entity.BudgetValue;
import org.opennars.entity.Sentence;
import org.opennars.entity.Task;
import org.opennars.entity.TruthValue;
import org.opennars.io.Symbols;
import org.opennars.language.*;
import org.opennars.storage.Memory;

import java.util.List;

/**
 * Single-premise inference rules involving compound terms. Input are one
 * sentence (the premise) and one TermLink (indicating a component)
 *
 * @author Pei Wang
 * @author Patrick Hammer
 */
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">public final class StructuralRules {</span>

   

    /* -------------------- transform between compounds and term -------------------- */
    /**
     * {&amp;lt;S --&amp;gt; P&amp;gt;, S@(S&amp;amp;T)} |- &amp;lt;(S&amp;amp;T) --&amp;gt; (P&amp;amp;T)&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;S --&amp;gt; P&amp;gt;, S@(M-S)} |- &amp;lt;(M-P) --&amp;gt; (M-S)&amp;gt;
     *
     * @param compound The compound term
     * @param index The location of the indicated term in the compound
     * @param statement The premise
     * @param side The location of the indicated term in the premise
     * @param nal Reference to the memory
     */
    static void structuralCompose2(final CompoundTerm compound, final short index, final Statement statement, final short side, final DerivationContext nal) {
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if (compound.equals(statement.term[side])) {</span>
<span class="fc" id="L62">            return;</span>
        }
<span class="fc" id="L64">        Term sub = statement.getSubject();</span>
<span class="fc" id="L65">        Term pred = statement.getPredicate();</span>
<span class="fc" id="L66">        final List&lt;Term&gt; components = compound.asTermList();</span>
<span class="fc bfc" id="L67" title="All 8 branches covered.">        if (((side == 0) &amp;&amp; components.contains(pred)) || ((side == 1) &amp;&amp; components.contains(sub))) {</span>
<span class="fc" id="L68">            return;</span>
        }
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if (side == 0) {</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">            if (components.contains(sub)) {</span>
<span class="fc" id="L72">                sub = compound;</span>
<span class="fc" id="L73">                components.set(index, pred.cloneDeep());</span>
<span class="fc" id="L74">                pred = Terms.term(compound, components);</span>
            }
        } else {
<span class="fc bfc" id="L77" title="All 2 branches covered.">            if (components.contains(pred)) {</span>
<span class="fc" id="L78">                components.set(index, sub.cloneDeep());</span>
<span class="fc" id="L79">                sub = Terms.term(compound, components);</span>
<span class="fc" id="L80">                pred = compound;</span>
            }
        }
        
<span class="pc bpc" id="L84" title="2 of 4 branches missed.">        if ((sub == null) || (pred == null)) {</span>
<span class="nc" id="L85">            return;</span>
        }
<span class="fc bfc" id="L87" title="All 2 branches covered.">        if(sub.cloneDeep().equals(pred.cloneDeep())) {</span>
<span class="fc" id="L88">            return;</span>
        }       
        final Statement content;
<span class="fc" id="L91">        final int order = statement.getTemporalOrder();</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (switchOrder(compound, index)) {</span>
<span class="fc" id="L93">            content = Statement.make(statement, pred, sub, TemporalRules.reverseOrder(order));</span>
        } else {
<span class="fc" id="L95">            content = Statement.make(statement, sub, pred, order);</span>
        }
        
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (content == null) {</span>
<span class="fc" id="L99">            return;</span>
        }
        
<span class="fc" id="L102">        final Sentence sentence = nal.getCurrentTask().sentence;</span>
<span class="fc" id="L103">        final TruthValue truth = TruthFunctions.deduction(sentence.truth, nal.narParameters.reliance, nal.narParameters);</span>
<span class="fc" id="L104">        final BudgetValue budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
<span class="fc" id="L105">        nal.singlePremiseTask(content, truth, budget);</span>
<span class="fc" id="L106">    }</span>

    /**
     * {&amp;lt;(S*T) --&amp;gt; (P*T)&amp;gt;, S@(S*T)} |- &amp;lt;S --&amp;gt; P&amp;gt;
     *
     * @param statement The premise
     * @param nal Reference to the memory
     */
    static void structuralDecompose2(final Statement statement, final int index, final DerivationContext nal) {
<span class="fc" id="L115">        final Term subj = statement.getSubject();</span>
<span class="fc" id="L116">        final Term pred = statement.getPredicate();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (subj.getClass() != pred.getClass()) {</span>
<span class="fc" id="L118">            return;</span>
        }
        
<span class="fc bfc" id="L121" title="All 6 branches covered.">        if (!(subj instanceof Product) &amp;&amp; !(subj instanceof SetExt) &amp;&amp; !(subj instanceof SetInt)) {</span>
<span class="fc" id="L122">            return; // no abduction on other compounds for now, but may change in the future</span>
        }
        
<span class="fc" id="L125">        final CompoundTerm sub = (CompoundTerm) subj;</span>
<span class="fc" id="L126">        final CompoundTerm pre = (CompoundTerm) pred;</span>
<span class="pc bpc" id="L127" title="1 of 4 branches missed.">        if (sub.size() != pre.size() || sub.size() &lt;= index) {</span>
<span class="fc" id="L128">            return;</span>
        }
        
<span class="fc" id="L131">        final Term t1 = sub.term[index];</span>
<span class="fc" id="L132">        final Term t2 = pre.term[index];</span>
        final Statement content;
<span class="fc" id="L134">        final int order = statement.getTemporalOrder();</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (switchOrder(sub, (short) index)) {</span>
<span class="nc" id="L136">            content = Statement.make(statement, t2, t1, TemporalRules.reverseOrder(order));</span>
        } else {
<span class="fc" id="L138">            content = Statement.make(statement, t1, t2, order);</span>
        }
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (content == null) {</span>
<span class="fc" id="L141">            return;</span>
        }
<span class="fc" id="L143">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L144">        final Sentence sentence = task.sentence;</span>
<span class="fc" id="L145">        final TruthValue truth = sentence.truth;</span>
        final BudgetValue budget;
<span class="pc bpc" id="L147" title="1 of 4 branches missed.">        if (sentence.isQuestion() || sentence.isQuest()) {</span>
<span class="fc" id="L148">            budget = BudgetFunctions.compoundBackward(content, nal);</span>
        } else {
<span class="fc" id="L150">            budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
        }
<span class="fc" id="L152">        nal.singlePremiseTask(content, truth, budget);</span>
<span class="fc" id="L153">    }</span>

    /**
     * List the cases where the direction of inheritance is revised in conclusion
     *
     * @param compound The compound term
     * @param index The location of focus in the compound
     * @return Whether the direction of inheritance should be revised
     */
    private static boolean switchOrder(final CompoundTerm compound, final short index) {
<span class="fc bfc" id="L163" title="All 14 branches covered.">        return ((((compound instanceof DifferenceExt) || (compound instanceof DifferenceInt)) &amp;&amp; (index == 1))</span>
                || ((compound instanceof ImageExt) &amp;&amp; (index != ((ImageExt) compound).relationIndex))
                || ((compound instanceof ImageInt) &amp;&amp; (index != ((ImageInt) compound).relationIndex)));
    }

    /**
     * {&amp;lt;S --&amp;gt; P&amp;gt;, P@(P|Q)} |- &amp;lt;S --&amp;gt; (P|Q)&amp;gt;
     *
     * @param compound The compound term
     * @param index The location of the indicated term in the compound
     * @param statement The premise
     * @param nal Reference to the memory
     */
    static void structuralCompose1(final CompoundTerm compound, final short index, final Statement statement, final DerivationContext nal) {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (!nal.getCurrentTask().sentence.isJudgment()) {</span>
<span class="nc" id="L178">            return;     // forward inference only</span>
        }
<span class="fc" id="L180">        final Term component = compound.term[index];</span>
<span class="fc" id="L181">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L182">        final Sentence sentence = task.sentence;</span>
<span class="fc" id="L183">        final int order = sentence.getTemporalOrder();</span>
<span class="fc" id="L184">        final TruthValue truth = sentence.truth;</span>
        
<span class="fc" id="L186">        final float reliance = nal.narParameters.reliance;</span>
<span class="fc" id="L187">        final TruthValue truthDed = TruthFunctions.deduction(truth, reliance, nal.narParameters);</span>
<span class="fc" id="L188">        final TruthValue truthNDed = TruthFunctions.negation(TruthFunctions.deduction(truth, reliance, nal.narParameters), nal.narParameters);</span>
        
<span class="fc" id="L190">        final Term subj = statement.getSubject();</span>
<span class="fc" id="L191">        final Term pred = statement.getPredicate();</span>
        
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (component.equals(subj)) {</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if (compound instanceof IntersectionExt) {</span>
<span class="fc" id="L195">                structuralStatement(compound, pred, order, truthDed, nal);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            } else if (compound instanceof IntersectionInt) {</span>
<span class="fc bfc" id="L197" title="All 4 branches covered.">            } else if ((compound instanceof DifferenceExt) &amp;&amp; (index == 0)) {</span>
<span class="fc" id="L198">                structuralStatement(compound, pred, order, truthDed, nal);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">            } else if (compound instanceof DifferenceInt) {</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">                if (index == 0) {</span>
                } else {
<span class="fc" id="L202">                    structuralStatement(compound, pred, order, truthNDed, nal);</span>
                }
            }
<span class="fc bfc" id="L205" title="All 2 branches covered.">        } else if (component.equals(pred)) {</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (compound instanceof IntersectionExt) {</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            } else if (compound instanceof IntersectionInt) {</span>
<span class="fc" id="L208">                structuralStatement(subj, compound, order, truthDed, nal);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">            } else if (compound instanceof DifferenceExt) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                if (index == 0) {</span>
                } else {
<span class="fc" id="L212">                    structuralStatement(subj, compound, order, truthNDed, nal);</span>
                }
<span class="fc bfc" id="L214" title="All 4 branches covered.">            } else if ((compound instanceof DifferenceInt) &amp;&amp; (index == 0)) {</span>
<span class="fc" id="L215">                structuralStatement(subj, compound, order, truthDed, nal);</span>
            }
        }
<span class="fc" id="L218">    }</span>

    /**
     * {&amp;lt;(S|T) --&amp;gt; P&amp;gt;, S@(S|T)} |- &amp;lt;S --&amp;gt; P&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;S --&amp;gt; (P&amp;amp;T)&amp;gt;, P@(P&amp;amp;T)} |- &amp;lt;S --&amp;gt; P&amp;gt;
     *
     * @param compound The compound term
     * @param index The location of the indicated term in the compound
     * @param statement The premise
     * @param nal Reference to the memory
     */
    static void structuralDecompose1(final CompoundTerm compound, final short index, final Statement statement, final DerivationContext nal) {
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if(index &gt;= compound.term.length) {</span>
<span class="nc" id="L232">            return;</span>
        }
<span class="fc" id="L234">        final Term component = compound.term[index];</span>
<span class="fc" id="L235">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L236">        final Sentence sentence = task.sentence;</span>
<span class="fc" id="L237">        final int order = sentence.getTemporalOrder();</span>
<span class="fc" id="L238">        final TruthValue truth = sentence.truth;</span>
        
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (truth == null) {</span>
<span class="fc" id="L241">            return;</span>
        }
        
<span class="fc" id="L244">        final float reliance = nal.narParameters.reliance;</span>
<span class="fc" id="L245">        final TruthValue truthDed = TruthFunctions.deduction(truth, reliance, nal.narParameters);</span>
<span class="fc" id="L246">        final TruthValue truthNDed = TruthFunctions.negation(TruthFunctions.deduction(truth, reliance, nal.narParameters), nal.narParameters);</span>
        
<span class="fc" id="L248">        final Term subj = statement.getSubject();</span>
<span class="fc" id="L249">        final Term pred = statement.getPredicate();</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (compound.equals(subj)) {</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (compound instanceof IntersectionInt) {</span>
<span class="fc" id="L252">                structuralStatement(component, pred, order, truthDed, nal);</span>
<span class="fc bfc" id="L253" title="All 4 branches covered.">            } else if ((compound instanceof SetExt) &amp;&amp; (compound.size() &gt; 1)) {</span>
<span class="fc" id="L254">                final Term[] t1 = new Term[]{component};</span>
<span class="fc" id="L255">                structuralStatement(new SetExt(t1), pred, order, truthDed, nal);</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            } else if (compound instanceof DifferenceInt) {</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">                if (index == 0) {</span>
<span class="fc" id="L258">                    structuralStatement(component, pred, order, truthDed, nal);</span>
                } else {
<span class="fc" id="L260">                    structuralStatement(component, pred, order, truthNDed, nal);</span>
                }
            }
<span class="fc bfc" id="L263" title="All 2 branches covered.">        } else if (compound.equals(pred)) {</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">            if (compound instanceof IntersectionExt) {</span>
<span class="fc" id="L265">                structuralStatement(subj, component, order, truthDed, nal);</span>
<span class="fc bfc" id="L266" title="All 4 branches covered.">            } else if ((compound instanceof SetInt) &amp;&amp; (compound.size() &gt; 1)) {</span>
<span class="fc" id="L267">                structuralStatement(subj, new SetInt(component), order, truthDed, nal);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            } else if (compound instanceof DifferenceExt) {</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">                if (index == 0) {</span>
<span class="fc" id="L270">                    structuralStatement(subj, component, order, truthDed, nal);</span>
                } else {
<span class="fc" id="L272">                    structuralStatement(subj, component, order, truthNDed, nal);</span>
                }
            }
        }
<span class="fc" id="L276">    }</span>

    /**
     * Common final operations of the above two methods
     *
     * @param subject The subject of the new task
     * @param predicate The predicate of the new task
     * @param truth The truth value of the new task
     * @param nal Reference to the memory
     */
    private static void structuralStatement(final Term subject, final Term predicate, final int order, final TruthValue truth, final DerivationContext nal) {
<span class="fc" id="L287">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L288">        final Term oldContent = task.getTerm();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (oldContent instanceof Statement) {</span>
<span class="fc" id="L290">            final Statement content = Statement.make((Statement) oldContent, subject, predicate, order);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (content != null) {</span>
<span class="fc" id="L292">                final BudgetValue budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
<span class="fc" id="L293">                nal.singlePremiseTask(content, truth, budget);</span>
            }
        }
<span class="fc" id="L296">    }</span>

    /* -------------------- set transform -------------------- */
    /**
     * {&amp;lt;S --&amp;gt; {P}&amp;gt;} |- &amp;lt;S &amp;lt;-&amp;gt; {P}&amp;gt;
     *
     * @param compound The set compound
     * @param statement The premise
     * @param side The location of the indicated term in the premise
     * @param nal Reference to the memory
     */
    static void transformSetRelation(final CompoundTerm compound, final Statement statement, final short side, final DerivationContext nal) {
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (compound.size() &gt; 1) {</span>
<span class="fc" id="L309">            return;</span>
        }
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (statement instanceof Inheritance) {</span>
<span class="fc bfc" id="L312" title="All 8 branches covered.">            if (((compound instanceof SetExt) &amp;&amp; (side == 0)) || ((compound instanceof SetInt) &amp;&amp; (side == 1))) {</span>
<span class="fc" id="L313">                return;</span>
            }
        }
<span class="fc" id="L316">        final Term sub = statement.getSubject();</span>
<span class="fc" id="L317">        final Term pre = statement.getPredicate();</span>
        final Statement content;
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (statement instanceof Inheritance) {</span>
<span class="fc" id="L320">            content = Similarity.make(sub, pre);</span>
        } else {
<span class="fc bfc" id="L322" title="All 8 branches covered.">            if (((compound instanceof SetExt) &amp;&amp; (side == 0)) || ((compound instanceof SetInt) &amp;&amp; (side == 1))) {</span>
<span class="fc" id="L323">                content = Inheritance.make(pre, sub);</span>
            } else {
<span class="fc" id="L325">                content = Inheritance.make(sub, pre);</span>
            }
        }
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (content == null) {</span>
<span class="nc" id="L329">            return;</span>
        }

<span class="fc" id="L332">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L333">        final Sentence sentence = task.sentence;</span>
<span class="fc" id="L334">        final TruthValue truth = sentence.truth;</span>
        final BudgetValue budget;
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (sentence.isJudgment()) {</span>
<span class="fc" id="L337">            budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
        } else {
<span class="fc" id="L339">            budget = BudgetFunctions.compoundBackward(content, nal);</span>
        }
<span class="fc" id="L341">        nal.singlePremiseTask(content, truth, budget);</span>
<span class="fc" id="L342">    }</span>

    /* -------------------- products and images transform -------------------- */
    /**
     * Equivalent transformation between products and images
     *
     * {&amp;lt;(*, S, M) --&amp;gt; P&amp;gt;, S@(*, S, M)} |- &amp;lt;S --&amp;gt; (/, P, _, M)&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;S --&amp;gt; (/, P, _, M)&amp;gt;, P@(/, P, _, M)} |- &amp;lt;(*, S, M) --&amp;gt; P&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;S --&amp;gt; (/, P, _, M)&amp;gt;, M@(/, P, _, M)} |- &amp;lt;M --&amp;gt; (/, P, S, _)&amp;gt;
     *
     * @param inh An Inheritance statement
     * @param oldContent The whole content
     * @param indices The indices of the TaskLink
     * @param nal Reference to the memory
     */
    static void transformProductImage(final Inheritance inh, final CompoundTerm oldContent, final short[] indices, final DerivationContext nal) {
<span class="fc" id="L360">        final Memory memory = nal.mem();</span>
<span class="fc" id="L361">        Term subject = inh.getSubject();</span>
<span class="fc" id="L362">        Term predicate = inh.getPredicate();</span>
<span class="fc" id="L363">        final short index = indices[indices.length - 1];</span>
<span class="fc" id="L364">        final short side = indices[indices.length - 2];</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        if (inh.equals(oldContent)) {</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">            if (subject instanceof CompoundTerm) {</span>
<span class="fc" id="L367">                transformSubjectPI(index, (CompoundTerm) subject, predicate, nal);</span>
            }
<span class="fc bfc" id="L369" title="All 2 branches covered.">            if (predicate instanceof CompoundTerm) {</span>
<span class="fc" id="L370">                transformPredicatePI(index, subject, (CompoundTerm) predicate, nal);</span>
            }
<span class="fc" id="L372">            return;</span>
        }

<span class="fc" id="L375">        final Term compT = inh.term[side];</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (!(compT instanceof CompoundTerm))</span>
<span class="fc" id="L377">            return;</span>
<span class="fc" id="L378">        final CompoundTerm comp = (CompoundTerm)compT;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">        if(comp.size() &lt;= index) { //make sure it points into the compound</span>
<span class="fc" id="L380">            return;</span>
        }
        
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (comp instanceof Product) {</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">            if (side == 0) {</span>
<span class="fc" id="L385">                subject = comp.term[index];</span>
<span class="fc" id="L386">                predicate = ImageExt.make((Product) comp, inh.getPredicate(), index);</span>
            } else {
<span class="fc" id="L388">                subject = ImageInt.make((Product) comp, inh.getSubject(), index);</span>
<span class="fc" id="L389">                predicate = comp.term[index];</span>
            }
<span class="fc bfc" id="L391" title="All 4 branches covered.">        } else if ((comp instanceof ImageExt) &amp;&amp; (side == 1)) {</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">            if (index == ((ImageExt) comp).relationIndex) {</span>
<span class="fc" id="L393">                subject = Product.make(comp, inh.getSubject(), index);</span>
<span class="fc" id="L394">                predicate = comp.term[index];</span>
            } else {
<span class="fc" id="L396">                subject = comp.term[index];</span>
<span class="fc" id="L397">                predicate = ImageExt.make((ImageExt) comp, inh.getSubject(), index);</span>
            }
<span class="fc bfc" id="L399" title="All 4 branches covered.">        } else if ((comp instanceof ImageInt) &amp;&amp; (side == 0)) {</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">            if (index == ((ImageInt) comp).relationIndex) {</span>
<span class="fc" id="L401">                subject = comp.term[index];</span>
<span class="fc" id="L402">                predicate = Product.make(comp, inh.getPredicate(), index);</span>
            } else {
<span class="nc" id="L404">                subject = ImageInt.make((ImageInt) comp, inh.getPredicate(), index);</span>
<span class="nc" id="L405">                predicate = comp.term[index];</span>
            }
        } else {
<span class="fc" id="L408">            return;</span>
        }
        
<span class="fc" id="L411">        CompoundTerm newInh = null;</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if(predicate.equals(Term.SEQ_SPATIAL)) {</span>
<span class="fc" id="L413">            newInh = (CompoundTerm) Conjunction.make(((CompoundTerm) subject).term, TemporalRules.ORDER_FORWARD, true);</span>
        } else
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if(predicate.equals(Term.SEQ_TEMPORAL)) {</span>
<span class="fc" id="L416">            newInh = (CompoundTerm) Conjunction.make(((CompoundTerm) subject).term, TemporalRules.ORDER_FORWARD, false);</span>
        }
        else 
        {
<span class="fc" id="L420">            newInh = Inheritance.make(subject, predicate);</span>
        }
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">        if (newInh == null)</span>
<span class="nc" id="L423">            return;</span>
        
<span class="fc" id="L425">        CompoundTerm content = null;</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        if (indices.length == 2) {</span>
<span class="nc" id="L427">            content = newInh;</span>
<span class="fc bfc" id="L428" title="All 4 branches covered.">        } else if ((oldContent instanceof Statement) &amp;&amp; (indices[0] == 1)) {</span>
<span class="fc" id="L429">            content = Statement.make((Statement) oldContent, oldContent.term[0], newInh, oldContent.getTemporalOrder());</span>
        } else {
            final Term[] componentList;
<span class="fc" id="L432">            final Term condition = oldContent.term[0];</span>
            
<span class="fc bfc" id="L434" title="All 4 branches covered.">            final boolean oldContentIsImplicationOrEquivalence = oldContent instanceof Implication || oldContent instanceof Equivalence;</span>
<span class="fc bfc" id="L435" title="All 4 branches covered.">            if (condition instanceof Conjunction &amp;&amp; oldContentIsImplicationOrEquivalence) {</span>
                // ex: &lt;(&amp;&amp;,&lt;(*,a,b) --&gt; R&gt;,...) ==&gt; C&gt;. |- &lt;(&amp;&amp;,&lt;a --&gt; (/,R,_,b)&gt;,...) ==&gt; C&gt;
                // ex: &lt;(&amp;&amp;,&lt;(*,a,b) --&gt; R&gt;,...) &lt;=&gt; C&gt;. |- &lt;(&amp;&amp;,&lt;a --&gt; (/,R,_,b)&gt;,...) &lt;=&gt; C&gt;
                
<span class="fc" id="L439">                componentList = ((CompoundTerm) condition).cloneTerms();</span>
<span class="fc" id="L440">                componentList[indices[1]] = newInh;</span>
<span class="fc" id="L441">                final Term newCond = Terms.term((CompoundTerm) condition, componentList);</span>
<span class="fc" id="L442">                content = Statement.make((Statement) oldContent, newCond, ((Statement) oldContent).getPredicate(), oldContent.getTemporalOrder());</span>
<span class="fc" id="L443">            } else {</span>
<span class="fc" id="L444">                componentList = oldContent.cloneTerms();</span>
<span class="fc" id="L445">                componentList[indices[0]] = newInh;</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">                if (oldContent instanceof Conjunction) {</span>
                    // ex: (&amp;&amp;,&lt;(*,a,b) --&gt; R&gt;,...) |- (&amp;&amp;,&lt;a --&gt; (/,R,_,b)&gt;,...)
                    
<span class="fc" id="L449">                    final Term newContent = Terms.term(oldContent, componentList);</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">                    if (!(newContent instanceof CompoundTerm))</span>
<span class="nc" id="L451">                        return;</span>
<span class="fc" id="L452">                    content = (CompoundTerm)newContent;</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">                } else if (oldContentIsImplicationOrEquivalence) {</span>
                    // ex: &lt;&lt;(*,a,b) --&gt; R&gt; ==&gt; C&gt;. |- &lt;&lt;a --&gt; (/,R,_,b)&gt; ==&gt; C&gt;
                    // ex: &lt;&lt;(*,a,b) --&gt; R&gt; &lt;=&gt; C&gt;. |- &lt;&lt;a --&gt; (/,R,_,b)&gt; &lt;=&gt; C&gt;
                    
<span class="fc" id="L457">                    content = Statement.make((Statement) oldContent, componentList[0], componentList[1], oldContent.getTemporalOrder());</span>
                }
            }
        }
        
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (content == null)</span>
<span class="fc" id="L463">            return;</span>
        
<span class="fc" id="L465">        final Sentence sentence = nal.getCurrentTask().sentence;</span>
<span class="fc" id="L466">        final TruthValue truth = sentence.truth;</span>
        final BudgetValue budget;
<span class="pc bpc" id="L468" title="1 of 4 branches missed.">        if (sentence.isQuestion() || sentence.isQuest()) {</span>
<span class="fc" id="L469">            budget = BudgetFunctions.compoundBackward(content, nal);</span>
        } else {
<span class="fc" id="L471">            budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
        }
        
<span class="fc" id="L474">        nal.singlePremiseTask(content, truth, budget);</span>
<span class="fc" id="L475">    }</span>

    /**
     * Equivalent transformation between products and images when the subject is
     * a compound
     *
     * {&amp;lt;(*, S, M) --&amp;gt; P&amp;gt;, S@(*, S, M)} |- &amp;lt;S --&amp;gt; (/, P, _, M)&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;S --&amp;gt; (/, P, _, M)&amp;gt;, P@(/, P, _, M)} |- &amp;lt;(*, S, M) --&amp;gt; P&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;S --&amp;gt; (/, P, _, M)&amp;gt;, M@(/, P, _, M)} |- &amp;lt;M --&amp;gt; (/, P, S, _)&amp;gt;
     *
     * @param subject The subject term
     * @param predicate The predicate term
     * @param nal Reference to the memory
     */
    private static void transformSubjectPI(final short index, final CompoundTerm subject, final Term predicate, final DerivationContext nal) {
<span class="fc" id="L492">        final TruthValue truth = nal.getCurrentTask().sentence.truth;</span>
        BudgetValue budget;
        Inheritance inheritance;
        Term newSubj, newPred;
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (subject instanceof Product) {</span>
<span class="fc" id="L497">            final Product product = (Product) subject;</span>
<span class="fc" id="L498">            final short i = index;</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">            if( product.term.length &gt;= i + 1) {</span>
<span class="fc" id="L500">                newSubj = product.term[i];</span>
<span class="fc" id="L501">                newPred = ImageExt.make(product, predicate, i);</span>
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">                if (!(newSubj instanceof Interval)) { //no intervals as subjects</span>
<span class="fc" id="L503">                    inheritance = Inheritance.make(newSubj, newPred);</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">                    if (inheritance != null) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">                        if (truth == null) {</span>
<span class="fc" id="L506">                            budget = BudgetFunctions.compoundBackward(inheritance, nal);</span>
                        } else {
<span class="fc" id="L508">                            budget = BudgetFunctions.compoundForward(truth, inheritance, nal);</span>
                        }
<span class="fc" id="L510">                        nal.singlePremiseTask(inheritance, truth, budget);</span>
                    }
                }
            }
<span class="fc bfc" id="L514" title="All 2 branches covered.">        } else if (subject instanceof ImageInt) {</span>
<span class="fc" id="L515">            final ImageInt image = (ImageInt) subject;</span>
<span class="fc" id="L516">            final int relationIndex = image.relationIndex;</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">            for (short i = 0; i &lt; image.size(); i++) {</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">                if (i == relationIndex) {</span>
<span class="fc" id="L519">                    newSubj = image.term[relationIndex];</span>
<span class="fc" id="L520">                    newPred = Product.make(image, predicate, relationIndex);</span>
                } else {
<span class="fc" id="L522">                    newSubj = ImageInt.make(image, predicate, i);</span>
<span class="fc" id="L523">                    newPred = image.term[i];</span>
                }
                
<span class="fc" id="L526">                inheritance = Inheritance.make(newSubj, newPred);</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">                if (inheritance != null) {</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">                    if (truth == null) {</span>
<span class="fc" id="L529">                        budget = BudgetFunctions.compoundBackward(inheritance, nal);</span>
                    } else {
<span class="fc" id="L531">                        budget = BudgetFunctions.compoundForward(truth, inheritance, nal);</span>
                    }
<span class="fc" id="L533">                    nal.singlePremiseTask(inheritance, truth, budget);</span>
                }
            }
        }
<span class="fc" id="L537">    }</span>

    /**
     * Equivalent transformation between products and images when the predicate
     * is a compound
     *
     * {&amp;lt;(*, S, M) --&amp;gt; P&amp;gt;, S@(*, S, M)} |- &amp;lt;S --&amp;gt; (/, P, _, M)&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;S --&amp;gt; (/, P, _, M)&amp;gt;, P@(/, P, _, M)} |- &amp;lt;(*, S, M) --&amp;gt; P&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;S --&amp;gt; (/, P, _, M)&amp;gt;, M@(/, P, _, M)} |- &amp;lt;M --&amp;gt; (/, P, S, _)&amp;gt;
     *
     * @param subject The subject term
     * @param predicate The predicate term
     * @param nal Reference to the memory
     */
    private static void transformPredicatePI(final short index, final Term subject, final CompoundTerm predicate, final DerivationContext nal) {
<span class="fc" id="L554">        final TruthValue truth = nal.getCurrentTask().sentence.truth;</span>
        BudgetValue budget;
        Inheritance inheritance;
        Term newSubj, newPred;
<span class="fc bfc" id="L558" title="All 2 branches covered.">        if (predicate instanceof Product) {</span>
<span class="fc" id="L559">            final Product product = (Product) predicate;</span>
<span class="fc" id="L560">            final short i = index;</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">            if (product.term.length &gt;= i+1) {</span>
<span class="fc" id="L562">                newSubj = ImageInt.make(product, subject, i);</span>
<span class="fc" id="L563">                newPred = product.term[i];</span>
<span class="fc" id="L564">                inheritance = Inheritance.make(newSubj, newPred);</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">                if (inheritance != null) {</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">                    if (truth == null) {</span>
<span class="fc" id="L567">                        budget = BudgetFunctions.compoundBackward(inheritance, nal);</span>
                    } else {
<span class="fc" id="L569">                        budget = BudgetFunctions.compoundForward(truth, inheritance, nal);</span>
                    }
<span class="fc" id="L571">                    nal.singlePremiseTask(inheritance, truth, budget);</span>
                }
            }
<span class="fc bfc" id="L574" title="All 2 branches covered.">        } else if (predicate instanceof ImageExt) {</span>
<span class="fc" id="L575">            final ImageExt image = (ImageExt) predicate;</span>
<span class="fc" id="L576">            final int relationIndex = image.relationIndex;</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">            for (short i = 0; i &lt; image.size(); i++) {</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                if (i == relationIndex) {</span>
<span class="fc" id="L579">                    newSubj = Product.make(image, subject, relationIndex);</span>
<span class="fc" id="L580">                    newPred = image.term[relationIndex];</span>
                } else {
<span class="fc" id="L582">                    newSubj = image.term[i];</span>
<span class="fc" id="L583">                    newPred = ImageExt.make(image, subject, i);</span>
                }
                
<span class="fc bfc" id="L586" title="All 2 branches covered.">                if(newSubj instanceof CompoundTerm &amp;&amp; </span>
<span class="fc bfc" id="L587" title="All 4 branches covered.">                        (newPred.equals(Term.SEQ_TEMPORAL) || newPred.equals(Term.SEQ_SPATIAL))) {</span>
<span class="fc" id="L588">                    final Term seq = Conjunction.make(((CompoundTerm)newSubj).term,</span>
                                                TemporalRules.ORDER_FORWARD, 
<span class="fc" id="L590">                                                newPred.equals(Term.SEQ_SPATIAL));</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">                    if (truth == null) {</span>
<span class="fc" id="L592">                        budget = BudgetFunctions.compoundBackward(seq, nal);</span>
                    } else {
<span class="fc" id="L594">                        budget = BudgetFunctions.compoundForward(truth, seq, nal);</span>
                    }
<span class="fc" id="L596">                    nal.singlePremiseTask(seq, truth, budget);</span>
<span class="fc" id="L597">                    return;</span>
                }
                
<span class="fc" id="L600">                inheritance = Inheritance.make(newSubj, newPred);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">                if (inheritance != null) { // jmv &lt;&lt;&lt;&lt;&lt;</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">                    if (truth == null) {</span>
<span class="fc" id="L603">                        budget = BudgetFunctions.compoundBackward(inheritance, nal);</span>
                    } else {
<span class="fc" id="L605">                        budget = BudgetFunctions.compoundForward(truth, inheritance, nal);</span>
                    }
<span class="fc" id="L607">                    nal.singlePremiseTask(inheritance, truth, budget);</span>
                }
            }
        }
<span class="fc" id="L611">    }</span>

    /* --------------- Flatten sequence transform --------------- */
    /**
     * {(#,(#,A,B),C), (#,A,B)@(#,(#,A,B), C)} |- (#,A,B,C)
     * (same for &amp;amp;/)
     *
     * @param compound The premise
     * @param component The recognized component in the premise
     * @param compoundTask Whether the compound comes from the task
     * @param nal Reference to the memory
     */
    static void flattenSequence(final CompoundTerm compound, final Term component, final boolean compoundTask, final int index, final DerivationContext nal) {
<span class="nc bnc" id="L624" title="All 4 branches missed.">        if(compound instanceof Conjunction &amp;&amp; component instanceof Conjunction) {</span>
<span class="nc" id="L625">            final Conjunction conjCompound = (Conjunction) compound;</span>
<span class="nc" id="L626">            final Conjunction conjComponent = (Conjunction) component;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">            if(conjCompound.getTemporalOrder() == TemporalRules.ORDER_FORWARD &amp;&amp; //since parallel conjunction and normal one already is flattened</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">                    conjComponent.getTemporalOrder() == TemporalRules.ORDER_FORWARD &amp;&amp;</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">                    conjCompound.getIsSpatial() == conjComponent.getIsSpatial()) { //because also when both are tmporal</span>
<span class="nc" id="L630">                final Term[] newTerm = new Term[conjCompound.size() - 1 + conjComponent.size()];</span>
<span class="nc" id="L631">                System.arraycopy(conjCompound.term, 0, newTerm, 0, index);</span>
<span class="nc" id="L632">                System.arraycopy(conjComponent.term, 0, newTerm, index + 0, conjComponent.size());</span>
<span class="nc" id="L633">                System.arraycopy(conjCompound.term, index + conjComponent.size() - conjComponent.size() + 1, newTerm, index + conjComponent.size(), newTerm.length - (index + conjComponent.size()));</span>
<span class="nc" id="L634">                final Conjunction cont = (Conjunction) Conjunction.make(newTerm, conjCompound.getTemporalOrder(), conjCompound.getIsSpatial());</span>
<span class="nc" id="L635">                final TruthValue truth = nal.getCurrentTask().sentence.truth.clone();</span>
<span class="nc" id="L636">                final BudgetValue budget = BudgetFunctions.forward(truth, nal);</span>
<span class="nc" id="L637">                nal.singlePremiseTask(cont, truth, budget);</span>
            }
        }
<span class="nc" id="L640">    }</span>
    
    /* --------------- Take out from conjunction --------------- */
    /**
     * {(&amp;amp;&amp;amp;,A,B,C), B@(&amp;amp;&amp;amp;,A,B,C)} |- (&amp;amp;&amp;amp;,A,C)
     *
     * Works for all conjunctions
     *
     * @param compound The premise
     * @param component The recognized component in the premise
     * @param compoundTask Whether the compound comes from the task
     * @param nal Reference to the memory
     */
    static void takeOutFromConjunction(final CompoundTerm compound, final Term component, final boolean compoundTask, final int index, final DerivationContext nal) {
<span class="nc bnc" id="L654" title="All 2 branches missed.">        if(compound instanceof Conjunction) {</span>
<span class="nc" id="L655">            final Conjunction conjCompound = (Conjunction) compound;</span>
<span class="nc" id="L656">            final Term[] newTerm = new Term[conjCompound.size() - 1];</span>
<span class="nc" id="L657">            System.arraycopy(conjCompound.term, 0, newTerm, 0, index);</span>
<span class="nc" id="L658">            System.arraycopy(conjCompound.term, index + 1, newTerm, index, newTerm.length - index);</span>
<span class="nc" id="L659">            final Term cont = Conjunction.make(newTerm, conjCompound.getTemporalOrder(), conjCompound.getIsSpatial());</span>
<span class="nc" id="L660">            Sentence curS = nal.getCurrentTask().sentence;</span>
<span class="nc" id="L661">            TruthValue truth = null;</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            if(curS.isJudgment()) {</span>
<span class="nc" id="L663">                truth = TruthFunctions.deduction(nal.getCurrentTask().sentence.truth, nal.narParameters.reliance, nal.narParameters);</span>
            }
<span class="nc bnc" id="L665" title="All 2 branches missed.">            if(curS.isGoal()) {</span>
<span class="nc" id="L666">                truth = TruthFunctions.desireStrong(nal.getCurrentTask().sentence.truth, new TruthValue(1.0f,nal.narParameters.reliance, nal.narParameters), nal.narParameters);</span>
            }
<span class="nc" id="L668">            final BudgetValue budget = BudgetFunctions.forward(truth, nal);</span>
<span class="nc" id="L669">            nal.singlePremiseTask(cont, truth, budget);</span>
        }
<span class="nc" id="L671">    }</span>
    
    /* --------------- Split sequence apart --------------- */
    /**
     * {(#,A,B,C,D,E), C@(#,A,B,C,D,E)} |- (#,A,B,C), (#,C,D,E)
     *
     * Works for all conjunctions
     *
     * @param compound The premise
     * @param component The recognized component in the premise
     * @param compoundTask Whether the compound comes from the task
     * @param nal Reference to the memory
     */
    static void splitConjunctionApart(final CompoundTerm compound, final Term component, final boolean compoundTask, final int index, final DerivationContext nal) {
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">        if(compound instanceof Conjunction) {</span>
<span class="fc" id="L686">            final Conjunction conjCompound = (Conjunction) compound;</span>
<span class="fc" id="L687">            final Term[] newTermLeft = new Term[index+1];</span>
<span class="fc" id="L688">            final Term[] newTermRight = new Term[conjCompound.size()-index];</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">            if(newTermLeft.length == compound.size() || //since nothing was splitted</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">               newTermRight.length == compound.size()) {</span>
<span class="fc" id="L691">                return;</span>
            }
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">            if(conjCompound.term.length &lt; newTermLeft.length) {</span>
<span class="nc" id="L694">                return;</span>
            }
<span class="fc" id="L696">            System.arraycopy(conjCompound.term, 0, newTermLeft, 0, newTermLeft.length);</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">            if(conjCompound.term.length - index &lt; newTermRight.length) {</span>
<span class="nc" id="L698">                return;</span>
            }
<span class="fc" id="L700">            System.arraycopy(conjCompound.term, 0 + index, newTermRight, 0, newTermRight.length);</span>
<span class="fc" id="L701">            final Sentence curS = nal.getCurrentTask().sentence;</span>
<span class="fc" id="L702">            TruthValue truth = null;</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">            if(curS.isJudgment()) {</span>
<span class="fc" id="L704">                truth = TruthFunctions.deduction(curS.truth, nal.narParameters.reliance, nal.narParameters);</span>
            }
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">            if(curS.isGoal()) {</span>
<span class="nc" id="L707">                truth = TruthFunctions.desireStrong(curS.truth, new TruthValue(1.0f, nal.narParameters.reliance, nal.narParameters), nal.narParameters);</span>
            }
<span class="fc" id="L709">            deriveSequenceTask(nal, conjCompound, newTermLeft, truth);</span>
<span class="fc" id="L710">            deriveSequenceTask(nal, conjCompound, newTermRight, truth);</span>
        }
<span class="fc" id="L712">    }</span>
    
    /**
     * {(#,A,B,C,D,E), C@(#,A,B,C,D,E)} |- (#,(#,A,B),C,D,E), (#,A,B,C,(#,D,E))
     *
     * Group sequence left and right
     *
     * Works for all conjunctions
     *
     * @param compound The premise
     * @param component The recognized component in the premise
     * @param compoundTask Whether the compound comes from the task
     * @param nal Reference to the memory
     *
     * @author Patrick Hammer
     * @author Robert Wünsche
     */
    static void groupSequence(final CompoundTerm compound, final Term component, final boolean compoundTask, final int index, final DerivationContext nal) {
<span class="pc bpc" id="L730" title="2 of 4 branches missed.">        if(!(compound instanceof Conjunction) || index &gt;= compound.size()) {</span>
<span class="nc" id="L731">            return;</span>
        }

<span class="fc" id="L734">        final Conjunction conjCompound = (Conjunction) compound;</span>
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">        if(conjCompound.getTemporalOrder() != TemporalRules.ORDER_FORWARD) {</span>
<span class="nc" id="L736">            return;</span>
        }

<span class="fc bfc" id="L739" title="All 2 branches covered.">        final boolean hasLeft = index &gt;= 1; // result subsequence will have at least two elements</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">        final boolean hasRight = index &lt; (compound.size() - 1);</span>

<span class="fc bfc" id="L742" title="All 2 branches covered.">        if (hasLeft) {</span>
<span class="fc" id="L743">            final int sliceStartIndexInclusive = nal.memory.randomNumber.nextInt(index - 1 + 1 /* inclusive */); //if index-1 it would have length 1, no group</span>
<span class="fc" id="L744">            final int sliceEndIndexInclusive = index;</span>

<span class="fc bfc" id="L746" title="All 4 branches covered.">            final boolean allRange = sliceStartIndexInclusive == 0 &amp;&amp; sliceEndIndexInclusive == (conjCompound.term.length - 1);</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">            if( !allRange ) {</span>
<span class="fc" id="L748">                createSequenceTaskByRange(conjCompound, sliceStartIndexInclusive, sliceEndIndexInclusive, nal);</span>
            }
        }

<span class="fc bfc" id="L752" title="All 2 branches covered.">        if (hasRight) {</span>
<span class="fc" id="L753">            final int sliceStartIndexInclusive = index;</span>
            final int sliceEndIndexInclusive;
            {
<span class="fc" id="L756">                final int randminInclusive = index + 1;</span>
<span class="fc" id="L757">                final int randmaxInclusive = compound.size() - 1;</span>
<span class="fc" id="L758">                sliceEndIndexInclusive = nal.memory.randomNumber.nextInt(randmaxInclusive - randminInclusive + 1 /*inclusive*/) + randminInclusive;</span>
            }

<span class="fc bfc" id="L761" title="All 4 branches covered.">            final boolean allRange = sliceStartIndexInclusive == 0 &amp;&amp; sliceEndIndexInclusive == (conjCompound.term.length - 1);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">            if( !allRange ) {</span>
<span class="fc" id="L763">                createSequenceTaskByRange(conjCompound, sliceStartIndexInclusive, sliceEndIndexInclusive, nal);</span>
            }
        }
<span class="fc" id="L766">    }</span>

    /** Derives a sub-sequence of a sequence based on a (inclusive) index range
     * 
     * @param sourceConjunction The conjunction we take out a certain part from
     * @param inclusiveStartIndex The start index (inclusive)
     * @param inclusiveEndIndex The end index (inclusive)
     * @param nal The derivation context
     *
     * @author Robert Wünsche
     */
    private static void createSequenceTaskByRange(Conjunction sourceConjunction,  int inclusiveStartIndex, int inclusiveEndIndex, DerivationContext nal) {
<span class="fc" id="L778">        int subsequenceLength = inclusiveEndIndex - inclusiveStartIndex + 1; //+1 because of all being inclusive indices</span>
<span class="fc" id="L779">        final Term[] subsequence = new Term[subsequenceLength];</span>
        // copy subsequence from source to subsequence:
<span class="fc bfc" id="L781" title="All 2 branches covered.">        for (int idxInSource=inclusiveStartIndex; idxInSource&lt;=inclusiveEndIndex; idxInSource++) {</span>
<span class="fc" id="L782">            int idxInSubsequence = idxInSource - inclusiveStartIndex;</span>
<span class="fc" id="L783">            subsequence[idxInSubsequence] = sourceConjunction.term[idxInSource];</span>
        }
<span class="fc" id="L785">        final Term[] destination = new Term[sourceConjunction.size() - subsequenceLength + 1]; //+1 because the subsequence requires one element too</span>
        // copy everything before the subsequence:
<span class="fc" id="L787">        int destinationIdx = 0;</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">        for (int idx=0; idx&lt;inclusiveStartIndex; idx++) {</span>
<span class="fc" id="L789">            destination[destinationIdx++] = sourceConjunction.term[idx];</span>
        }
<span class="pc bpc" id="L791" title="2 of 4 branches missed.">        assert destinationIdx == inclusiveStartIndex;</span>
        // followed by the subsequence
<span class="fc" id="L793">        destination[destinationIdx++] = Conjunction.make(subsequence, sourceConjunction.getTemporalOrder(), sourceConjunction.getIsSpatial());</span>
        // followed by everything after the subsequence
<span class="fc bfc" id="L795" title="All 2 branches covered.">        for (int idxInSource=inclusiveEndIndex+1; idxInSource&lt;sourceConjunction.size(); idxInSource++) {</span>
<span class="fc" id="L796">            destination[destinationIdx++] = sourceConjunction.term[idxInSource];</span>
        }
<span class="pc bpc" id="L798" title="2 of 4 branches missed.">        assert destinationIdx == destination.length;</span>
        // derive sourceConjunction, inheriting the type of conjunction from sourceConjunction
<span class="fc" id="L800">        Sentence curS = nal.getCurrentTask().sentence;</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">        final TruthValue truth = curS.truth != null ? curS.truth.clone() : null;</span>
<span class="fc" id="L802">        deriveSequenceTask(nal, sourceConjunction, destination, truth);</span>
<span class="fc" id="L803">    }</span>
    
    /***
     * Derives a sequence task, inheriting properties from parentConj
     * 
     * @param nal The derivation context
     * @param total The sub-terms the conjunction should be created from
     * @param truth The truth value of the derivation
     */
    private static void deriveSequenceTask(DerivationContext nal, Conjunction parentConj, Term[] total, TruthValue truth) {
<span class="fc" id="L813">        final Term cont = Conjunction.make(total, parentConj.getTemporalOrder(), parentConj.getIsSpatial());</span>
<span class="pc bpc" id="L814" title="2 of 4 branches missed.">        if(cont instanceof Conjunction &amp;&amp; total.length != parentConj.size()) {</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">            final BudgetValue budget = truth != null ? BudgetFunctions.compoundForward(truth, cont, nal) : </span>
<span class="fc" id="L816">                                                       BudgetFunctions.compoundBackward(cont, nal);</span>
<span class="fc" id="L817">            nal.singlePremiseTask(cont, truth, budget);</span>
        }
<span class="fc" id="L819">    }</span>

    public static void seqToImage(final Conjunction conj, final int index, final DerivationContext nal) {
<span class="fc" id="L822">        final int side = 0; //extensional</span>
<span class="fc" id="L823">        final short[] indices = new short[] { (short)side, (short)index };</span>
<span class="fc" id="L824">        final Product subject = Product.make(conj.term);</span>
<span class="fc" id="L825">        Term predicate = Term.SEQ_TEMPORAL;</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">        if(conj.isSpatial) {</span>
<span class="fc" id="L827">            predicate = Term.SEQ_SPATIAL;</span>
        }
<span class="fc" id="L829">        final Inheritance inh = Inheritance.make(subject, predicate);</span>
<span class="fc" id="L830">        StructuralRules.transformProductImage(inh, inh, indices, nal);</span>
<span class="fc" id="L831">    }</span>
    
    /* --------------- Disjunction and Conjunction transform --------------- */
    /**
     * {(&amp;amp;&amp;amp;, A, B), A@(&amp;amp;&amp;amp;, A, B)} |- A,
     * &lt;br&gt;
     * or answer (&amp;amp;&amp;amp;, A, B)? using A {(||, A, B), A@(||, A, B)} |- A,
     * &lt;br&gt;
     * or answer (||, A, B)? using A
     *
     * @param compound The premise
     * @param component The recognized component in the premise
     * @param compoundTask Whether the compound comes from the task
     * @param nal Reference to the memory
     */
    static boolean structuralCompound(final CompoundTerm compound, final Term component, final boolean compoundTask, final int index, final DerivationContext nal) {
        
<span class="fc bfc" id="L848" title="All 2 branches covered.">        if(compound instanceof Conjunction) {</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">            if(nal.getCurrentTask().getTerm() == compound) {</span>
<span class="fc" id="L850">                final Conjunction conj = (Conjunction) compound; //only for # for now, will be gradually applied to &amp;/ later</span>
<span class="fc bfc" id="L851" title="All 4 branches covered.">                if(conj.getTemporalOrder() == TemporalRules.ORDER_FORWARD &amp;&amp; conj.isSpatial) { //and some also to &amp;&amp; &amp;|</span>
                    //flattenSequence(compound, component, compoundTask, index, nal);
<span class="fc" id="L853">                    groupSequence(compound, component, compoundTask, index, nal);</span>
                    //takeOutFromConjunction(compound, component, compoundTask, index, nal);
<span class="fc" id="L855">                    splitConjunctionApart(compound, component, compoundTask, index, nal);</span>
                }
<span class="fc bfc" id="L857" title="All 2 branches covered.">                if(conj.getTemporalOrder() == TemporalRules.ORDER_FORWARD) {</span>
<span class="fc" id="L858">                    seqToImage(conj, index, nal);</span>
                }
            }
        }
        
<span class="fc bfc" id="L863" title="All 2 branches covered.">        if (component.hasVarIndep()) { //moved down here since flattening also works when indep</span>
<span class="fc" id="L864">            return false;</span>
        } //and also for &amp;/ with index &gt; 0
<span class="fc bfc" id="L866" title="All 8 branches covered.">        if ((compound instanceof Conjunction) &amp;&amp; !compound.getIsSpatial() &amp;&amp; (compound.getTemporalOrder() == TemporalRules.ORDER_FORWARD) &amp;&amp; (index != 0)) {</span>
<span class="fc" id="L867">            return false;</span>
        } 
        
<span class="fc bfc" id="L870" title="All 2 branches covered.">        final Term content = compoundTask ? component : compound;</span>
<span class="fc" id="L871">        final Task task = nal.getCurrentTask();</span>

<span class="fc" id="L873">        final Sentence sentence = task.sentence;</span>
<span class="fc" id="L874">        TruthValue truth = sentence.truth;</span>

<span class="fc" id="L876">        final float reliance = nal.narParameters.reliance;</span>

        final BudgetValue budget;
<span class="pc bpc" id="L879" title="1 of 4 branches missed.">        if (sentence.isQuestion() || sentence.isQuest()) {</span>
<span class="fc" id="L880">            budget = BudgetFunctions.compoundBackward(content, nal);</span>
        } else {  // need to redefine the cases
            
            //[03:24] &lt;patham9&gt; &lt;a --&gt; b&gt;.     (||,&lt;a --&gt; b&gt;,&lt;x --&gt; y&gt;)?    =&gt;    (||,&lt;a --&gt; b&gt;,&lt;x --&gt; y&gt;).
            //[03:25] &lt;patham9&gt; &lt;a --&gt; b&gt;.     (||,&lt;a --&gt; b&gt;,&lt;x --&gt; y&gt;).     =&gt; dont derive it  &quot;outputMustNotContain(&lt;x --&gt; y&gt;)&quot;
            //[03:25] &lt;patham9&gt; &lt;a --&gt; b&gt;.     (&amp;&amp;,&lt;a --&gt; b&gt;,&lt;x --&gt; y&gt;)?    =&gt;      dont derive it   &quot;outputMustNotContain( (&amp;&amp;,&lt;a --&gt; b&gt;,&lt;x --&gt; y&gt;))&quot;
            //[03:25] &lt;patham9&gt; &lt;a --&gt; b&gt;.     (&amp;&amp;,&lt;a --&gt; b&gt;,&lt;x --&gt; y&gt;).   =&gt;    &lt;x --&gt; y&gt;
<span class="pc bpc" id="L887" title="1 of 12 branches missed.">            if ((sentence.isJudgment() || sentence.isGoal()) &amp;&amp; </span>
                ((!compoundTask &amp;&amp; compound instanceof Disjunction) ||
                (compoundTask &amp;&amp; compound instanceof Conjunction))) {
<span class="fc" id="L890">                truth = TruthFunctions.deduction(truth, reliance, nal.narParameters);</span>
            }else {
                final TruthValue v1;
                final TruthValue v2;
<span class="fc" id="L894">                v1 = TruthFunctions.negation(truth, nal.narParameters);</span>
<span class="fc" id="L895">                v2 = TruthFunctions.deduction(v1, reliance, nal.narParameters);</span>
<span class="fc" id="L896">                truth = TruthFunctions.negation(v2, nal.narParameters);</span>
            }
<span class="fc" id="L898">            budget = BudgetFunctions.forward(truth, nal);</span>
        }
<span class="fc" id="L900">        return nal.singlePremiseTask(content, truth, budget);</span>
    }

    /* --------------- Negation related rules --------------- */
    /**
     * {A, A@(--, A)} |- (--, A)
     *
     * @param content The premise
     * @param nal Reference to the memory
     */
    public static void transformNegation(final CompoundTerm content, final DerivationContext nal) {
<span class="fc" id="L911">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L912">        final Sentence sentence = task.sentence;</span>
<span class="fc" id="L913">        TruthValue truth = sentence.truth;</span>

        final BudgetValue budget;
        
<span class="fc bfc" id="L917" title="All 4 branches covered.">        if (sentence.isJudgment() || sentence.isGoal()) {</span>
<span class="fc" id="L918">            truth = TruthFunctions.negation(truth, nal.narParameters);</span>
<span class="fc" id="L919">            budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
        } else {
<span class="fc" id="L921">            budget = BudgetFunctions.compoundBackward(content, nal);</span>
        }
<span class="fc" id="L923">        nal.singlePremiseTask(content, truth, budget);</span>
<span class="fc" id="L924">    }</span>

    /**
     * {&amp;lt;A ==&amp;gt; B&amp;gt;, A@(--, A)} |- &amp;lt;(--, B) ==&amp;gt; (--, A)&amp;gt;
     *
     * @param statement The premise
     * @param nal Reference to the memory
     */
    protected static boolean contraposition(final Statement statement, final Sentence sentence, final DerivationContext nal) {
<span class="fc" id="L933">        final Memory memory = nal.mem();</span>
        //memory.logic.CONTRAPOSITION.commit(statement.complexity);
        
<span class="fc" id="L936">        final Term subj = statement.getSubject();</span>
<span class="fc" id="L937">        final Term pred = statement.getPredicate();</span>
        
<span class="fc" id="L939">        final Statement content = Statement.make(statement,</span>
<span class="fc" id="L940">                Negation.make(pred), </span>
<span class="fc" id="L941">                Negation.make(subj), </span>
<span class="fc" id="L942">                TemporalRules.reverseOrder(statement.getTemporalOrder()));                </span>
        
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">        if (content == null) return false;</span>
        
<span class="fc" id="L946">        TruthValue truth = sentence.truth;</span>
        final BudgetValue budget;
<span class="pc bpc" id="L948" title="1 of 4 branches missed.">        if (sentence.isQuestion() || sentence.isQuest()) {</span>
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">            if (content instanceof Implication) {</span>
<span class="fc" id="L950">                budget = BudgetFunctions.compoundBackwardWeak(content, nal);</span>
            } else {
<span class="nc" id="L952">                budget = BudgetFunctions.compoundBackward(content, nal);</span>
            }
<span class="fc" id="L954">            return nal.singlePremiseTask(content, Symbols.QUESTION_MARK, truth, budget);</span>
        } else {
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">            if (content instanceof Implication) {</span>
<span class="fc" id="L957">                truth = TruthFunctions.contraposition(truth, nal.narParameters);</span>
            }
<span class="fc" id="L959">            budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
<span class="fc" id="L960">            return nal.singlePremiseTask(content, Symbols.JUDGMENT_MARK, truth, budget);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>