<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BudgetFunctions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.inference</a> &gt; <span class="el_source">BudgetFunctions.java</span></div><h1>BudgetFunctions.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.inference;

import org.opennars.entity.*;
import org.opennars.language.Term;
import org.opennars.storage.Memory;

import static java.lang.Math.*;
import org.opennars.main.Parameters;

/**
 * Budget functions for resources allocation
 *
 * @author Pei Wang
 * @author Patrick Hammer
 */
<span class="nc" id="L39">public final class BudgetFunctions extends UtilityFunctions {</span>

    /* ----------------------- Belief evaluation ----------------------- */
    /**
     * Determine the quality of a judgment by its truth value alone
     * &lt;p&gt;
     * Mainly decided by confidence, though binary judgment is also preferred
     *
     * @param t The truth value of a judgment
     * @return The quality of the judgment, according to truth value only
     */
    public final static float truthToQuality(final TruthValue t) {
<span class="fc" id="L51">        final float exp = t.getExpectation();</span>
<span class="fc" id="L52">        return (float) max(exp, (1 - exp)*0.75);</span>
    }

    /**
     * Determine the rank of a judgment by its quality and originality (stamp
 baseLength), called from Concept
     *
     * @param judg The judgment to be ranked
     * @return The rank of the judgment, according to truth value only
     */
    public final static float rankBelief(final Sentence judg, final boolean rankTruthExpectation) {        
<span class="fc bfc" id="L63" title="All 2 branches covered.">        if(rankTruthExpectation) {</span>
<span class="fc" id="L64">            return judg.getTruth().getExpectation();</span>
        }
<span class="fc" id="L66">        final double confidence = judg.truth.getConfidence();</span>
        //final float originality = judg.stamp.getOriginality();
<span class="fc" id="L68">        return (float)confidence; //or(confidence, originality);</span>
    }


    /**
     * Evaluate the quality of a revision, then de-prioritize the premises
     *
     * @param tTruth The truth value of the judgment in the task
     * @param bTruth The truth value of the belief
     * @param truth The truth value of the conclusion of revision
     * @return The budget for the new task
     */
    static BudgetValue revise(final TruthValue tTruth, final TruthValue bTruth, final TruthValue truth, final boolean feedbackToLinks, final org.opennars.control.DerivationContext nal) {
<span class="fc" id="L81">        final float difT = truth.getExpDifAbs(tTruth);</span>
<span class="fc" id="L82">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L83">        task.decPriority(1 - difT);</span>
<span class="fc" id="L84">        task.decDurability(1 - difT);</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (feedbackToLinks) {</span>
<span class="fc" id="L86">            final TaskLink tLink = nal.getCurrentTaskLink();</span>
<span class="fc" id="L87">            tLink.decPriority(1 - difT);</span>
<span class="fc" id="L88">            tLink.decDurability(1 - difT);</span>
<span class="fc" id="L89">            final TermLink bLink = nal.getCurrentBeliefLink();</span>
<span class="fc" id="L90">            final float difB = truth.getExpDifAbs(bTruth);</span>
<span class="fc" id="L91">            bLink.decPriority(1 - difB);</span>
<span class="fc" id="L92">            bLink.decDurability(1 - difB);</span>
        }
<span class="fc" id="L94">        final double dif = truth.getConfidence() - max(tTruth.getConfidence(), bTruth.getConfidence());</span>
<span class="fc" id="L95">        final float priority = or((float)dif, task.getPriority());</span>
<span class="fc" id="L96">        final float durability = aveAri((float)dif, task.getDurability());</span>
<span class="fc" id="L97">        final float quality = truthToQuality(truth);</span>
        
        /*
        if (priority &lt; 0) {
            memory.nar.output(ERR.class, 
                    new IllegalStateException(&quot;BudgetValue.revise resulted in negative priority; set to 0&quot;));
            priority = 0;
        }
        if (durability &lt; 0) {
            memory.nar.output(ERR.class, 
                    new IllegalStateException(&quot;BudgetValue.revise resulted in negative durability; set to 0; aveAri(dif=&quot; + dif + &quot;, task.getDurability=&quot; + task.getDurability() +&quot;) = &quot; + durability));
            durability = 0;
        }
        if (quality &lt; 0) {
            memory.nar.output(ERR.class, 
                    new IllegalStateException(&quot;BudgetValue.revise resulted in negative quality; set to 0&quot;));
            quality = 0;
        }
        */
        
<span class="fc" id="L117">        return new BudgetValue(priority, durability, quality, nal.narParameters);</span>
    }

    /**
     * Update a belief
     *
     * @param task The task containing new belief
     * @param bTruth Truth value of the previous belief
     * @return Budget value of the updating task
     */
    public static BudgetValue update(final Task task, final TruthValue bTruth, Parameters narParameters) {
<span class="nc" id="L128">        final TruthValue tTruth = task.sentence.truth;</span>
<span class="nc" id="L129">        final float dif = tTruth.getExpDifAbs(bTruth);</span>
<span class="nc" id="L130">        final float priority = or(dif, task.getPriority());</span>
<span class="nc" id="L131">        final float durability = aveAri(dif, task.getDurability());</span>
<span class="nc" id="L132">        final float quality = truthToQuality(bTruth);</span>
<span class="nc" id="L133">        return new BudgetValue(priority, durability, quality, narParameters);</span>
    }

    /* ----------------------- Links ----------------------- */
    /**
     * Distribute the budget of a task among the links to it
     *
     * @param b The original budget
     * @param n Number of links
     * @return Budget value for each link
     */
    public static BudgetValue distributeAmongLinks(final BudgetValue b, final int n, Parameters narParameters) {
<span class="fc" id="L145">        final float priority = (float) (b.getPriority() / sqrt(n));</span>
<span class="fc" id="L146">        return new BudgetValue(priority, b.getDurability(), b.getQuality(), narParameters);</span>
    }

<span class="fc" id="L149">    public enum Activating {</span>
<span class="fc" id="L150">        Max, TaskLink</span>
    }
    
    
    /* ----------------------- Concept ----------------------- */
    /**
     * Activate a concept by an incoming TaskLink
     *
     * @param receiver The budget receiving the activation
     * @param amount The budget for the new item
     */
    public static void activate(final BudgetValue receiver, final BudgetValue amount, final Activating mode) {
<span class="pc bpc" id="L162" title="2 of 3 branches missed.">        switch (mode) {</span>
            case Max:
<span class="nc" id="L164">                BudgetFunctions.merge(receiver, amount);</span>
<span class="nc" id="L165">                break;</span>
            case TaskLink:                
<span class="fc" id="L167">                final float oldPri = receiver.getPriority();</span>
<span class="fc" id="L168">                receiver.setPriority( or(oldPri, amount.getPriority()) );</span>
<span class="fc" id="L169">                receiver.setDurability( aveAri(receiver.getDurability(), amount.getDurability()) );</span>
<span class="fc" id="L170">                receiver.setQuality( receiver.getQuality() );</span>
                break;
        }
        
<span class="fc" id="L174">    }</span>

    /* ---------------- Bag functions, on all Items ------------------- */
    /**
     * Decrease Priority after an item is used, called in Bag.
     * After a constant time, p should become d*p. Since in this period, the
     * item is accessed c*p times, each time p-q should multiple d^(1/(c*p)).
     * The intuitive meaning of the parameter &quot;forgetRate&quot; is: after this number
     * of times of access, priority 1 will become d, it is a system parameter
     * adjustable in run time.
     *
     * @param budget The previous budget value
     * @param forgetCycles The budget for the new item
     * @param relativeThreshold The relative threshold of the bag
     */
    public static void applyForgetting(final BudgetValue budget, final float forgetCycles, final float relativeThreshold) {
<span class="fc" id="L190">        float quality = budget.getQuality() * relativeThreshold;      // re-scaled quality</span>
<span class="fc" id="L191">        final float p = budget.getPriority() - quality;                     // priority above quality</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (p &gt; 0) {</span>
<span class="fc" id="L193">            quality += p * pow(budget.getDurability(), 1.0 / (forgetCycles * p));</span>
        }    // priority Durability
<span class="fc" id="L195">        budget.setPriority(quality);</span>
<span class="fc" id="L196">    }</span>

    
    /**
     * Merge an item into another one in a bag, when the two are identical
     * except in budget values
     *
     * @param b The budget baseValue to be modified
     * @param a The budget adjustValue doing the adjusting
     */
    public static void merge(final BudgetValue b, final BudgetValue a) {        
<span class="fc" id="L207">        b.setPriority(max(b.getPriority(), a.getPriority()));</span>
<span class="fc" id="L208">        b.setDurability(max(b.getDurability(), a.getDurability()));</span>
<span class="fc" id="L209">        b.setQuality(max(b.getQuality(), a.getQuality()));</span>
<span class="fc" id="L210">    }</span>

    /* ----- Task derivation in LocalRules and SyllogisticRules ----- */
    /**
     * Forward inference result and adjustment
     *
     * @param truth The truth value of the conclusion
     * @return The budget value of the conclusion
     */
    public static BudgetValue forward(final TruthValue truth, final org.opennars.control.DerivationContext nal) {
<span class="fc" id="L220">        return budgetInference(truthToQuality(truth), 1, nal);</span>
    }

    /**
     * Backward inference result and adjustment, stronger case
     *
     * @param truth The truth value of the belief deriving the conclusion
     * @param nal Reference to the memory
     * @return The budget value of the conclusion
     */
    public static BudgetValue backward(final TruthValue truth, final org.opennars.control.DerivationContext nal) {
<span class="fc" id="L231">        return budgetInference(truthToQuality(truth), 1, nal);</span>
    }

    /**
     * Backward inference result and adjustment, weaker case
     *
     * @param truth The truth value of the belief deriving the conclusion
     * @param nal Reference to the memory
     * @return The budget value of the conclusion
     */
    public static BudgetValue backwardWeak(final TruthValue truth, final org.opennars.control.DerivationContext nal) {
<span class="fc" id="L242">        return budgetInference((float)w2c(1, nal.narParameters) * truthToQuality(truth), 1, nal);</span>
    }

    /* ----- Task derivation in CompositionalRules and StructuralRules ----- */
    /**
     * Forward inference with CompoundTerm conclusion
     *
     * @param truth The truth value of the conclusion
     * @param content The content of the conclusion
     * @param nal Reference to the memory
     * @return The budget of the conclusion
     */
    public static BudgetValue compoundForward(final TruthValue truth, final Term content, final org.opennars.control.DerivationContext nal) {
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        final float complexity = (content == null) ? nal.narParameters.COMPLEXITY_UNIT : nal.narParameters.COMPLEXITY_UNIT*content.getComplexity();</span>
<span class="fc" id="L256">        return budgetInference(truthToQuality(truth), complexity, nal);</span>
    }

    /**
     * Backward inference with CompoundTerm conclusion, stronger case
     *
     * @param content The content of the conclusion
     * @param nal Reference to the memory
     * @return The budget of the conclusion
     */
    public static BudgetValue compoundBackward(final Term content, final org.opennars.control.DerivationContext nal) {
<span class="fc" id="L267">        return budgetInference(1, content.getComplexity()*nal.narParameters.COMPLEXITY_UNIT, nal);</span>
    }

    /**
     * Backward inference with CompoundTerm conclusion, weaker case
     *
     * @param content The content of the conclusion
     * @param nal Reference to the memory
     * @return The budget of the conclusion
     */
    public static BudgetValue compoundBackwardWeak(final Term content, final org.opennars.control.DerivationContext nal) {
<span class="fc" id="L278">        return budgetInference((float)w2c(1, nal.narParameters), content.getComplexity()*nal.narParameters.COMPLEXITY_UNIT, nal);</span>
    }

    /**
     * Get the current activation level of a concept.
     *
     * @param t The Term naming a concept
     * @return the priority value of the concept
     */
    public static float conceptActivation(final Memory mem, final Term t) {
<span class="fc" id="L288">        final Concept c = mem.concept(t);</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        return (c == null) ? 0f : c.getPriority();</span>
    }
    
    /**
     * Common processing for all inference step
     *
     * @param qual Quality of the inference
     * @param complexity Syntactic complexity of the conclusion
     * @param nal Reference to the memory
     * @return Budget of the conclusion task
     */
    private static BudgetValue budgetInference(final float qual, final float complexity, final org.opennars.control.DerivationContext nal) {
<span class="fc" id="L301">        Item t = nal.getCurrentTaskLink();</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (t == null) {</span>
<span class="fc" id="L303">            t = nal.getCurrentTask();</span>
        }
<span class="fc" id="L305">        float priority = t.getPriority();</span>
<span class="fc" id="L306">        float durability = t.getDurability() / complexity;</span>
<span class="fc" id="L307">        final float quality = qual / complexity;</span>
<span class="fc" id="L308">        final TermLink bLink = nal.getCurrentBeliefLink();</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if (bLink != null) {</span>
<span class="fc" id="L310">            priority = or(priority, bLink.getPriority());</span>
<span class="fc" id="L311">            durability = (float)and(durability, bLink.getDurability());</span>
<span class="fc" id="L312">            final float targetActivation = conceptActivation(nal.memory, bLink.target);</span>
<span class="fc" id="L313">            bLink.incPriority(or(quality, targetActivation));</span>
<span class="fc" id="L314">            bLink.incDurability(quality);</span>
        }
<span class="fc" id="L316">        return new BudgetValue(priority, durability, quality, nal.narParameters);</span>
    }

    @Deprecated static BudgetValue solutionEval(final Sentence problem, final Sentence solution, final Task task, final Memory memory) {
<span class="nc" id="L320">        throw new IllegalStateException(&quot;Moved to TemporalRules.java&quot;);</span>
    }    

    public static BudgetValue budgetTermLinkConcept(final Concept c, final BudgetValue taskBudget, final TermLink termLink) {
<span class="nc" id="L324">        return taskBudget.clone();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>