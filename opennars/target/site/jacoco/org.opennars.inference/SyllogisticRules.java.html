<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SyllogisticRules.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.inference</a> &gt; <span class="el_source">SyllogisticRules.java</span></div><h1>SyllogisticRules.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.inference;

import java.util.LinkedHashMap;
import org.opennars.control.DerivationContext;
import org.opennars.entity.*;
import org.opennars.io.Symbols;
import org.opennars.io.Symbols.NativeOperator;
import org.opennars.language.*;

import java.util.List;
import org.opennars.control.concept.ProcessAnticipation;

import static org.opennars.inference.TemporalRules.*;
import static org.opennars.language.Terms.reduceComponents;

/**
 * Syllogisms: Inference rules based on the transitivity of the relation.
 *
 * @author Pei Wang
 * @author Patrick Hammer
 */
<span class="nc" id="L45">public final class SyllogisticRules {</span>

    /* --------------- rules used in both first-tense inference and higher-tense inference --------------- */
    /**
     * &lt;pre&gt;
     * {&amp;lt;S ==&amp;gt; M&amp;gt;, &amp;lt;M ==&amp;gt; P&amp;gt;} |- {&amp;lt;S ==&amp;gt; P&amp;gt;, &amp;lt;P ==&amp;gt; S&amp;gt;}
     * &lt;/pre&gt;
     *
     * @param term1 Subject of the first new task
     * @param term2 Predicate of the first new task
     * @param sentence The first premise
     * @param belief The second premise
     * @param nal Reference to the memory
     */
    static void dedExe(final Term term1, final Term term2, final Sentence sentence, final Sentence belief, final DerivationContext nal) {
<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (Statement.invalidStatement(term1, term2)) {</span>
<span class="fc" id="L61">            return;</span>
        }
<span class="fc" id="L63">        final int order1 = sentence.term.getTemporalOrder();</span>
<span class="fc" id="L64">        final int order2 = belief.term.getTemporalOrder();</span>
<span class="fc" id="L65">        final int order = dedExeOrder(order1, order2);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">        if (order == ORDER_INVALID) {</span>
<span class="fc" id="L67">            return;</span>
        }
<span class="fc" id="L69">        final TruthValue value1 = sentence.truth;</span>
<span class="fc" id="L70">        final TruthValue value2 = belief.truth;</span>
<span class="fc" id="L71">        TruthValue truth1 = null;</span>
<span class="fc" id="L72">        TruthValue truth2 = null;</span>
        final BudgetValue budget1;
        final BudgetValue budget2;

<span class="pc bpc" id="L76" title="1 of 4 branches missed.">        if (!(sentence.isQuestion() || sentence.isQuest())) {</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">            if (sentence.isGoal()) {</span>
<span class="fc" id="L78">                truth1 = TruthFunctions.desireWeak(value1, value2, nal.narParameters);</span>
<span class="fc" id="L79">                truth2 = TruthFunctions.desireWeak(value1, value2, nal.narParameters);</span>
            } else {
                // isJudgment
<span class="fc" id="L82">                truth1 = TruthFunctions.deduction(value1, value2, nal.narParameters);</span>
<span class="fc" id="L83">                truth2 = TruthFunctions.exemplification(value1, value2, nal.narParameters);</span>
            }
        }

<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (sentence.isQuestion()) {</span>
<span class="fc" id="L88">            budget1 = BudgetFunctions.backwardWeak(value2, nal);</span>
<span class="fc" id="L89">            budget2 = BudgetFunctions.backwardWeak(value2, nal);</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        } else if (sentence.isQuest()) {</span>
<span class="nc" id="L91">            budget1 = BudgetFunctions.backward(value2, nal);</span>
<span class="nc" id="L92">            budget2 = BudgetFunctions.backward(value2, nal);</span>
        } else {
<span class="fc" id="L94">            budget1 = BudgetFunctions.forward(truth1, nal);</span>
<span class="fc" id="L95">            budget2 = BudgetFunctions.forward(truth2, nal);</span>
        }

<span class="fc" id="L98">        final Statement content = (Statement) sentence.term;</span>
<span class="fc" id="L99">        final Statement content1 = Statement.make(content, term1, term2, order);</span>
<span class="fc" id="L100">        final Statement content2 = Statement.make(content, term2, term1, reverseOrder(order));</span>
        
<span class="pc bpc" id="L102" title="1 of 4 branches missed.">        if ((content1 == null) || (content2 == null))</span>
<span class="fc" id="L103">            return;</span>
        
<span class="fc" id="L105">        nal.doublePremiseTask(content1, truth1, budget1,false, false); //(allow overlap) but not needed here, isn't detachment</span>
<span class="fc" id="L106">        nal.doublePremiseTask(content2, truth2, budget2,false, false);</span>
<span class="fc" id="L107">    }</span>

    /**
     * {&amp;lt;M ==&amp;gt; S&amp;gt;, &amp;lt;M ==&amp;gt; P&amp;gt;} |- {&amp;lt;S ==&amp;gt; P&amp;gt;, &amp;lt;P ==&amp;gt; S&amp;gt;, &amp;lt;S &amp;lt;=&amp;gt; P&amp;gt;}
     *
     * @param term1 Subject of the first new task
     * @param term2 Predicate of the first new task
     * @param sentence1 The first premise
     * @param sentence2 The second premise
     * @param figure Locations of the shared term in premises --- can be
     * removed?
     * @param nal Reference to the memory
     */
    static boolean abdIndCom(Term term1, Term term2, final Sentence sentence1, final Sentence sentence2, final int figure, final DerivationContext nal) {
<span class="fc bfc" id="L121" title="All 4 branches covered.">        if (Statement.invalidStatement(term1, term2) || Statement.invalidPair(term1, term2)) {</span>
<span class="fc" id="L122">            return false;</span>
        }
<span class="fc" id="L124">        final int order1 = sentence1.term.getTemporalOrder();</span>
<span class="fc" id="L125">        final int order2 = sentence2.term.getTemporalOrder();</span>
<span class="fc" id="L126">        final int order = abdIndComOrder(order1, order2);</span>
        
<span class="fc" id="L128">        final Statement taskContent = (Statement) sentence1.term;</span>
<span class="fc" id="L129">        TruthValue truth1 = null;</span>
<span class="fc" id="L130">        TruthValue truth2 = null;</span>
<span class="fc" id="L131">        TruthValue truth3 = null;</span>
        final BudgetValue budget1;
        final BudgetValue budget2;
        final BudgetValue budget3;
<span class="fc" id="L135">        final TruthValue value1 = sentence1.truth;</span>
<span class="fc" id="L136">        final TruthValue value2 = sentence2.truth;</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (sentence1.isGoal()) {</span>
<span class="fc" id="L139">            truth1 = TruthFunctions.desireStrong(value1, value2, nal.narParameters); //P --&gt; S</span>
<span class="fc" id="L140">            truth2 = TruthFunctions.desireWeak(value2, value1, nal.narParameters); //S --&gt; P</span>
<span class="fc" id="L141">            truth3 = TruthFunctions.desireStrong(value1, value2, nal.narParameters); //S &lt;-&gt; P</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        } else if( sentence1.isJudgment() ) {</span>
<span class="fc" id="L143">            truth1 = TruthFunctions.abduction(value1, value2, nal.narParameters); //P --&gt; S</span>
<span class="fc" id="L144">            truth2 = TruthFunctions.abduction(value2, value1, nal.narParameters); //S --&gt; P</span>
<span class="fc" id="L145">            truth3 = TruthFunctions.comparison(value1, value2, nal.narParameters); //S &lt;-&gt; P</span>
        }

<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (sentence1.isQuestion()) {</span>
<span class="fc" id="L149">            budget1 = BudgetFunctions.backward(value2, nal);</span>
<span class="fc" id="L150">            budget2 = BudgetFunctions.backwardWeak(value2, nal);</span>
<span class="fc" id="L151">            budget3 = BudgetFunctions.backward(value2, nal);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        } else if (sentence1.isQuest()) {</span>
<span class="nc" id="L153">            budget1 = BudgetFunctions.backwardWeak(value2, nal);</span>
<span class="nc" id="L154">            budget2 = BudgetFunctions.backward(value2, nal);</span>
<span class="nc" id="L155">            budget3 = BudgetFunctions.backwardWeak(value2, nal);            </span>
        } else {
<span class="fc" id="L157">            budget1 = BudgetFunctions.forward(truth1, nal);</span>
<span class="fc" id="L158">            budget2 = BudgetFunctions.forward(truth2, nal);</span>
<span class="fc" id="L159">            budget3 = BudgetFunctions.forward(truth3, nal);</span>
        }
        
<span class="fc bfc" id="L162" title="All 4 branches covered.">        if(term1.imagination != null &amp;&amp; term2.imagination != null) {</span>
<span class="fc" id="L163">            final TruthValue T = term1.imagination.AbductionOrComparisonTo(term2.imagination, true);</span>
<span class="fc" id="L164">            nal.doublePremiseTask(</span>
<span class="fc" id="L165">                Statement.make(NativeOperator.SIMILARITY, term1, term2, TemporalRules.ORDER_NONE), </span>
<span class="fc" id="L166">                    T, BudgetFunctions.forward(T, nal),false, false);   </span>
<span class="fc" id="L167">            final TruthValue T2 = term1.imagination.AbductionOrComparisonTo(term2.imagination, false);</span>
<span class="fc" id="L168">            nal.doublePremiseTask(</span>
<span class="fc" id="L169">                Statement.make(NativeOperator.INHERITANCE, term1, term2, TemporalRules.ORDER_NONE), </span>
<span class="fc" id="L170">                    T2, BudgetFunctions.forward(T2, nal),false, false);   </span>
<span class="fc" id="L171">            final TruthValue T3 = term2.imagination.AbductionOrComparisonTo(term1.imagination, false);</span>
<span class="fc" id="L172">            nal.doublePremiseTask(</span>
<span class="fc" id="L173">                Statement.make(NativeOperator.INHERITANCE, term2, term1, TemporalRules.ORDER_NONE), </span>
<span class="fc" id="L174">                    T3, BudgetFunctions.forward(T3, nal),false, false);</span>

            /**
             * no need for other syllogistic inference, it were sensational terms,
             * but it would not hurt to allow it either.. but why afford tasks that summarize
             * so little evidence in comparison to the amount summarized by the array comparison.
             */

<span class="fc" id="L182">            return true;</span>
        }

<span class="fc" id="L185">        long occurrence_time2 = nal.getCurrentTask().sentence.getOccurenceTime();</span>
<span class="pc bpc" id="L186" title="1 of 6 branches missed.">        while (occurrence_time2!=Stamp.ETERNAL &amp;&amp; (term2 instanceof Conjunction) &amp;&amp; (((CompoundTerm) term2).term[0] instanceof Interval)) {</span>
<span class="nc" id="L187">            final Interval interval = (Interval) ((CompoundTerm) term2).term[0];</span>
<span class="nc" id="L188">            occurrence_time2 += interval.time;</span>
<span class="nc" id="L189">            term2 = ((CompoundTerm)term2).setComponent(0, null, nal.mem());</span>
<span class="nc" id="L190">        }</span>
<span class="fc" id="L191">        long occurrence_time1 = nal.getCurrentTask().sentence.getOccurenceTime();</span>
<span class="pc bpc" id="L192" title="1 of 6 branches missed.">        while (occurrence_time1!=Stamp.ETERNAL &amp;&amp; (term1 instanceof Conjunction) &amp;&amp; (((CompoundTerm) term1).term[0] instanceof Interval)) {</span>
<span class="nc" id="L193">            final Interval interval = (Interval) ((CompoundTerm) term1).term[0];</span>
<span class="nc" id="L194">            occurrence_time1 += interval.time;</span>
<span class="nc" id="L195">            term1 = ((CompoundTerm)term1).setComponent(0, null, nal.mem());</span>
<span class="nc" id="L196">        }</span>
        
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (order != ORDER_INVALID) {</span>
<span class="fc" id="L199">            nal.getTheNewStamp().setOccurrenceTime(occurrence_time1);</span>
<span class="fc" id="L200">            nal.doublePremiseTask(</span>
<span class="fc" id="L201">                    Statement.make(taskContent, term1, term2, order), </span>
                        truth1, budget1,false, false);
<span class="fc" id="L203">            nal.getTheNewStamp().setOccurrenceTime(occurrence_time2);</span>
<span class="fc" id="L204">            nal.doublePremiseTask(</span>
<span class="fc" id="L205">                    Statement.make(taskContent, term2, term1, reverseOrder(order)), </span>
                        truth2, budget2,false, false);
<span class="fc" id="L207">            nal.getTheNewStamp().setOccurrenceTime(occurrence_time1);</span>
<span class="fc" id="L208">            nal.doublePremiseTask(</span>
<span class="fc" id="L209">                    Statement.makeSym(taskContent, term1, term2, order), </span>
                        truth3, budget3,false, false);
        }
<span class="pc bpc" id="L212" title="7 of 8 branches missed.">        if(nal.narParameters.BREAK_NAL_HOL_BOUNDARY &amp;&amp; order1==order2 &amp;&amp; taskContent.isHigherOrderStatement() &amp;&amp; sentence2.term.isHigherOrderStatement()) { //</span>
            /* Bridge to higher order statements:
             * &lt;a ==&gt; c&gt;.
             * &lt;b ==&gt; c&gt;.
             * |-
             * &lt;a &lt;-&gt; b&gt;. %F_cmp%
             * &lt;a --&gt; b&gt;. %F_abd%
             * &lt;b --&gt; a&gt;. %F_abd%
             */
            /* // commented because it may be useful in the future
            if(truth1!=null)
                truth1=truth1.clone();
            if(truth2!=null) 
                truth2=truth2.clone();*/
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if(truth3!=null) </span>
<span class="nc" id="L227">                truth3=truth3.clone();</span>
            /* // commented because it may be useful in the future
            nal.doublePremiseTask(
                Statement.make(NativeOperator.INHERITANCE, term1, term2), 
                    truth1, budget1.clone(),false, false);
            nal.doublePremiseTask(
                Statement.make(NativeOperator.INHERITANCE, term2, term1), 
                    truth2, budget2.clone(),false, false);*/
<span class="nc" id="L235">            nal.doublePremiseTask(</span>
<span class="nc" id="L236">                Statement.make(NativeOperator.SIMILARITY, term1, term2, TemporalRules.ORDER_NONE), </span>
<span class="nc" id="L237">                    truth3, budget3.clone(),false, false);</span>
        }
<span class="fc" id="L239">        return false;</span>
    }
    
    

    /**
     * {&amp;lt;S ==&amp;gt; P&amp;gt;, &amp;lt;M &amp;lt;=&amp;gt; P&amp;gt;} |- &amp;lt;S ==&amp;gt; P&amp;gt;
     *
     * @param subj Subject of the new task
     * @param pred Predicate of the new task
     * @param asym The asymmetric premise
     * @param sym The symmetric premise
     * @param figure Locations of the shared term in premises
     * @param nal Reference to the memory
     */
    static void analogy(final Term subj, final Term pred, final Sentence asym, final Sentence sym, final int figure, final DerivationContext nal) {
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (Statement.invalidStatement(subj, pred)) {</span>
<span class="fc" id="L256">            return;</span>
        }
<span class="fc" id="L258">        final int order1 = asym.term.getTemporalOrder();</span>
<span class="fc" id="L259">        final int order2 = sym.term.getTemporalOrder();</span>
<span class="fc" id="L260">        final int order = analogyOrder(order1, order2, figure);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (order == ORDER_INVALID) {</span>
<span class="fc" id="L262">            return;</span>
        }
<span class="fc" id="L264">        final Statement st = (Statement) asym.term;</span>
<span class="fc" id="L265">        TruthValue truth = null;</span>
        final BudgetValue budget;
<span class="fc" id="L267">        final Sentence sentence = nal.getCurrentTask().sentence;</span>
<span class="fc" id="L268">        final CompoundTerm taskTerm = (CompoundTerm) sentence.term;</span>
<span class="pc bpc" id="L269" title="1 of 4 branches missed.">        if (sentence.isQuestion() || sentence.isQuest()) {</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (taskTerm.isCommutative()) {</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">                if(asym.truth==null) { //a question for example</span>
<span class="nc" id="L272">                    return;</span>
                }
<span class="fc" id="L274">                budget = BudgetFunctions.backwardWeak(asym.truth, nal);</span>
            } else {
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">                if(sym.truth==null) { //a question for example</span>
<span class="nc" id="L277">                    return;</span>
                }
<span class="fc" id="L279">                budget = BudgetFunctions.backward(sym.truth, nal);</span>
            }
        } else {
<span class="fc bfc" id="L282" title="All 2 branches covered.">            if (sentence.isGoal()) {</span>
<span class="fc" id="L283">                truth = TruthFunctions.lookupTruthFunctionByBoolAndCompute(taskTerm.isCommutative(), TruthFunctions.EnumType.DESIREWEAK, TruthFunctions.EnumType.DESIRESTRONG, asym.truth, sym.truth, nal.narParameters);</span>
            } else {
<span class="fc" id="L285">                truth = TruthFunctions.analogy(asym.truth, sym.truth, nal.narParameters);</span>
            }
            
<span class="fc" id="L288">            budget = BudgetFunctions.forward(truth, nal);</span>
        }
        
        //nal.mem().logic.ANALOGY.commit();
<span class="fc" id="L292">        nal.doublePremiseTask( Statement.make(st, subj, pred, order), truth, budget,false, false); //(allow overlap) but not needed here, isn't detachment</span>
<span class="fc" id="L293">    }</span>

    /**
     * {&amp;lt;S &amp;lt;=&amp;gt; M&amp;gt;, &amp;lt;&amp;lt; &amp;lt;=&amp;gt; P&amp;gt;} |- &amp;lt;S &amp;lt;=&amp;gt; P&amp;gt;
     *
     * @param term1 Subject of the new task
     * @param term2 Predicate of the new task
     * @param belief The first premise
     * @param sentence The second premise
     * @param figure Locations of the shared term in premises
     * @param nal Reference to the memory
     */
    static void resemblance(final Term term1, final Term term2, final Sentence belief, final Sentence sentence, final int figure, final DerivationContext nal) {
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (Statement.invalidStatement(term1, term2)) {</span>
<span class="fc" id="L307">            return;</span>
        }
<span class="fc" id="L309">        final int order1 = belief.term.getTemporalOrder();</span>
<span class="fc" id="L310">        final int order2 = sentence.term.getTemporalOrder();</span>
<span class="fc" id="L311">        int order = resemblanceOrder(order1, order2, figure);</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (order == ORDER_INVALID) {</span>
<span class="nc" id="L313">            return;</span>
        }
<span class="fc" id="L315">        final Statement st = (Statement) belief.term;</span>
<span class="fc" id="L316">        TruthValue truth = null;</span>
        final BudgetValue budget;
<span class="pc bpc" id="L318" title="1 of 4 branches missed.">        if (!(sentence.isQuestion() || sentence.isQuest())) {</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            if (sentence.isGoal()) {</span>
<span class="fc" id="L320">                truth = TruthFunctions.desireStrong(sentence.truth, belief.truth, nal.narParameters);</span>
            } else {
                // NOTE&lt; this must be Judgement again ? &gt;
<span class="fc" id="L323">                truth = TruthFunctions.resemblance(belief.truth, sentence.truth, nal.narParameters);</span>
            }
        }

<span class="pc bpc" id="L327" title="1 of 4 branches missed.">        if (sentence.isQuestion() || sentence.isQuest()) {</span>
<span class="fc" id="L328">            budget = BudgetFunctions.backward(belief.truth, nal);</span>
        } else {
<span class="fc" id="L330">            budget = BudgetFunctions.forward(truth, nal);</span>
        }

<span class="fc bfc" id="L333" title="All 4 branches covered.">        final boolean higherOrder=(belief.term.isHigherOrderStatement() || sentence.term.isHigherOrderStatement());</span>
<span class="fc bfc" id="L334" title="All 4 branches covered.">        final boolean bothHigherOrder=(belief.term.isHigherOrderStatement() &amp;&amp; sentence.term.isHigherOrderStatement());</span>
<span class="fc bfc" id="L335" title="All 4 branches covered.">        if(!bothHigherOrder &amp;&amp; higherOrder) {</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">            if(belief.term.isHigherOrderStatement()) {</span>
<span class="fc" id="L337">                order=belief.term.getTemporalOrder();</span>
            } 
            else
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">            if(sentence.term.isHigherOrderStatement()) {</span>
<span class="fc" id="L341">                order=sentence.term.getTemporalOrder();</span>
            }
        }
<span class="fc bfc" id="L344" title="All 2 branches covered.">        final Statement s=Statement.make(higherOrder ? NativeOperator.EQUIVALENCE : NativeOperator.SIMILARITY, term1, term2, order);</span>
<span class="fc" id="L345">        nal.doublePremiseTask( s, truth, budget,false, false); //(allow overlap) but not needed here, isn't detachment</span>
        
<span class="pc bpc" id="L347" title="11 of 12 branches missed.">        if(nal.narParameters.BREAK_NAL_HOL_BOUNDARY &amp;&amp; !sentence.term.hasVarIndep() &amp;&amp; (st instanceof Equivalence) &amp;&amp; order1==order2 &amp;&amp; belief.term.isHigherOrderStatement() &amp;&amp; sentence.term.isHigherOrderStatement()) {</span>
           
<span class="nc" id="L349">            final BudgetValue budget1=null;</span>
<span class="nc" id="L350">            final BudgetValue budget2=null;</span>
<span class="nc" id="L351">            BudgetValue budget3=null;</span>
<span class="nc" id="L352">            final TruthValue truth1=null;</span>
<span class="nc" id="L353">            final TruthValue truth2=null;</span>
<span class="nc" id="L354">            TruthValue truth3=null;</span>
<span class="nc" id="L355">            final TruthValue value1 = sentence.truth;</span>
<span class="nc" id="L356">            final TruthValue value2 = belief.truth;</span>
            
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (sentence.isQuestion()) {</span>
               /* // commented because it may be useful in the future
                budget1 = BudgetFunctions.backward(value2, nal);
                budget2 = BudgetFunctions.backwardWeak(value2, nal);*/
<span class="nc" id="L362">                budget3 = BudgetFunctions.backward(value2, nal);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            } else if (sentence.isQuest()) {</span>
               /* // commented because it may be useful in the future
                budget1 = BudgetFunctions.backwardWeak(value2, nal);
                budget2 = BudgetFunctions.backward(value2, nal);*/
<span class="nc" id="L367">                budget3 = BudgetFunctions.backwardWeak(value2, nal);            </span>
            } else {
<span class="nc bnc" id="L369" title="All 2 branches missed.">                if (sentence.isGoal()) {</span>
                    /* // commented because it may be useful in the future
                    truth1 = TruthFunctions.desireStrong(value1, value2);
                    truth2 = TruthFunctions.desireWeak(value2, value1);*/
<span class="nc" id="L373">                    truth3 = TruthFunctions.desireStrong(value1, value2, nal.narParameters);</span>
                } else { 
                    // isJudgment
                    /* // commented because it may be useful in the future
                    truth1 = TruthFunctions.abduction(value1, value2);
                    truth2 = TruthFunctions.abduction(value2, value1);*/
<span class="nc" id="L379">                    truth3 = TruthFunctions.comparison(value1, value2, nal.narParameters);</span>
                }

                /* // commented because it may be useful in the future
                budget1 = BudgetFunctions.forward(truth1, nal);
                budget2 = BudgetFunctions.forward(truth2, nal);*/
<span class="nc" id="L385">                budget3 = BudgetFunctions.forward(truth3, nal);</span>
            }
           
            /* Bridge to higher order statements:
             * &lt;b &lt;=&gt; k&gt;.
             * &lt;b &lt;=&gt; c&gt;.
             * |-
             * &lt;k &lt;-&gt; c&gt;. %F_cmp%
             */
            /* // commented because it may be useful in the future
            nal.doublePremiseTask(
                Statement.make(NativeOperator.INHERITANCE, term1, term2),
                    truth1, budget1.clone(),false, false);
            nal.doublePremiseTask(
                Statement.make(NativeOperator.INHERITANCE, term2, term1),
                    truth2, budget2.clone(),false, false);*/
<span class="nc" id="L401">            nal.doublePremiseTask(</span>
<span class="nc" id="L402">                Statement.make(NativeOperator.SIMILARITY, term1, term2, TemporalRules.ORDER_NONE),</span>
<span class="nc" id="L403">                truth3, budget3.clone(),false, false);</span>
        }
<span class="fc" id="L405">    }</span>

    /* --------------- rules used only in conditional inference --------------- */
    /**
     * {&amp;lt;&amp;lt;M --&amp;gt; S&amp;gt; ==&amp;gt; &amp;lt;M --&amp;gt; P&amp;gt;&amp;gt;, &amp;lt;M --&amp;gt; S&amp;gt;} |- &amp;lt;M --&amp;gt; P&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;&amp;lt;M --&amp;gt; S&amp;gt; ==&amp;gt; &amp;lt;M --&amp;gt; P&amp;gt;&amp;gt;, &amp;lt;M --&amp;gt; P&amp;gt;} |- &amp;lt;M --&amp;gt; S&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;&amp;lt;M --&amp;gt; S&amp;gt; &amp;lt;=&amp;gt; &amp;lt;M --&amp;gt; P&amp;gt;&amp;gt;, &amp;lt;M --&amp;gt; S&amp;gt;} |- &amp;lt;M --&amp;gt; P&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;&amp;lt;M --&amp;gt; S&amp;gt; &amp;lt;=&amp;gt; &amp;lt;M --&amp;gt; P&amp;gt;&amp;gt;, &amp;lt;M --&amp;gt; P&amp;gt;} |- &amp;lt;M --&amp;gt; S&amp;gt;
     *
     * @param mainSentence The implication/equivalence premise
     * @param subSentence The premise on part of s1
     * @param side The location of s2 in s1
     * @param nal Reference to the memory
     */
    static void detachment(final Sentence mainSentence, final Sentence subSentence, final int side, final DerivationContext nal) {
<span class="fc" id="L423">        detachment(mainSentence, subSentence, side, true, nal);</span>
<span class="fc" id="L424">    }</span>
    static void detachment(final Sentence mainSentence, final Sentence subSentence, final int side, final boolean checkTermAgain, final DerivationContext nal) {
<span class="fc" id="L426">        final Statement statement = (Statement) mainSentence.term;</span>
<span class="fc bfc" id="L427" title="All 4 branches covered.">        if (!(statement instanceof Implication) &amp;&amp; !(statement instanceof Equivalence)) {</span>
<span class="fc" id="L428">            return;</span>
        }
<span class="fc" id="L430">        final Term subject = statement.getSubject();</span>
<span class="fc" id="L431">        final Term predicate = statement.getPredicate();</span>
        final Term content;
<span class="fc" id="L433">        final Term term = subSentence.term;</span>
<span class="fc bfc" id="L434" title="All 6 branches covered.">        if ((side == 0) &amp;&amp; (!checkTermAgain || term.equals(subject))) {</span>
<span class="fc" id="L435">            content = predicate;</span>
<span class="fc bfc" id="L436" title="All 6 branches covered.">        } else if ((side == 1) &amp;&amp; (!checkTermAgain || term.equals(predicate))) {</span>
<span class="fc" id="L437">            content = subject;</span>
        } else {
<span class="fc" id="L439">            return;</span>
        }
<span class="pc bpc" id="L441" title="1 of 4 branches missed.">        if ((content instanceof Statement) &amp;&amp; ((Statement) content).invalid()) {</span>
<span class="nc" id="L442">            return;</span>
        }
        
<span class="fc" id="L445">        final Sentence taskSentence = nal.getCurrentTask().sentence;</span>
<span class="fc" id="L446">        final Sentence beliefSentence = nal.getCurrentBelief();</span>
        
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if (beliefSentence == null)</span>
<span class="nc" id="L449">            return;</span>
        
<span class="fc" id="L451">        final int order = statement.getTemporalOrder();</span>
<span class="fc" id="L452">        long occurrence_time = nal.getCurrentTask().sentence.getOccurenceTime();</span>
<span class="pc bpc" id="L453" title="1 of 4 branches missed.">        if ((order != ORDER_NONE) &amp;&amp; (order!=ORDER_INVALID)) {</span>
<span class="fc" id="L454">            final long baseTime = subSentence.getOccurenceTime();</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">            if (baseTime != Stamp.ETERNAL) {</span>
<span class="fc" id="L456">                final long inc = order * nal.narParameters.DURATION;</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">                occurrence_time = (side == 0) ? baseTime+inc : baseTime-inc;</span>
            }
        }

<span class="fc" id="L461">        final TruthValue beliefTruth = beliefSentence.truth;</span>
<span class="fc" id="L462">        final TruthValue truth1 = mainSentence.truth;</span>
<span class="fc" id="L463">        final TruthValue truth2 = subSentence.truth;</span>
<span class="fc" id="L464">        TruthValue truth = null;</span>
<span class="fc" id="L465">        boolean strong = false;</span>
        final BudgetValue budget;

<span class="pc bpc" id="L468" title="1 of 4 branches missed.">        if (!(taskSentence.isQuestion() || taskSentence.isQuest())) {</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">            if (taskSentence.isGoal()) {</span>
<span class="fc bfc" id="L470" title="All 4 branches covered.">                strong = statement instanceof Equivalence || side != 0;</span>
            } else { // isJudgment
<span class="fc bfc" id="L472" title="All 4 branches covered.">                strong = statement instanceof Equivalence || side == 0;</span>
            }
        }

<span class="pc bpc" id="L476" title="1 of 4 branches missed.">        if (!(taskSentence.isQuestion() || taskSentence.isQuest())) {</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">            if (taskSentence.isGoal()) {</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">                if (statement instanceof Equivalence) {</span>
<span class="fc" id="L479">                    truth = TruthFunctions.desireStrong(truth1, truth2, nal.narParameters);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                } else if (side == 0) {</span>
<span class="fc" id="L481">                    truth = TruthFunctions.desireInd(truth1, truth2, nal.narParameters);</span>
                } else {
<span class="fc" id="L483">                    truth = TruthFunctions.desireDed(truth1, truth2, nal.narParameters);</span>
                }
            } else { // isJudgment
<span class="fc bfc" id="L486" title="All 2 branches covered.">                if (statement instanceof Equivalence) {</span>
<span class="fc" id="L487">                    truth = TruthFunctions.analogy(truth2, truth1, nal.narParameters);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">                } else if (side == 0) {</span>
<span class="fc" id="L489">                    truth = TruthFunctions.deduction(truth1, truth2, nal.narParameters);</span>
                } else {
<span class="fc" id="L491">                    truth = TruthFunctions.abduction(truth2, truth1, nal.narParameters);</span>
                }
            }
        }

<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (taskSentence.isQuestion()) {</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if (statement instanceof Equivalence) {</span>
<span class="fc" id="L498">                budget = BudgetFunctions.backward(beliefTruth, nal);</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">            } else if (side == 0) {</span>
<span class="fc" id="L500">                budget = BudgetFunctions.backwardWeak(beliefTruth, nal);</span>
            } else {
<span class="fc" id="L502">                budget = BudgetFunctions.backward(beliefTruth, nal);</span>
            }
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">        } else if (taskSentence.isQuest()) {</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">            if (statement instanceof Equivalence) {</span>
<span class="nc" id="L506">                budget = BudgetFunctions.backwardWeak(beliefTruth, nal);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">            } else if (side == 0) {</span>
<span class="nc" id="L508">                budget = BudgetFunctions.backward(beliefTruth, nal);</span>
            } else {
<span class="nc" id="L510">               budget = BudgetFunctions.backwardWeak(beliefTruth, nal);</span>
            }
        } else {
<span class="fc" id="L513">            budget = BudgetFunctions.forward(truth, nal);</span>
        }
<span class="fc bfc" id="L515" title="All 2 branches covered.">        if(!Variables.indepVarUsedInvalid(content)) {</span>
<span class="fc bfc" id="L516" title="All 4 branches covered.">            final boolean allowOverlap = taskSentence.isJudgment() &amp;&amp; strong;</span>
<span class="fc" id="L517">            nal.getTheNewStamp().setOccurrenceTime(occurrence_time);</span>
<span class="fc" id="L518">            nal.doublePremiseTask(content, truth, budget, false, allowOverlap); //(strong) when strong on judgement</span>
        }
<span class="fc" id="L520">    }</span>

    /**
     * {&amp;lt;(&amp;amp;&amp;amp;, S1, S2, S3) ==&amp;gt; P&amp;gt;, S1} |- &amp;lt;(&amp;amp;&amp;amp;, S2, S3) ==&amp;gt; P&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;(&amp;amp;&amp;amp;, S2, S3) ==&amp;gt; P&amp;gt;, &amp;lt;S1 ==&amp;gt; S2&amp;gt;} |- &amp;lt;(&amp;amp;&amp;amp;, S1, S3) ==&amp;gt; P&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;(&amp;amp;&amp;amp;, S1, S3) ==&amp;gt; P&amp;gt;, &amp;lt;S1 ==&amp;gt; S2&amp;gt;} |- &amp;lt;(&amp;amp;&amp;amp;, S2, S3) ==&amp;gt; P&amp;gt;
     *
     * @param premise1 The conditional premise
     * @param index The location of the shared term in the condition of premise1
     * @param premise2 The premise which, or part of which, appears in the
     * condition of premise1
     * @param side The location of the shared term in premise2: 0 for subject, 1
     * for predicate, -1 for the whole term
     * @param nal Reference to the memory
     */
    static void conditionalDedInd(final Sentence premise1Sentence, Implication premise1, short index, Term premise2, final int side, final DerivationContext nal) {
<span class="fc" id="L538">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L539">        final Sentence taskSentence = task.sentence;</span>
<span class="fc" id="L540">        final Sentence belief = nal.getCurrentBelief();</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">        final boolean deduction = (side != 0);</span>
<span class="fc" id="L542">        final boolean conditionalTask = Variables.hasSubstitute(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT, premise2, belief.term);</span>
        final Term commonComponent;
<span class="fc" id="L544">        Term newComponent = null;</span>
<span class="fc bfc" id="L545" title="All 4 branches covered.">        if (side == 0 || side == 1) {</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">            Statement.EnumStatementSide sideOfCommonComponentAsEnum = side == 0 ? Statement.EnumStatementSide.SUBJECT : Statement.EnumStatementSide.PREDICATE;</span>
<span class="fc" id="L547">            commonComponent = ((Statement)premise2).retBySide(sideOfCommonComponentAsEnum);</span>
<span class="fc" id="L548">            newComponent = ((Statement)premise2).retBySide(Statement.retOppositeSide(sideOfCommonComponentAsEnum));</span>
<span class="fc" id="L549">        }else {</span>
<span class="fc" id="L550">            commonComponent = premise2;</span>
        }
        
<span class="fc" id="L553">        final Term subj = premise1.getSubject();</span>

<span class="fc bfc" id="L555" title="All 2 branches covered.">        if (!(subj instanceof Conjunction)) {</span>
<span class="fc" id="L556">            return;</span>
        }
<span class="fc" id="L558">        final Conjunction oldCondition = (Conjunction) subj;</span>
        
<span class="fc" id="L560">        final int index2 = Terms.indexOf(oldCondition.term,commonComponent);</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (index2 &gt;= 0) {</span>
<span class="fc" id="L562">            index = (short) index2;</span>
        } else {
<span class="fc" id="L564">            Term[] u = new Term[] { premise1, premise2 };            </span>
<span class="fc" id="L565">            boolean match = Variables.unify(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT, oldCondition.term[index], commonComponent, u);</span>
<span class="fc" id="L566">            premise1 = (Implication) u[0]; premise2 = u[1];</span>
            
<span class="fc bfc" id="L568" title="All 4 branches covered.">            if (!match &amp;&amp; (commonComponent.getClass() == oldCondition.getClass())) {</span>

<span class="fc" id="L570">                final CompoundTerm compoundCommonComponent = ((CompoundTerm) commonComponent);</span>
                
<span class="pc bpc" id="L572" title="1 of 4 branches missed.">                if ((oldCondition.term.length &gt; index) &amp;&amp; (compoundCommonComponent.term.length &gt; index)) { // assumption: { was missing</span>
<span class="fc" id="L573">                    u = new Term[] { premise1, premise2 };</span>
<span class="fc" id="L574">                    match = Variables.unify(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT, </span>
                            oldCondition.term[index], 
                            compoundCommonComponent.term[index], 
                            u);
<span class="fc" id="L578">                    premise1 = (Implication) u[0]; premise2 = u[1];</span>
                }
                
            }
<span class="fc bfc" id="L582" title="All 2 branches covered.">            if (!match) {</span>
<span class="fc" id="L583">                return;</span>
            }
        }
<span class="fc" id="L586">        final int conjunctionOrder = subj.getTemporalOrder();</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">        if (conjunctionOrder == ORDER_FORWARD) {</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">            if (index &gt; 0) {</span>
<span class="fc" id="L589">                return;</span>
            }
<span class="fc bfc" id="L591" title="All 4 branches covered.">            if ((side == 0) &amp;&amp; (premise2.getTemporalOrder() == ORDER_FORWARD)) {</span>
<span class="fc" id="L592">                return;</span>
            }
<span class="fc bfc" id="L594" title="All 4 branches covered.">            if ((side == 1) &amp;&amp; (premise2.getTemporalOrder() == ORDER_BACKWARD)) {</span>
<span class="fc" id="L595">                return;</span>
            }
        }
        Term newCondition;
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">        if (oldCondition.equals(commonComponent)) {</span>
<span class="nc" id="L600">            newCondition = null;</span>
        } else {
<span class="fc" id="L602">            newCondition = oldCondition.setComponent(index, newComponent, nal.mem());</span>
        }
        final Term content;
        
<span class="fc" id="L606">        long delta = 0;</span>
<span class="fc" id="L607">        long mintime = 0;</span>
<span class="fc" id="L608">        long maxtime = 0;</span>
<span class="fc" id="L609">        boolean predictedEvent = false;</span>
        
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">        if (newCondition != null) {</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">             if (newCondition instanceof Interval) {</span>
<span class="fc" id="L613">                content = premise1.getPredicate();</span>
<span class="fc" id="L614">                delta = ((Interval) newCondition).time;</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">                if(taskSentence.getOccurenceTime() != Stamp.ETERNAL) {</span>
<span class="fc" id="L616">                   float timeOffset = ((Interval) newCondition).time;</span>
<span class="fc" id="L617">                   float timeWindowHalf = timeOffset * nal.narParameters.ANTICIPATION_TOLERANCE;</span>
<span class="fc" id="L618">                   mintime = (long) Math.max(taskSentence.getOccurenceTime(), (taskSentence.getOccurenceTime() + timeOffset - timeWindowHalf));</span>
<span class="fc" id="L619">                   maxtime = (long) (taskSentence.getOccurenceTime() + timeOffset + timeWindowHalf);</span>
<span class="pc bpc" id="L620" title="1 of 4 branches missed.">                   predictedEvent = nal.narParameters.RETROSPECTIVE_ANTICIPATIONS || (taskSentence.getOccurenceTime() &gt;= nal.time.time());</span>
<span class="fc" id="L621">                }</span>
             } else {
<span class="fc bfc" id="L623" title="All 4 branches covered.">                while ((newCondition instanceof Conjunction) &amp;&amp; (((CompoundTerm) newCondition).term[0] instanceof Interval)) {</span>
<span class="fc" id="L624">                    final Interval interval = (Interval) ((CompoundTerm) newCondition).term[0];</span>
<span class="fc" id="L625">                    delta += interval.time;</span>
<span class="fc" id="L626">                    newCondition = ((CompoundTerm)newCondition).setComponent(0, null, nal.mem());</span>
<span class="fc" id="L627">                }</span>
<span class="fc" id="L628">                content = Statement.make(premise1, newCondition, premise1.getPredicate(), premise1.getTemporalOrder());</span>
             }
               
        } else {
<span class="nc" id="L632">            content = premise1.getPredicate();</span>
        }
        
<span class="fc bfc" id="L635" title="All 2 branches covered.">        if (content == null)</span>
<span class="fc" id="L636">            return;        </span>
        
<span class="fc" id="L638">        long occurrence_time = nal.getCurrentTask().sentence.getOccurenceTime();</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">        if (delta != 0) {</span>
<span class="fc" id="L640">            long baseTime = taskSentence.getOccurenceTime();</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">            if (baseTime != Stamp.ETERNAL) {</span>
<span class="fc" id="L642">                baseTime += delta;</span>
<span class="fc" id="L643">                occurrence_time = baseTime;</span>
            }
        }
        
<span class="fc" id="L647">        final TruthValue truth1 = taskSentence.truth;</span>
<span class="fc" id="L648">        final TruthValue truth2 = belief.truth;</span>
<span class="fc" id="L649">        TruthValue truth = null;</span>
        final BudgetValue budget;

<span class="pc bpc" id="L652" title="1 of 4 branches missed.">        if (!(taskSentence.isQuestion() || taskSentence.isQuest())) {</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">            if (taskSentence.isGoal()) {</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">                if (conditionalTask) {</span>
<span class="nc" id="L655">                    truth = TruthFunctions.desireWeak(truth1, truth2, nal.narParameters);</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">                } else if (deduction) {</span>
<span class="fc" id="L657">                    truth = TruthFunctions.desireInd(truth1, truth2, nal.narParameters);</span>
                } else {
<span class="nc" id="L659">                    truth = TruthFunctions.desireDed(truth1, truth2, nal.narParameters);</span>
                }
            } else {
<span class="fc bfc" id="L662" title="All 2 branches covered.">                if (deduction) {</span>
<span class="fc" id="L663">                    truth = TruthFunctions.deduction(truth1, truth2, nal.narParameters);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">                } else if (conditionalTask) {</span>
<span class="fc" id="L665">                    truth = TruthFunctions.induction(truth2, truth1, nal.narParameters);</span>
                } else {
<span class="fc" id="L667">                    truth = TruthFunctions.induction(truth1, truth2, nal.narParameters);</span>
                }
            }
        }

<span class="pc bpc" id="L672" title="1 of 4 branches missed.">        if (taskSentence.isQuestion() || taskSentence.isQuest()) {</span>
<span class="fc" id="L673">            budget = BudgetFunctions.backwardWeak(truth2, nal);</span>
        } else {
<span class="fc" id="L675">            budget = BudgetFunctions.forward(truth, nal);</span>
        }
        
<span class="fc" id="L678">        nal.getTheNewStamp().setOccurrenceTime(occurrence_time);</span>
<span class="fc bfc" id="L679" title="All 4 branches covered.">        final List&lt;Task&gt; ret = nal.doublePremiseTask(content, truth, budget,false, taskSentence.isJudgment() &amp;&amp; deduction); //(allow overlap) when deduction on judgment</span>
<span class="pc bpc" id="L680" title="2 of 12 branches missed.">        if(!nal.evidentalOverlap &amp;&amp; ret != null &amp;&amp; ret.size() &gt; 0 &amp;&amp; predictedEvent &amp;&amp; taskSentence.isJudgment() &amp;&amp; truth != null &amp;&amp; </span>
<span class="pc bpc" id="L681" title="1 of 4 branches missed.">            truth.getExpectation() &gt; nal.narParameters.DEFAULT_CONFIRMATION_EXPECTATION &amp;&amp; !premise1Sentence.stamp.alreadyAnticipatedNegConfirmation) {</span>
<span class="fc" id="L682">            premise1Sentence.stamp.alreadyAnticipatedNegConfirmation = true;</span>
<span class="fc" id="L683">            ProcessAnticipation.anticipate(nal, premise1Sentence, budget, mintime, maxtime, 1, new LinkedHashMap&lt;Term,Term&gt;());</span>
        }
<span class="fc" id="L685">    }</span>

    /**
     * {&amp;lt;(&amp;amp;&amp;amp;, S1, S2, S3) &amp;lt;=&amp;gt; P&amp;gt;, S1} |- &amp;lt;(&amp;amp;&amp;amp;, S2, S3) &amp;lt;=&amp;gt; P&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;(&amp;amp;&amp;amp;, S2, S3) &amp;lt;=&amp;gt; P&amp;gt;, &amp;lt;S1 ==&amp;gt; S2&amp;gt;} |- &amp;lt;(&amp;amp;&amp;amp;, S1, S3) &amp;lt;=&amp;gt; P&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;(&amp;amp;&amp;amp;, S1, S3) &amp;lt;=&amp;gt; P&amp;gt;, &amp;lt;S1 ==&amp;gt;
     *
     * @param premise1 The equivalence premise
     * @param index The location of the shared term in the condition of premise1
     * @param premise2 The premise which, or part of which, appears in the condition of premise1
     * @param side The location of the shared term in premise2: 0 for subject, 1 for predicate, -1 for the whole term
     * @param nal Reference to the memory
     */
    static void conditionalAna(Equivalence premise1, final short index, Term premise2, final int side, final DerivationContext nal) {
<span class="fc" id="L701">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L702">        final Sentence taskSentence = task.sentence;</span>
<span class="fc" id="L703">        final Sentence belief = nal.getCurrentBelief();</span>
<span class="fc" id="L704">        final boolean conditionalTask = Variables.hasSubstitute(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT, premise2, belief.term);</span>
        final Term commonComponent;
<span class="fc" id="L706">        Term newComponent = null;</span>
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (side == 0) {</span>
<span class="nc" id="L708">            commonComponent = ((Statement) premise2).getSubject();</span>
<span class="nc" id="L709">            newComponent = ((Statement) premise2).getPredicate();</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">        } else if (side == 1) {</span>
<span class="nc" id="L711">            commonComponent = ((Statement) premise2).getPredicate();</span>
<span class="nc" id="L712">            newComponent = ((Statement) premise2).getSubject();</span>
        } else {
<span class="fc" id="L714">            commonComponent = premise2;</span>
        }

<span class="fc" id="L717">        final Term tm = premise1.getSubject();</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">        if (!(tm instanceof Conjunction)) {</span>
<span class="fc" id="L719">            return;</span>
        }
<span class="fc" id="L721">        final Conjunction oldCondition = (Conjunction) tm;</span>

<span class="fc" id="L723">        Term[] u = new Term[] { premise1, premise2 };</span>
<span class="fc" id="L724">        boolean match = Variables.unify(nal.memory.randomNumber, Symbols.VAR_DEPENDENT, oldCondition.term[index], commonComponent, u);</span>
<span class="fc" id="L725">        premise1 = (Equivalence) u[0]; premise2 = u[1];</span>
        
<span class="fc bfc" id="L727" title="All 4 branches covered.">        if (!match &amp;&amp; (commonComponent.getClass() == oldCondition.getClass())) {</span>
<span class="fc" id="L728">            u = new Term[] { premise1, premise2 };</span>
<span class="fc" id="L729">            match = Variables.unify(nal.memory.randomNumber, Symbols.VAR_DEPENDENT, oldCondition.term[index], ((CompoundTerm) commonComponent).term[index], u);</span>
<span class="fc" id="L730">            premise1 = (Equivalence) u[0]; premise2 = u[1];</span>
        }
<span class="fc bfc" id="L732" title="All 2 branches covered.">        if (!match) {</span>
<span class="fc" id="L733">            return;</span>
        }
<span class="fc" id="L735">        final int conjunctionOrder = oldCondition.getTemporalOrder();</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">        if (conjunctionOrder == ORDER_FORWARD) {</span>
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">            if (index &gt; 0) {</span>
<span class="nc" id="L738">                return;</span>
            }
<span class="pc bpc" id="L740" title="3 of 4 branches missed.">            if ((side == 0) &amp;&amp; (premise2.getTemporalOrder() == ORDER_FORWARD)) {</span>
<span class="nc" id="L741">                return;</span>
            }
<span class="pc bpc" id="L743" title="3 of 4 branches missed.">            if ((side == 1) &amp;&amp; (premise2.getTemporalOrder() == ORDER_BACKWARD)) {</span>
<span class="nc" id="L744">                return;</span>
            }
        }
        final Term newCondition;
<span class="fc bfc" id="L748" title="All 2 branches covered.">        if (oldCondition.equals(commonComponent)) {</span>
<span class="fc" id="L749">            newCondition = null;</span>
        } else {
<span class="fc" id="L751">            newCondition = oldCondition.setComponent(index, newComponent, nal.mem());</span>
        }
        final Term content;
<span class="fc bfc" id="L754" title="All 2 branches covered.">        if (newCondition != null) {</span>
<span class="fc" id="L755">            content = Statement.make(premise1, newCondition, premise1.getPredicate(), premise1.getTemporalOrder());</span>
        } else {
<span class="fc" id="L757">            content = premise1.getPredicate();</span>
        }
        
<span class="fc bfc" id="L760" title="All 2 branches covered.">        if (content == null)</span>
<span class="fc" id="L761">            return;</span>
        
<span class="fc" id="L763">        final TruthValue truth1 = taskSentence.truth;</span>
<span class="fc" id="L764">        final TruthValue truth2 = belief.truth;</span>
<span class="fc" id="L765">        TruthValue truth = null;</span>
        final BudgetValue budget;
<span class="pc bpc" id="L767" title="1 of 4 branches missed.">        if (!(taskSentence.isQuestion() || taskSentence.isQuest())) {</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">            if (taskSentence.isGoal()) {</span>
<span class="fc" id="L769">                truth = TruthFunctions.lookupTruthFunctionByBoolAndCompute(conditionalTask, TruthFunctions.EnumType.DESIREWEAK, TruthFunctions.EnumType.DESIREDED, truth1, truth2, nal.narParameters);</span>
            } else {
<span class="fc" id="L771">                truth = TruthFunctions.lookupTruthFunctionByBoolAndCompute(conditionalTask, TruthFunctions.EnumType.COMPARISON, TruthFunctions.EnumType.ANALOGY, truth1, truth2, nal.narParameters);</span>
            }
        }

<span class="pc bpc" id="L775" title="1 of 4 branches missed.">        if (taskSentence.isQuestion() || taskSentence.isQuest()) {</span>
<span class="fc" id="L776">            budget = BudgetFunctions.backwardWeak(truth2, nal);</span>
        } else {
<span class="fc" id="L778">            budget = BudgetFunctions.forward(truth, nal);</span>
        }

<span class="pc bpc" id="L781" title="1 of 4 branches missed.">        nal.doublePremiseTask(content, truth, budget, false, taskSentence.isJudgment() &amp;&amp; !conditionalTask); //(allow overlap) when !conditionalTask on judgment</span>
<span class="fc" id="L782">    }</span>

    /**
     * {&amp;lt;(&amp;amp;&amp;amp;, S2, S3) ==&amp;gt; P&amp;gt;, &amp;lt;(&amp;amp;&amp;amp;, S1, S3) ==&amp;gt; P&amp;gt;} |- &amp;lt;S1 ==&amp;gt; S2&amp;gt;
     *
     * @param cond1 The condition of the first premise
     * @param cond2 The condition of the second premise
     * @param st1 The first premise
     * @param st2 The second premise
     * @param nal Reference to the memory
     * @return Whether there are derived tasks
     */
    static boolean conditionalAbd(final Term cond1, final Term cond2, final Statement st1, final Statement st2, final DerivationContext nal) {
<span class="pc bpc" id="L795" title="1 of 4 branches missed.">        if (!(st1 instanceof Implication) || !(st2 instanceof Implication)) {</span>
<span class="fc" id="L796">            return false;</span>
        }
<span class="fc bfc" id="L798" title="All 4 branches covered.">        if (!(cond1 instanceof Conjunction) &amp;&amp; !(cond2 instanceof Conjunction)) {</span>
<span class="fc" id="L799">            return false;</span>
        }
<span class="fc" id="L801">        final int order1 = st1.getTemporalOrder();</span>
<span class="fc" id="L802">        final int order2 = st2.getTemporalOrder();</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (order1 != reverseOrder(order2)) {</span>
<span class="fc" id="L804">            return false;</span>
        }
<span class="fc" id="L806">        Term term1 = null;</span>
<span class="fc" id="L807">        Term term2 = null;</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">        if (cond1 instanceof Conjunction) {</span>
<span class="fc" id="L809">            term1 = reduceComponents((CompoundTerm) cond1, cond2, nal.mem());</span>
        }
<span class="fc bfc" id="L811" title="All 2 branches covered.">        if (cond2 instanceof Conjunction) {</span>
<span class="fc" id="L812">            term2 = reduceComponents((CompoundTerm) cond2, cond1, nal.mem());</span>
        }
<span class="fc bfc" id="L814" title="All 4 branches covered.">        if ((term1 == null) &amp;&amp; (term2 == null)) {</span>
<span class="fc" id="L815">            return false;</span>
        }
<span class="fc" id="L817">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L818">        final Sentence sentence = task.sentence;</span>
<span class="fc" id="L819">        final Sentence belief = nal.getCurrentBelief();</span>
<span class="fc" id="L820">        final TruthValue value1 = sentence.truth;</span>
<span class="fc" id="L821">        final TruthValue value2 = belief.truth;</span>

<span class="fc" id="L823">        final boolean keepOrder = Variables.hasSubstitute(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT, st1, task.getTerm());</span>

        // we folded the logic to use loops for more compact code
<span class="fc bfc" id="L826" title="All 2 branches covered.">        for (int loop=0;loop&lt;2;loop++) {</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">            final boolean isFirstLoop = loop == 0;</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">            Term term1InLoop = isFirstLoop ? term1 : term2;</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">            Term term2InLoop = isFirstLoop ? term2 : term1;</span>

<span class="fc bfc" id="L831" title="All 2 branches covered.">            if (term1InLoop == null) {</span>
<span class="fc" id="L832">                continue;</span>
            }
            Term content;
<span class="fc" id="L835">            TruthValue truth = null;</span>
            BudgetValue budget;

<span class="fc bfc" id="L838" title="All 2 branches covered.">            if (term2InLoop != null) {</span>
<span class="fc bfc" id="L839" title="All 4 branches covered.">                content = Statement.make(isFirstLoop ? st2 : st1, term2InLoop, term1InLoop, isFirstLoop ? st2.getTemporalOrder() : st1.getTemporalOrder());</span>
            } else {
<span class="fc" id="L841">                content = term1InLoop;</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">                if(content.hasVarIndep()) {</span>
<span class="fc" id="L843">                    return false;</span>
                }
            }

<span class="pc bpc" id="L847" title="1 of 4 branches missed.">            if (sentence.isQuestion() || sentence.isQuest()) {</span>
<span class="fc" id="L848">                budget = BudgetFunctions.backwardWeak(value2, nal);</span>
            } else {
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">                if (sentence.isGoal()) {</span>
<span class="nc" id="L851">                    truth = TruthFunctions.lookupTruthFunctionByBoolAndCompute(keepOrder, TruthFunctions.EnumType.DESIREDED, TruthFunctions.EnumType.DESIREIND, value1, value2, nal.narParameters);</span>
                } else { // isJudgment
<span class="fc bfc" id="L853" title="All 2 branches covered.">                    if (isFirstLoop) {</span>
<span class="fc" id="L854">                        truth = TruthFunctions.abduction(value2, value1, nal.narParameters);</span>
                    }
                    else {
<span class="fc" id="L857">                        truth = TruthFunctions.abduction(value1, value2, nal.narParameters);</span>
                    }
                }
<span class="fc" id="L860">                budget = BudgetFunctions.forward(truth, nal);</span>
            }
<span class="fc" id="L862">            nal.doublePremiseTask(content, truth, budget,false, false);</span>
        }
        
<span class="fc" id="L865">        return true;</span>
    }

    /**
     * {(&amp;amp;&amp;amp;, &amp;lt;#x() --&amp;gt; S&amp;gt;, &amp;lt;#x() --&amp;gt; P&amp;gt;&amp;gt;, &amp;lt;M --&amp;gt; P&amp;gt;} |- &amp;lt;M --&amp;gt; S&amp;gt;
     *
     * @param compound The compound term to be decomposed
     * @param component The part of the compound to be removed
     * @param compoundTask Whether the compound comes from the task
     * @param nal Reference to the memory
     */
    static void elimiVarDep(final CompoundTerm compound, final Term component, final boolean compoundTask, final DerivationContext nal) {
<span class="fc" id="L877">        Term comp = null;</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">        for(final Term t : compound) {</span>
<span class="fc" id="L879">            final Term[] unify = new Term[] { t, component };</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">            if(Variables.unify(nal.memory.randomNumber, Symbols.VAR_DEPENDENT, unify)) {</span>
<span class="fc" id="L881">                comp = t;</span>
<span class="fc" id="L882">                break;</span>
            }
<span class="fc bfc" id="L884" title="All 2 branches covered.">            if(Variables.unify(nal.memory.randomNumber, Symbols.VAR_QUERY, unify)) {</span>
<span class="fc" id="L885">                comp = t;</span>
<span class="fc" id="L886">                break;</span>
            }
<span class="fc" id="L888">        }</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">        if(comp == null) {</span>
<span class="fc" id="L890">            return;</span>
        }
<span class="fc" id="L892">        final Term content = reduceComponents(compound, comp, nal.mem());</span>
<span class="pc bpc" id="L893" title="2 of 6 branches missed.">        if ((content == null) || ((content instanceof Statement) &amp;&amp; ((Statement) content).invalid())) {</span>
<span class="nc" id="L894">            return;</span>
        }
<span class="fc" id="L896">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L897">        final Sentence sentence = task.sentence;</span>
<span class="fc" id="L898">        final Sentence belief = nal.getCurrentBelief();</span>
<span class="fc" id="L899">        final TruthValue v1 = sentence.truth;</span>
<span class="fc" id="L900">        final TruthValue v2 = belief.truth;</span>
<span class="fc" id="L901">        TruthValue truth = null;</span>
        final BudgetValue budget;

<span class="pc bpc" id="L904" title="1 of 4 branches missed.">        if (!(sentence.isQuestion() || sentence.isQuest())) {</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">            if (sentence.isGoal()) {</span>
<span class="fc" id="L906">                truth = TruthFunctions.lookupTruthFunctionByBoolAndCompute(compoundTask, TruthFunctions.EnumType.DESIREDED, TruthFunctions.EnumType.DESIREIND, v1, v2, nal.narParameters);</span>
            } else {
<span class="fc bfc" id="L908" title="All 2 branches covered.">                truth = (compoundTask ? TruthFunctions.anonymousAnalogy(v1, v2, nal.narParameters) : TruthFunctions.anonymousAnalogy(v2, v1, nal.narParameters));</span>
            }
        }

<span class="pc bpc" id="L912" title="1 of 4 branches missed.">        if (sentence.isQuestion() || sentence.isQuest()) {</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">            budget = (compoundTask ? BudgetFunctions.backward(v2, nal) : BudgetFunctions.backwardWeak(v2, nal));</span>
        } else {
<span class="fc" id="L915">            budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
        }

<span class="fc" id="L918">        nal.doublePremiseTask(content, truth, budget,false, false);</span>
<span class="fc" id="L919">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>