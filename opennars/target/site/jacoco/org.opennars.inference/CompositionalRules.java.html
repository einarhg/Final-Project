<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompositionalRules.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.inference</a> &gt; <span class="el_source">CompositionalRules.java</span></div><h1>CompositionalRules.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.inference;

import java.util.ArrayList;
import java.util.Collections;
import org.opennars.control.DerivationContext;
import org.opennars.entity.*;
import org.opennars.io.Symbols;
import org.opennars.language.*;
import org.opennars.main.Debug;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;

import static org.opennars.inference.TruthFunctions.*;
import static org.opennars.language.Terms.reduceComponents;
import org.opennars.storage.Memory;

/**
 * Compound term composition and decomposition rules, with two premises.
 * &lt;p&gt;
 * New compound terms are introduced only in forward inference, while
 * decompositional rules are also used in backward inference
 *
 * @author Pei Wang
 * @author Patrick Hammer
 */
<span class="nc" id="L55">public final class CompositionalRules {</span>

    /* -------------------- intersections and differences -------------------- */
    /**
     * {&amp;lt;S ==&amp;gt; M&amp;gt;, &amp;lt;P ==&amp;gt; M&amp;gt;} |- &lt;br&gt;
     * {&amp;lt;(S|P) ==&amp;gt; M&amp;gt;, &amp;lt;(S&amp;amp;P) ==&amp;gt; M&amp;gt;, &amp;lt;(S-P) ==&amp;gt; M&amp;gt;, &amp;lt;(P-S) ==&amp;gt; M&amp;gt;}
     *
     * @param taskContent The first premise
     * @param beliefContent The second premise
     * @param index The location of the shared term
     * @param nal Reference to the memory
     */
    static void composeCompound(final Statement taskContent, final Statement beliefContent, final int index, final DerivationContext nal) {
<span class="fc bfc" id="L68" title="All 4 branches covered.">        if ((!nal.getCurrentTask().sentence.isJudgment()) || (taskContent.getClass() != beliefContent.getClass())) {</span>
<span class="fc" id="L69">            return;</span>
        }   
<span class="fc" id="L71">        final Term componentT = taskContent.term[1 - index];</span>
<span class="fc" id="L72">        final Term componentB = beliefContent.term[1 - index];</span>
<span class="fc" id="L73">        final Term componentCommon = taskContent.term[index];</span>
<span class="fc" id="L74">        final int order1 = taskContent.getTemporalOrder();</span>
<span class="fc" id="L75">        final int order2 = beliefContent.getTemporalOrder();</span>
<span class="fc" id="L76">        final int order = TemporalRules.composeOrder(order1, order2);</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (order == TemporalRules.ORDER_INVALID) {</span>
<span class="fc" id="L78">            return;</span>
        } 
<span class="fc bfc" id="L80" title="All 4 branches covered.">        if ((componentT instanceof CompoundTerm) &amp;&amp; ((CompoundTerm) componentT).containsAllTermsOf(componentB)) {</span>
<span class="fc" id="L81">            decomposeCompound((CompoundTerm) componentT, componentB, componentCommon, index, true, order, nal);</span>
<span class="fc" id="L82">            return;</span>
<span class="fc bfc" id="L83" title="All 4 branches covered.">        } else if ((componentB instanceof CompoundTerm) &amp;&amp; ((CompoundTerm) componentB).containsAllTermsOf(componentT)) {</span>
<span class="fc" id="L84">            decomposeCompound((CompoundTerm) componentB, componentT, componentCommon, index, false, order, nal);</span>
<span class="fc" id="L85">            return;</span>
        }
<span class="fc" id="L87">        final TruthValue truthT = nal.getCurrentTask().sentence.truth;</span>
<span class="fc" id="L88">        final TruthValue truthB = nal.getCurrentBelief().truth;</span>
<span class="fc" id="L89">        final TruthValue truthOr = union(truthT, truthB, nal.narParameters);</span>
<span class="fc" id="L90">        final TruthValue truthAnd = intersection(truthT, truthB, nal.narParameters);</span>
<span class="fc" id="L91">        TruthValue truthDif = null;</span>
<span class="fc" id="L92">        Term termOr = null;</span>
<span class="fc" id="L93">        Term termAnd = null;</span>
<span class="fc" id="L94">        Term termDif = null;</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (index == 0) {</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">            if (taskContent instanceof Inheritance) {</span>
<span class="fc" id="L97">                termOr = IntersectionInt.make(componentT, componentB);</span>
<span class="fc" id="L98">                termAnd = IntersectionExt.make(componentT, componentB);</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">                if (truthB.isNegative()) {</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">                    if (!truthT.isNegative()) {</span>
<span class="fc" id="L101">                        termDif = DifferenceExt.make(componentT, componentB);</span>
<span class="fc" id="L102">                        truthDif = intersection(truthT, negation(truthB, nal.narParameters), nal.narParameters);</span>
                    }
<span class="fc bfc" id="L104" title="All 2 branches covered.">                } else if (truthT.isNegative()) {</span>
<span class="fc" id="L105">                    termDif = DifferenceExt.make(componentB, componentT);</span>
<span class="fc" id="L106">                    truthDif = intersection(truthB, negation(truthT, nal.narParameters), nal.narParameters);</span>
                }
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">            } else if (taskContent instanceof Implication) {</span>
<span class="fc" id="L109">                termOr = Disjunction.make(componentT, componentB);</span>
<span class="fc" id="L110">                termAnd = Conjunction.make(componentT, componentB);</span>
            }
<span class="fc bfc" id="L112" title="All 2 branches covered.">            if(!(componentT.cloneDeep().equals(componentB.cloneDeep()))) {</span>
<span class="fc" id="L113">                processComposed(taskContent, componentCommon, termOr, order, truthOr, nal);</span>
<span class="fc" id="L114">                processComposed(taskContent, componentCommon, termAnd, order, truthAnd, nal);</span>
            }
<span class="fc" id="L116">            processComposed(taskContent, componentCommon, termDif, order, truthDif, nal);</span>
        } else {    // index == 1
<span class="fc bfc" id="L118" title="All 2 branches covered.">            if (taskContent instanceof Inheritance) {</span>
<span class="fc" id="L119">                termOr = IntersectionExt.make(componentT, componentB);</span>
<span class="fc" id="L120">                termAnd = IntersectionInt.make(componentT, componentB);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">                if (truthB.isNegative()) {</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">                    if (!truthT.isNegative()) {</span>
<span class="fc" id="L123">                        termDif = DifferenceInt.make(componentT, componentB);</span>
<span class="fc" id="L124">                        truthDif = intersection(truthT, negation(truthB, nal.narParameters), nal.narParameters);</span>
                    }
<span class="fc bfc" id="L126" title="All 2 branches covered.">                } else if (truthT.isNegative()) {</span>
<span class="fc" id="L127">                    termDif = DifferenceInt.make(componentB, componentT);</span>
<span class="fc" id="L128">                    truthDif = intersection(truthB, negation(truthT, nal.narParameters), nal.narParameters);</span>
                }
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">            } else if (taskContent instanceof Implication) {</span>
<span class="fc" id="L131">                termOr = Conjunction.make(componentT, componentB);</span>
<span class="fc" id="L132">                termAnd = Disjunction.make(componentT, componentB);</span>
            }
            
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if(!(componentT.cloneDeep().equals(componentB.cloneDeep()))) {</span>
<span class="fc" id="L136">                processComposed(taskContent, termOr, componentCommon, order, truthOr, nal);</span>
<span class="fc" id="L137">                processComposed(taskContent, termAnd, componentCommon, order, truthAnd, nal);</span>
            }
<span class="fc" id="L139">            processComposed(taskContent, termDif, componentCommon, order, truthDif, nal);</span>
        }
<span class="fc" id="L141">    }</span>

    /**
     * Finish composing implication term
     *
     * @param statement Type of the contentInd
     * @param subject Subject of contentInd
     * @param predicate Predicate of contentInd
     * @param truth TruthValue of the contentInd
     * @param nal Reference to the memory
     */
    private static void processComposed(final Statement statement, final Term subject, final Term predicate, final int order, final TruthValue truth, final DerivationContext nal) {
<span class="fc bfc" id="L153" title="All 4 branches covered.">        if ((subject == null) || (predicate == null)) {</span>
<span class="fc" id="L154">            return;</span>
        }
<span class="fc" id="L156">        final Term content = Statement.make(statement, subject, predicate, order);</span>
<span class="pc bpc" id="L157" title="1 of 8 branches missed.">        if ((content == null) || statement == null || content.equals(statement) || content.equals(nal.getCurrentBelief().term)) {</span>
<span class="fc" id="L158">            return;</span>
        }
<span class="fc" id="L160">        final BudgetValue budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
<span class="fc" id="L161">        nal.doublePremiseTask(content, truth, budget, false, false); //(allow overlap) but not needed here, isn't detachment, this one would be even problematic from control perspective because its composition</span>
<span class="fc" id="L162">    }</span>

    /**
     * {&amp;lt;(S|P) ==&amp;gt; M&amp;gt;, &amp;lt;P ==&amp;gt; M&amp;gt;} |- &amp;lt;S ==&amp;gt; M&amp;gt;
     *
     * @param term1 The other term in the contentInd
     * @param index The location of the shared term: 0 for subject, 1 for predicate
     * @param compoundTask Whether the implication comes from the task
     * @param nal Reference to the memory
     */
    private static void decomposeCompound(final CompoundTerm compound, final Term component, final Term term1, final int index, final boolean compoundTask, final int order, final DerivationContext nal) {

<span class="fc bfc" id="L174" title="All 6 branches covered.">        if ((compound instanceof Statement) || (compound instanceof ImageExt) || (compound instanceof ImageInt)) {</span>
<span class="fc" id="L175">            return;</span>
        }
<span class="fc" id="L177">        Term term2 = reduceComponents(compound, component, nal.mem());</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (term2 == null) {</span>
<span class="fc" id="L179">            return;</span>
        }
        
<span class="fc" id="L182">        long delta = 0;</span>
<span class="fc bfc" id="L183" title="All 4 branches covered.">        while ((term2 instanceof Conjunction) &amp;&amp; (((CompoundTerm) term2).term[0] instanceof Interval)) {</span>
<span class="fc" id="L184">            final Interval interval = (Interval) ((CompoundTerm) term2).term[0];</span>
<span class="fc" id="L185">            delta += interval.time;</span>
<span class="fc" id="L186">            term2 = ((CompoundTerm)term2).setComponent(0, null, nal.mem());</span>
<span class="fc" id="L187">        }</span>
        
<span class="fc" id="L189">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L190">        final Sentence sentence = task.sentence;</span>
<span class="fc" id="L191">        final Sentence belief = nal.getCurrentBelief();</span>
<span class="fc" id="L192">        final Statement oldContent = (Statement) task.getTerm();</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">        final TruthValue v1 = compoundTask ? sentence.truth : belief.truth;</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        final TruthValue v2 = compoundTask ? belief.truth : sentence.truth;</span>

<span class="fc bfc" id="L197" title="All 4 branches covered.">        final Term content = Statement.make(oldContent, index == 0 ? term1 : term2, index == 0 ? term2 : term1, order);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (content == null) {</span>
<span class="fc" id="L199">            return;</span>
        }

<span class="fc" id="L202">        TruthValue truth = null;</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (index == 0) {</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if (oldContent instanceof Inheritance) {</span>
<span class="fc" id="L205">                truth = lookupTruthOrNull(v1, v2, nal.narParameters,</span>
<span class="fc" id="L206">                    compound instanceof IntersectionExt,               EnumType.REDUCECONJUNCTION,</span>
<span class="pc bpc" id="L207" title="3 of 4 branches missed.">                    compound instanceof IntersectionInt,                       EnumType.REDUCEDISJUNCTION,</span>
<span class="pc bpc" id="L208" title="3 of 4 branches missed.">                    compound instanceof SetInt &amp;&amp; component instanceof SetInt, EnumType.REDUCECONJUNCTION,</span>
<span class="fc" id="L209">                    compound instanceof SetExt &amp;&amp; component instanceof SetExt, EnumType.REDUCEDISJUNCTION);</span>

<span class="fc bfc" id="L211" title="All 4 branches covered.">                if (truth == null &amp;&amp; compound instanceof DifferenceExt) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">                    if (compound.term[0].equals(component)) {</span>
<span class="fc" id="L213">                        truth = reduceDisjunction(v2, v1, nal.narParameters);</span>
                    } else {
<span class="fc" id="L215">                        truth = reduceConjunctionNeg(v1, v2, nal.narParameters);</span>
                    }
                }
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            } else if (oldContent instanceof Implication) {</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                if (compound instanceof Conjunction) {</span>
<span class="fc" id="L220">                    truth = reduceConjunction(v1, v2, nal.narParameters);</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">                } else if (compound instanceof Disjunction) {</span>
<span class="fc" id="L222">                    truth = reduceDisjunction(v1, v2, nal.narParameters);</span>
                }
            }
        } else {
<span class="fc bfc" id="L226" title="All 2 branches covered.">            if (oldContent instanceof Inheritance) {</span>
<span class="fc" id="L227">                truth = lookupTruthOrNull(v1, v2, nal.narParameters,</span>
<span class="fc" id="L228">                    compound instanceof IntersectionInt,               EnumType.REDUCECONJUNCTION,</span>
<span class="pc bpc" id="L229" title="3 of 4 branches missed.">                    compound instanceof IntersectionExt,                       EnumType.REDUCEDISJUNCTION,</span>
<span class="pc bpc" id="L230" title="3 of 4 branches missed.">                    compound instanceof SetExt &amp;&amp; component instanceof SetExt, EnumType.REDUCECONJUNCTION,</span>
<span class="fc" id="L231">                    compound instanceof SetInt &amp;&amp; component instanceof SetInt, EnumType.REDUCEDISJUNCTION);</span>

<span class="fc bfc" id="L233" title="All 4 branches covered.">                if( truth == null &amp;&amp; compound instanceof DifferenceInt ) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">                    if (compound.term[1].equals(component)) {</span>
<span class="fc" id="L235">                        truth = reduceDisjunction(v2, v1, nal.narParameters);</span>
                    } else {
<span class="fc" id="L237">                        truth = reduceConjunctionNeg(v1, v2, nal.narParameters);</span>
                    }
                }
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            } else if (oldContent instanceof Implication) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                if (compound instanceof Disjunction) {</span>
<span class="fc" id="L242">                    truth = reduceConjunction(v1, v2, nal.narParameters);</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">                } else if (compound instanceof Conjunction) {</span>
<span class="fc" id="L244">                    truth = reduceDisjunction(v1, v2, nal.narParameters);</span>
                }
            }
        }
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (truth != null) {</span>
<span class="fc" id="L249">            final BudgetValue budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (delta != 0) {</span>
<span class="fc" id="L251">                long baseTime = task.sentence.getOccurenceTime();</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">                if (baseTime != Stamp.ETERNAL) {</span>
<span class="nc" id="L253">                    baseTime += delta;</span>
<span class="nc" id="L254">                    nal.getTheNewStamp().setOccurrenceTime(baseTime);</span>
                }
            }
<span class="fc" id="L257">            nal.doublePremiseTask(content, truth, budget, false, true); //(allow overlap), a form of detachment</span>
        }
<span class="fc" id="L259">    }</span>

    /**
     * {(||, S, P), P} |- S {(&amp;amp;&amp;amp;, S, P), P} |- S
     *
     * @param compoundTask Whether the implication comes from the task
     * @param nal Reference to the memory
     */
    static void decomposeStatement(final CompoundTerm compound, final Term component, final boolean compoundTask, final int index, final DerivationContext nal) {
<span class="fc bfc" id="L268" title="All 4 branches covered.">        final boolean isTemporalConjunction = (compound instanceof Conjunction) &amp;&amp; !((Conjunction) compound).isSpatial;</span>
<span class="fc bfc" id="L269" title="All 6 branches covered.">        if (isTemporalConjunction &amp;&amp; (compound.getTemporalOrder() == TemporalRules.ORDER_FORWARD) &amp;&amp; (index != 0)) {</span>
<span class="fc" id="L270">            return;</span>
        }
<span class="fc" id="L272">        long occurrence_time = nal.getCurrentTask().sentence.getOccurenceTime();</span>
<span class="fc bfc" id="L273" title="All 4 branches covered.">        if(isTemporalConjunction &amp;&amp; (compound.getTemporalOrder() == TemporalRules.ORDER_FORWARD)) {</span>
<span class="fc bfc" id="L274" title="All 4 branches covered.">            if(!nal.getCurrentTask().sentence.isEternal() &amp;&amp; compound.term[index + 1] instanceof Interval) {</span>
<span class="fc" id="L275">                final long shift_occurrence = ((Interval)compound.term[index + 1]).time;</span>
<span class="fc" id="L276">                occurrence_time = nal.getCurrentTask().sentence.getOccurenceTime() + shift_occurrence;</span>
            }
        }

<span class="fc" id="L280">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L281">        final Sentence taskSentence = task.sentence;</span>
<span class="fc" id="L282">        final Sentence belief = nal.getCurrentBelief();</span>
<span class="fc" id="L283">        final Term content = reduceComponents(compound, component, nal.mem());</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (content == null) {</span>
<span class="fc" id="L285">            return;</span>
        }
<span class="fc" id="L287">        TruthValue truth = null;</span>
        BudgetValue budget;
<span class="pc bpc" id="L289" title="1 of 4 branches missed.">        if (taskSentence.isQuestion() || taskSentence.isQuest()) {</span>
<span class="fc" id="L290">            budget = BudgetFunctions.compoundBackward(content, nal);</span>
<span class="fc" id="L291">            nal.getTheNewStamp().setOccurrenceTime(occurrence_time);</span>
<span class="fc" id="L292">            nal.doublePremiseTask(content, truth, budget, false, false);</span>
            // special inference to answer conjunctive questions with query variables
<span class="fc bfc" id="L294" title="All 2 branches covered.">            if (taskSentence.term.hasVarQuery()) {</span>
<span class="fc" id="L295">                final Concept contentConcept = nal.mem().concept(content);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                if (contentConcept == null) {</span>
<span class="fc" id="L297">                    return;</span>
                }
<span class="fc" id="L299">                final Sentence contentBelief = contentConcept.getBelief(nal, task);</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                if (contentBelief == null) {</span>
<span class="fc" id="L301">                    return;</span>
                }

<span class="fc" id="L304">                final Task contentTask = new Task(contentBelief, task.budget, Task.EnumType.DERIVED);</span>

<span class="fc" id="L306">                nal.setCurrentTask(contentTask);</span>
<span class="fc" id="L307">                final Term conj = Conjunction.make(component, content);</span>
<span class="fc" id="L308">                truth = intersection(contentBelief.truth, belief.truth, nal.narParameters);</span>
<span class="fc" id="L309">                budget = BudgetFunctions.compoundForward(truth, conj, nal);</span>
<span class="fc" id="L310">                nal.getTheNewStamp().setOccurrenceTime(occurrence_time);</span>
<span class="fc" id="L311">                nal.doublePremiseTask(conj, truth, budget, false, false);</span>
<span class="fc" id="L312">            }</span>
        } else {
<span class="fc bfc" id="L314" title="All 2 branches covered.">            final TruthValue v1 = compoundTask ? taskSentence.truth : belief.truth;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">            final TruthValue v2 = compoundTask ? belief.truth : taskSentence.truth;</span>

<span class="pc bpc" id="L317" title="1 of 4 branches missed.">            if (compound instanceof Conjunction || compound instanceof Disjunction) {</span>
<span class="fc bfc" id="L318" title="All 4 branches covered.">                if (taskSentence.isGoal() &amp;&amp; !compoundTask) {</span>
<span class="fc" id="L319">                    return;</span>
                }
            } else {
<span class="nc" id="L322">                return;</span>
            }

<span class="fc bfc" id="L325" title="All 2 branches covered.">            if (compound instanceof Conjunction) {</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">                if (taskSentence.isGoal()) {</span>
<span class="fc" id="L327">                    truth = intersection(v1, v2, nal.narParameters);</span>
                } else { // isJudgment
<span class="fc" id="L329">                    truth = reduceConjunction(v1, v2, nal.narParameters);</span>
                }
            } else {
<span class="fc bfc" id="L332" title="All 2 branches covered.">                if (taskSentence.isGoal()) {</span>
<span class="fc" id="L333">                    truth = reduceConjunction(v2, v1, nal.narParameters);</span>
                } else {  // isJudgment
<span class="fc" id="L335">                    truth = reduceDisjunction(v1, v2, nal.narParameters);</span>
                }
            }

<span class="fc" id="L339">            budget = BudgetFunctions.compoundForward(truth, content, nal);</span>
        }
<span class="fc" id="L341">        nal.getTheNewStamp().setOccurrenceTime(occurrence_time);</span>
<span class="fc" id="L342">        nal.doublePremiseTask(content, truth, budget, false, false);</span>
<span class="fc" id="L343">    }</span>

    
    /* --------------- rules used for variable introduction --------------- */
    /**
     * Introduce a dependent variable in an outer-layer conjunction
     * &lt;br&gt;
     * {&amp;lt;S --&amp;gt; P1&amp;gt;, &amp;lt;S --&amp;gt; P2&amp;gt;} |- (&amp;amp;&amp;amp;, &amp;lt;#x --&amp;gt; P1&amp;gt;, &amp;lt;#x --&amp;gt; P2&amp;gt;)
     *
     * @param taskContent The first premise &amp;lt;M --&amp;gt; S&amp;gt;
     * @param beliefContent The second premise &amp;lt;M --&amp;gt; P&amp;gt;
     * @param index The location of the shared term: 0 for subject, 1 for
     * predicate
     * @param nal Reference to the memory
     */
    public static void introVarOuter(final Statement taskContent, final Statement beliefContent, final int index, final DerivationContext nal) {

<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (!(taskContent instanceof Inheritance)) {</span>
<span class="fc" id="L361">            return;</span>
        }
        
<span class="fc" id="L364">        Term term11 = taskContent.getSubject();</span>
<span class="fc" id="L365">        Term term21 = beliefContent.getSubject();</span>
<span class="fc" id="L366">        Term term12 = taskContent.getPredicate();</span>
<span class="fc" id="L367">        Term term22 = beliefContent.getPredicate();</span>
<span class="fc" id="L368">        Statement state1 = Inheritance.make(term11, term12);</span>
<span class="fc" id="L369">        Statement state2 = Inheritance.make(term21, term22);</span>
<span class="fc" id="L370">        final TruthValue truthT = nal.getCurrentTask().sentence.truth;</span>
<span class="fc" id="L371">        final TruthValue truthB = nal.getCurrentBelief().truth;</span>
<span class="pc bpc" id="L372" title="1 of 4 branches missed.">        if ((truthT == null) || (truthB == null)) {</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">            if(Debug.DETAILED) {</span>
<span class="nc" id="L374">                System.out.println(&quot;ERROR: Belief with null truth value. (introVarOuter)&quot;);</span>
            }
<span class="fc" id="L376">            return;</span>
        }
<span class="fc bfc" id="L378" title="All 2 branches covered.">        for(boolean subjectIntroduction : new boolean[]{true, false}) {</span>
<span class="fc" id="L379">            Set&lt;Pair&lt;Term,Float&gt;&gt; contents = CompositionalRules.introduceVariables(nal, Implication.make(state1, state2),subjectIntroduction);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            for(Pair&lt;Term,Float&gt; content_penalty : contents) {</span>
<span class="fc" id="L381">                TruthValue truth = induction(truthT, truthB, nal.narParameters).mulConfidence(content_penalty.getRight());</span>
<span class="fc" id="L382">                BudgetValue budget = BudgetFunctions.compoundForward(truth, content_penalty.getLeft(), nal);</span>
<span class="fc" id="L383">                nal.doublePremiseTask(content_penalty.getLeft(), truth, budget.clone(), false, false);</span>
<span class="fc" id="L384">            }</span>

<span class="fc" id="L386">            contents = CompositionalRules.introduceVariables(nal, Implication.make(state2, state1), subjectIntroduction);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">             for(Pair&lt;Term,Float&gt; content_penalty : contents) {</span>
<span class="fc" id="L388">                TruthValue truth = induction(truthB, truthT, nal.narParameters).mulConfidence(content_penalty.getRight());</span>
<span class="fc" id="L389">                BudgetValue budget = BudgetFunctions.compoundForward(truth, content_penalty.getLeft(), nal);</span>
<span class="fc" id="L390">                nal.doublePremiseTask(content_penalty.getLeft(), truth, budget.clone(), false, false);</span>
<span class="fc" id="L391">            }</span>

<span class="fc" id="L393">            contents = CompositionalRules.introduceVariables(nal, Equivalence.make(state1, state2), subjectIntroduction);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">             for(Pair&lt;Term,Float&gt; content_penalty : contents) {</span>
<span class="fc" id="L395">                TruthValue truth = comparison(truthT, truthB, nal.narParameters).mulConfidence(content_penalty.getRight());</span>
<span class="fc" id="L396">                BudgetValue budget = BudgetFunctions.compoundForward(truth, content_penalty.getLeft(), nal);</span>
<span class="fc" id="L397">                nal.doublePremiseTask(content_penalty.getLeft(), truth, budget.clone(), false, false);</span>
<span class="fc" id="L398">            }</span>

<span class="fc" id="L400">            contents = CompositionalRules.introduceVariables(nal, Conjunction.make(state1, state2), subjectIntroduction);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            for(Pair&lt;Term,Float&gt; content_penalty : contents) {</span>
<span class="fc" id="L402">                TruthValue truth = intersection(truthT, truthB, nal.narParameters).mulConfidence(content_penalty.getRight());</span>
<span class="fc" id="L403">                BudgetValue budget = BudgetFunctions.compoundForward(truth, content_penalty.getLeft(), nal);</span>
<span class="fc" id="L404">                nal.doublePremiseTask(content_penalty.getLeft(), truth, budget.clone(), false, false);</span>
<span class="fc" id="L405">            }</span>
        }
<span class="fc" id="L407">    }</span>

    /**
     * {&amp;lt;M --&amp;gt; S&amp;gt;, &amp;lt;C ==&amp;gt; &amp;lt;M --&amp;gt; P&amp;gt;&amp;gt;} |- &amp;lt;(&amp;amp;&amp;amp;, &amp;lt;#x --&amp;gt; S&amp;gt;, C) ==&amp;gt; &amp;lt;#x --&amp;gt; P&amp;gt;&amp;gt;
     * &lt;br&gt;
     * {&amp;lt;M --&amp;gt; S&amp;gt;, (&amp;amp;&amp;amp;, C, &amp;lt;M --&amp;gt; P&amp;gt;)} |- (&amp;amp;&amp;amp;, C, &amp;lt;&amp;lt;#x --&amp;gt; S&amp;gt; ==&amp;gt; &amp;lt;#x --&amp;gt; P&amp;gt;&amp;gt;)
     *
     * @param oldCompound The whole contentInd of the first premise, Implication
     * or Conjunction
     * @param nal Reference to the memory
     */
    static boolean introVarInner(final Statement premise1, final Statement premise2, final CompoundTerm oldCompound, final DerivationContext nal) {
<span class="fc" id="L419">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L420">        final Sentence taskSentence = task.sentence;</span>
<span class="pc bpc" id="L421" title="1 of 6 branches missed.">        if (!taskSentence.isJudgment() || (premise1.getClass() != premise2.getClass()) || oldCompound.containsTerm(premise1)) {</span>
<span class="fc" id="L422">            return false;</span>
        }
<span class="fc" id="L424">        final Sentence belief = nal.getCurrentBelief();</span>
        
<span class="fc" id="L426">        boolean b1 = false, b2 = false;</span>
        
        {
<span class="fc" id="L429">            Term content = Conjunction.make(premise1, oldCompound);</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">            if (!(content instanceof CompoundTerm)) {</span>
<span class="nc" id="L431">                return false;  </span>
            }
<span class="fc bfc" id="L433" title="All 2 branches covered.">            for(boolean subjectIntro : new boolean[]{true, false}) {</span>
<span class="fc" id="L434">                Set&lt;Pair&lt;Term,Float&gt;&gt; conts = introduceVariables(nal, content, subjectIntro);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">                for(Pair&lt;Term,Float&gt; content_penalty : conts) {</span>
<span class="fc" id="L436">                    final TruthValue truth = intersection(taskSentence.truth, belief.truth, nal.narParameters).mulConfidence(content_penalty.getRight());</span>
<span class="fc" id="L437">                    final BudgetValue budget = BudgetFunctions.forward(truth, nal);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">                    b1 |= (nal.doublePremiseTask(content_penalty.getLeft(), truth, budget, false, false))!=null;</span>
<span class="fc" id="L439">                }</span>
            }
        }

        {
<span class="fc" id="L444">            Term content = Implication.make(premise1, oldCompound);</span>
<span class="pc bpc" id="L445" title="1 of 4 branches missed.">            if ((content == null) || (!(content instanceof CompoundTerm))) {</span>
<span class="fc" id="L446">                return false;</span>
            }
<span class="fc bfc" id="L448" title="All 2 branches covered.">            for(boolean subjectIntro : new boolean[]{true, false}) {</span>
<span class="fc" id="L449">                Set&lt;Pair&lt;Term,Float&gt;&gt; conts = introduceVariables(nal, content, subjectIntro);</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">                for(Pair&lt;Term,Float&gt; content_penalty : conts) {</span>
                    final TruthValue truth;
<span class="fc bfc" id="L452" title="All 2 branches covered.">                    if (premise1.equals(taskSentence.term)) {</span>
<span class="fc" id="L453">                        truth = induction(belief.truth, taskSentence.truth, nal.narParameters);</span>
                    } else {
<span class="fc" id="L455">                        truth = induction(taskSentence.truth, belief.truth, nal.narParameters);</span>
                    }
<span class="fc" id="L457">                    truth.mulConfidence(content_penalty.getRight());</span>
<span class="fc" id="L458">                    final BudgetValue budget = BudgetFunctions.forward(truth, nal);</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">                    b2 |= nal.doublePremiseTask(content_penalty.getLeft(), truth, budget, false, false)!=null;</span>
<span class="fc" id="L460">                }</span>
            }
        }
        
<span class="fc bfc" id="L464" title="All 4 branches covered.">        return b1 || b2;</span>
    }

    /*
     * The other inversion (abduction) should also be studied:
     * IN: &lt;&lt;lock1 --&gt; (/,open,$1,_)&gt; ==&gt; &lt;$1 --&gt; key&gt;&gt;.
     * IN: &lt;(&amp;&amp;,&lt;#1 --&gt; lock&gt;,&lt;#1 --&gt; (/,open,$2,_)&gt;) ==&gt; &lt;$2 --&gt; key&gt;&gt;.
     * OUT: &lt;lock1 --&gt; lock&gt;.
     * http://code.google.com/p/open-nars/issues/detail?id=40&amp;can=1
     */
    public static void eliminateVariableOfConditionAbductive(final int figure, final Sentence sentence, final Sentence belief, final DerivationContext nal) {
<span class="fc" id="L475">        Statement T1 = (Statement) sentence.term;</span>
<span class="fc" id="L476">        Statement T2 = (Statement) belief.term;</span>

<span class="fc" id="L478">        Term S1 = T2.getSubject();</span>
<span class="fc" id="L479">        Term S2 = T1.getSubject();</span>
<span class="fc" id="L480">        Term P1 = T2.getPredicate();</span>
<span class="fc" id="L481">        Term P2 = T1.getPredicate();</span>

        final Map&lt;Term, Term&gt;
<span class="fc" id="L484">            res1 = new LinkedHashMap&lt;&gt;(),</span>
<span class="fc" id="L485">            res2 = new LinkedHashMap&lt;&gt;(),</span>
<span class="fc" id="L486">            res3 = new LinkedHashMap&lt;&gt;(),</span>
<span class="fc" id="L487">            res4 = new LinkedHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (figure == 21) {</span>
<span class="fc" id="L490">            Variables.findSubstitute(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT, P1, S2, res1, res2);</span>
        }
<span class="fc bfc" id="L492" title="All 2 branches covered.">        else if (figure == 12) {</span>
<span class="fc" id="L493">            Variables.findSubstitute(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT, S1, P2, res1, res2);</span>
        }
<span class="fc bfc" id="L495" title="All 2 branches covered.">        else if (figure == 11) {</span>
<span class="fc" id="L496">            Variables.findSubstitute(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT, S1, S2, res1, res2);</span>
        }
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        else if (figure == 22) {</span>
<span class="fc" id="L499">            Variables.findSubstitute(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT, P1, P2, res1, res2);</span>
        }

        // this part is independent, the rule works if it unifies
<span class="fc" id="L503">        T1 = (Statement) T1.applySubstitute(res2);</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if(T1==null) {</span>
<span class="fc" id="L505">            return;</span>
        }
<span class="fc" id="L507">        T2 = (Statement) T2.applySubstitute(res1);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">        if(T2==null) {</span>
<span class="fc" id="L509">            return;</span>
        }


<span class="fc bfc" id="L513" title="All 2 branches covered.">        if (figure == 21) {</span>
            // update the variables because T1 and T2 may have changed
<span class="fc" id="L515">            S1 = T2.getSubject();</span>
<span class="fc" id="L516">            P2 = T1.getPredicate();</span>

<span class="fc" id="L518">            eliminateVariableOfConditionAbductiveTryCrossUnification(sentence, belief, nal, S1, P2, res3, res4);</span>
        }
<span class="fc bfc" id="L520" title="All 2 branches covered.">        else if (figure == 12) {</span>
            // update the variables because T1 and T2 may have changed
<span class="fc" id="L522">            S2 = T1.getSubject();</span>
<span class="fc" id="L523">            P1 = T2.getPredicate();</span>

<span class="fc" id="L525">            eliminateVariableOfConditionAbductiveTryCrossUnification(sentence, belief, nal, S2, P1, res3, res4);</span>
        }
<span class="fc bfc" id="L527" title="All 2 branches covered.">        else if (figure == 11) {</span>
            // update the variables because T1 and T2 may have changed
<span class="fc" id="L529">            P1 = T2.getPredicate();</span>
<span class="fc" id="L530">            P2 = T1.getPredicate();</span>

<span class="fc" id="L532">            eliminateVariableOfConditionAbductiveTryCrossUnification(sentence, belief, nal, P1, P2, res3, res4);</span>
        }
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        else if (figure == 22) {</span>
            // update the variables because T1 and T2 may have changed
<span class="fc" id="L536">            S1 = T2.getSubject();</span>
<span class="fc" id="L537">            S2 = T1.getSubject();</span>

<span class="fc bfc" id="L539" title="All 2 branches covered.">            if (S1 instanceof Conjunction) {</span>
                //try to unify S2 with a component
<span class="fc bfc" id="L541" title="All 2 branches covered.">                for (final Term s1 : ((CompoundTerm) S1).term) {</span>
<span class="fc" id="L542">                    res3.clear();</span>
<span class="fc" id="L543">                    res4.clear(); //here the dependent part matters, see example of Issue40</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">                    if (Variables.findSubstitute(nal.memory.randomNumber, Symbols.VAR_DEPENDENT, s1, S2, res3, res4)) {</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">                        for (Term s2 : ((CompoundTerm) S1).term) {</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">                            if (!(s2 instanceof CompoundTerm)) {</span>
<span class="fc" id="L547">                                continue;</span>
                            }
<span class="fc" id="L549">                            s2 = ((CompoundTerm) s2).applySubstitute(res3);</span>
<span class="fc bfc" id="L550" title="All 4 branches covered.">                            if(s2==null || s2.hasVarIndep()) {</span>
<span class="fc" id="L551">                                continue;</span>
                            }
<span class="pc bpc" id="L553" title="2 of 8 branches missed.">                            if (s2!=null &amp;&amp; !s2.equals(s1) &amp;&amp; (sentence.truth != null) &amp;&amp; (belief.truth != null)) {</span>
<span class="fc" id="L554">                                final TruthValue truth = abduction(sentence.truth, belief.truth, nal.narParameters);</span>
<span class="fc" id="L555">                                final BudgetValue budget = BudgetFunctions.compoundForward(truth, s2, nal);</span>
<span class="fc" id="L556">                                nal.doublePremiseTask(s2, truth, budget, false, false);</span>
                            }
                        }
                    }
                }
            }
<span class="fc bfc" id="L562" title="All 2 branches covered.">            if (S2 instanceof Conjunction) {</span>
                //try to unify S1 with a component
<span class="fc bfc" id="L564" title="All 2 branches covered.">                for (final Term s1 : ((CompoundTerm) S2).term) {</span>
<span class="fc" id="L565">                    res3.clear();</span>
<span class="fc" id="L566">                    res4.clear(); //here the dependent part matters, see example of Issue40</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">                    if (Variables.findSubstitute(nal.memory.randomNumber, Symbols.VAR_DEPENDENT, s1, S1, res3, res4)) {</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">                        for (Term s2 : ((CompoundTerm) S2).term) {</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">                            if (!(s2 instanceof CompoundTerm)) {</span>
<span class="fc" id="L570">                                continue;</span>
                            }

<span class="fc" id="L573">                            s2 = ((CompoundTerm) s2).applySubstitute(res3);</span>
<span class="fc bfc" id="L574" title="All 4 branches covered.">                            if(s2==null || s2.hasVarIndep()) {</span>
<span class="fc" id="L575">                                continue;</span>
                            }
<span class="pc bpc" id="L577" title="2 of 8 branches missed.">                            if (s2!=null &amp;&amp; !s2.equals(s1) &amp;&amp; (sentence.truth != null) &amp;&amp; (belief.truth != null)) {</span>
<span class="fc" id="L578">                                final TruthValue truth = abduction(sentence.truth, belief.truth, nal.narParameters);</span>
<span class="fc" id="L579">                                final BudgetValue budget = BudgetFunctions.compoundForward(truth, s2, nal);</span>
<span class="fc" id="L580">                                nal.doublePremiseTask(s2, truth, budget, false, false);</span>
                            }
                        }
                    }
                }
            }
        }
<span class="fc" id="L587">    }</span>

    private static void eliminateVariableOfConditionAbductiveTryCrossUnification(Sentence sentence, Sentence belief, DerivationContext nal, Term s1, Term p2, Map&lt;Term, Term&gt; res3, Map&lt;Term, Term&gt; res4) {
<span class="fc bfc" id="L590" title="All 2 branches covered.">        if (s1 instanceof Conjunction) {</span>
            //try to unify P2 with a component
<span class="fc" id="L592">            eliminateVariableOfConditionAbductiveTryUnification1(sentence, belief, nal, p2, (CompoundTerm) s1, res3, res4);</span>
        }
<span class="fc bfc" id="L594" title="All 2 branches covered.">        if (p2 instanceof Conjunction) {</span>
            //try to unify S1 with a component
<span class="fc" id="L596">            eliminateVariableOfConditionAbductiveTryUnification1(sentence, belief, nal, s1, (CompoundTerm) p2, res3, res4);</span>
        }
<span class="fc" id="L598">    }</span>

    private static void eliminateVariableOfConditionAbductiveTryUnification1(Sentence sentence, Sentence belief, DerivationContext nal, Term p1, CompoundTerm p2, Map&lt;Term, Term&gt; res3, Map&lt;Term, Term&gt; res4) {
<span class="fc bfc" id="L601" title="All 2 branches covered.">        for (final Term s1 : p2.term) {</span>
<span class="fc" id="L602">            res3.clear();</span>
<span class="fc" id="L603">            res4.clear(); //here the dependent part matters, see example of Issue40</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">            if (Variables.findSubstitute(nal.memory.randomNumber, Symbols.VAR_DEPENDENT, s1, p1, res3, res4)) {</span>
<span class="fc" id="L605">                eliminateVariableOfConditionAbductiveInner1(sentence, belief, nal, p2, res3, s1);</span>
            }
        }
<span class="fc" id="L608">    }</span>

    private static void eliminateVariableOfConditionAbductiveInner1(Sentence sentence, Sentence belief, DerivationContext nal, CompoundTerm s1, Map&lt;Term, Term&gt; res3, Term s12) {
<span class="fc bfc" id="L611" title="All 2 branches covered.">        for (Term s2 : s1.term) {</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">            if (!(s2 instanceof CompoundTerm)) {</span>
<span class="fc" id="L613">                continue;</span>
            }
<span class="fc" id="L615">            s2 = ((CompoundTerm) s2).applySubstitute(res3);</span>
<span class="fc bfc" id="L616" title="All 4 branches covered.">            if(s2==null || s2.hasVarIndep()) {</span>
<span class="fc" id="L617">                continue;</span>
            }
<span class="pc bpc" id="L619" title="1 of 6 branches missed.">            if (!s2.equals(s12) &amp;&amp; (sentence.truth != null) &amp;&amp; (belief.truth != null)) {</span>
<span class="fc" id="L620">                final TruthValue truth = abduction(sentence.truth, belief.truth, nal.narParameters);</span>
<span class="fc" id="L621">                final BudgetValue budget = BudgetFunctions.compoundForward(truth, s2, nal);</span>
<span class="fc" id="L622">                nal.doublePremiseTask(s2, truth, budget, false, false);</span>
            }
        }
<span class="fc" id="L625">    }</span>

    static void IntroVarSameSubjectOrPredicate(final Sentence originalMainSentence, final Sentence subSentence, final Term component, final Term content, final int index, final DerivationContext nal) {
<span class="fc" id="L628">        final Term T1 = originalMainSentence.term;</span>
<span class="pc bpc" id="L629" title="2 of 4 branches missed.">        if (!(T1 instanceof CompoundTerm) || !(content instanceof CompoundTerm)) {</span>
<span class="nc" id="L630">            return;</span>
        }
<span class="fc" id="L632">        CompoundTerm T = (CompoundTerm) T1;</span>
<span class="fc" id="L633">        CompoundTerm T2 = (CompoundTerm) content;</span>
        
<span class="pc bpc" id="L635" title="4 of 8 branches missed.">        if ((component instanceof Inheritance &amp;&amp; content instanceof Inheritance)</span>
                || (component instanceof Similarity &amp;&amp; content instanceof Similarity)) {
            //CompoundTerm result = T;
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">            if (component.equals(content)) {</span>
<span class="nc" id="L639">                return; //wouldnt make sense to create a conjunction here, would contain a statement twice</span>
            }

<span class="pc bpc" id="L642" title="1 of 4 branches missed.">            if (((Statement) component).getPredicate().equals(((Statement) content).getPredicate()) &amp;&amp; !(((Statement) component).getPredicate() instanceof Variable)) {</span>

<span class="fc" id="L644">                CompoundTerm zw = (CompoundTerm) T.term[index];</span>
<span class="fc" id="L645">                final Conjunction res = (Conjunction) Conjunction.make(zw, T2);</span>
<span class="fc" id="L646">                T = (CompoundTerm) T.setComponent(index, res, nal.mem());</span>
<span class="pc bpc" id="L647" title="1 of 4 branches missed.">            } else if (((Statement) component).getSubject().equals(((Statement) content).getSubject()) &amp;&amp; !(((Statement) component).getSubject() instanceof Variable)) {</span>

<span class="fc" id="L649">                CompoundTerm zw = (CompoundTerm) T.term[index];</span>
<span class="fc" id="L650">                final Conjunction res = (Conjunction) Conjunction.make(zw, T2);</span>
<span class="fc" id="L651">                T = (CompoundTerm) T.setComponent(index, res, nal.mem());</span>
            }
            
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">            if(T == null) {</span>
<span class="nc" id="L655">                return;</span>
            }
<span class="fc" id="L657">            final TruthValue truth = induction(originalMainSentence.truth, subSentence.truth, nal.narParameters);</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">            for(boolean subjectIntro : new boolean[]{true, false}) {</span>
<span class="fc" id="L659">                Set&lt;Pair&lt;Term,Float&gt;&gt; conts = introduceVariables(nal, T, subjectIntro);</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">                for(Pair&lt;Term,Float&gt; content_penalty : conts) {</span>
<span class="fc" id="L661">                    final BudgetValue budget = BudgetFunctions.compoundForward(truth, content_penalty.getLeft(), nal);</span>
<span class="fc" id="L662">                    final TruthValue truthVal = truth.clone();</span>
<span class="fc" id="L663">                    truthVal.mulConfidence(content_penalty.getRight());</span>
<span class="fc" id="L664">                    nal.doublePremiseTask(content_penalty.getLeft(), truthVal, budget.clone(), false, false);</span>
<span class="fc" id="L665">                }</span>
            }
        }
<span class="fc" id="L668">    }</span>
    
    
    /**
     * The power set, from João Silva, https://stackoverflow.com/questions/1670862/obtaining-a-powerset-of-a-set-in-java
     * 
     * @param &lt;T&gt;
     * @param originalSet
     * @return 
     */
    public static &lt;T&gt; Set&lt;Set&lt;T&gt;&gt; powerSet(Set&lt;T&gt; originalSet) {
<span class="fc" id="L679">        Set&lt;Set&lt;T&gt;&gt; sets = new LinkedHashSet&lt;Set&lt;T&gt;&gt;();</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">        if (originalSet.isEmpty()) {</span>
<span class="fc" id="L681">            sets.add(new LinkedHashSet&lt;T&gt;());</span>
<span class="fc" id="L682">            return sets;</span>
        }
<span class="fc" id="L684">        List&lt;T&gt; list = new ArrayList&lt;T&gt;(originalSet);</span>
<span class="fc" id="L685">        T head = list.get(0);</span>
<span class="fc" id="L686">        Set&lt;T&gt; rest = new LinkedHashSet&lt;T&gt;(list.subList(1, list.size())); </span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">        for (Set&lt;T&gt; set : powerSet(rest)) {</span>
<span class="fc" id="L688">            Set&lt;T&gt; newSet = new LinkedHashSet&lt;T&gt;();</span>
<span class="fc" id="L689">            newSet.add(head);</span>
<span class="fc" id="L690">            newSet.addAll(set);</span>
<span class="fc" id="L691">            sets.add(newSet);</span>
<span class="fc" id="L692">            sets.add(set);</span>
<span class="fc" id="L693">        }       </span>
<span class="fc" id="L694">        return sets;</span>
    }
    
    /**
     * Introduction of variables that appear either within subjects or within predicates and more than once
     * 
     * @param nal The derivation context
     * @param implicationEquivalenceOrJunction
     * @param subject
     * @return The terms of the variable introduction variants plus the penalty from the amount of vars introduced
     */
    public static Set&lt;Pair&lt;Term,Float&gt;&gt; introduceVariables(DerivationContext nal, Term implicationEquivalenceOrJunction, boolean subject) {
<span class="fc" id="L706">        Set&lt;Pair&lt;Term, Float&gt;&gt; result = new LinkedHashSet&lt;&gt;();</span>
<span class="pc bpc" id="L707" title="2 of 8 branches missed.">        boolean validForIntroduction =  implicationEquivalenceOrJunction instanceof Conjunction ||</span>
                                        implicationEquivalenceOrJunction instanceof Disjunction ||
                                        implicationEquivalenceOrJunction instanceof Equivalence ||
                                        implicationEquivalenceOrJunction instanceof Implication;
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">        if(!validForIntroduction) {</span>
<span class="nc" id="L712">            return result;</span>
        }
<span class="fc" id="L714">        final Map&lt;Term,Term&gt; app = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L715">        Set&lt;Term&gt; candidates = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L716" title="All 4 branches covered.">        if(implicationEquivalenceOrJunction instanceof Implication || implicationEquivalenceOrJunction instanceof Equivalence) {</span>
<span class="fc" id="L717">            addVariableCandidates(candidates, ((Statement)implicationEquivalenceOrJunction).getSubject(),   subject);</span>
<span class="fc" id="L718">            addVariableCandidates(candidates, ((Statement)implicationEquivalenceOrJunction).getPredicate(), subject);</span>
        }
<span class="pc bpc" id="L720" title="1 of 4 branches missed.">        if(implicationEquivalenceOrJunction instanceof Conjunction || implicationEquivalenceOrJunction instanceof Disjunction) {</span>
<span class="fc" id="L721">            addVariableCandidates(candidates, implicationEquivalenceOrJunction, subject);</span>
        }
<span class="fc" id="L723">        Map&lt;Term,Integer&gt; termCounts = implicationEquivalenceOrJunction.countTermRecursively(null);</span>
<span class="fc" id="L724">        int k = 0;</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">        for(Term t : candidates) {</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">            if(termCounts.getOrDefault(t, 0) &gt; 1) {</span>
                //ok it appeared as subject or predicate but appears in the Conjunction more than once
                //=&gt; introduce a dependent variable for it!
<span class="fc" id="L729">                String varType = &quot;#&quot;;</span>
<span class="fc bfc" id="L730" title="All 4 branches covered.">                if(implicationEquivalenceOrJunction instanceof Implication || implicationEquivalenceOrJunction instanceof Equivalence) {</span>
<span class="fc" id="L731">                    Statement imp = (Statement) implicationEquivalenceOrJunction;</span>
<span class="fc bfc" id="L732" title="All 4 branches covered.">                    if(imp.getSubject().containsTermRecursively(t) &amp;&amp; imp.getPredicate().containsTermRecursively(t)) {</span>
<span class="fc" id="L733">                        varType = &quot;$&quot;;</span>
                    }
                }
<span class="fc" id="L736">                Variable introVar = new Variable(varType + &quot;ind&quot; + k);</span>
<span class="fc" id="L737">                app.put(t, introVar);</span>
<span class="fc" id="L738">                k++;</span>
            }
<span class="fc" id="L740">        }</span>
        
<span class="fc" id="L742">        List&lt;Term&gt; shuffledVariables = new ArrayList&lt;Term&gt;();</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">        for(Term t : app.keySet()) {</span>
<span class="fc" id="L744">            shuffledVariables.add(t);</span>
<span class="fc" id="L745">        }</span>
<span class="fc" id="L746">        Collections.shuffle(shuffledVariables, nal.memory.randomNumber);</span>
<span class="fc" id="L747">        Set&lt;Term&gt; selected = new LinkedHashSet&lt;Term&gt;();</span>
<span class="fc" id="L748">        int i = 1;</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">        for(Term t : shuffledVariables) {</span>
<span class="fc" id="L750">            selected.add(t);</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">            if(Math.pow(2.0, i) &gt; nal.narParameters.VARIABLE_INTRODUCTION_COMBINATIONS_MAX) {</span>
<span class="fc" id="L752">                break;</span>
            }
<span class="fc" id="L754">            i++;</span>
<span class="fc" id="L755">        }</span>
<span class="fc" id="L756">        Set&lt;Set&lt;Term&gt;&gt; powerset = powerSet(selected);</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">        for(Set&lt;Term&gt; combo : powerset) {</span>
<span class="fc" id="L758">            Map&lt;Term,Term&gt; mapping = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">            for(Term vIntro : combo) {</span>
<span class="fc" id="L760">                mapping.put(vIntro, app.get(vIntro));</span>
<span class="fc" id="L761">            }</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">            if(mapping.size() &gt; 0) {</span>
<span class="fc" id="L763">                Float generalizationPenalty = (float) Math.pow(nal.narParameters.VARIABLE_INTRODUCTION_CONFIDENCE_MUL, mapping.size()-1);</span>
<span class="fc" id="L764">                result.add(new ImmutablePair&lt;&gt;(((CompoundTerm)implicationEquivalenceOrJunction).applySubstitute(mapping),generalizationPenalty));</span>
            }
<span class="fc" id="L766">        }</span>
<span class="fc" id="L767">        return result;</span>
    }

    /**
     * Add the variable candidates that appear as subjects and predicates
     * 
     * @param candidates manipulated set of candidates
     * @param side
     * @param subject
     */
    public static void addVariableCandidates(Set&lt;Term&gt; candidates, Term side, boolean subject) {
<span class="pc bpc" id="L778" title="1 of 6 branches missed.">        boolean junction = (side instanceof Conjunction || side instanceof Disjunction || side instanceof Negation);</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">        int n = junction ? ((CompoundTerm) side).size() : 1;</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">        for(int i=0; i&lt;n; i++) {</span>
            // we found an Inheritance
<span class="fc" id="L782">            Term t = null;</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">            if(i&lt;n) {</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">                if(junction) {</span>
<span class="fc" id="L785">                    t = ((CompoundTerm) side).term[i];</span>
                } else {
<span class="fc" id="L787">                    t = side;</span>
                }
            }
<span class="pc bpc" id="L790" title="1 of 6 branches missed.">            if(t instanceof Conjunction || t instanceof Disjunction || t instanceof Negation) { //component itself is a conjunction/disjunction</span>
<span class="fc" id="L791">                addVariableCandidates(candidates, t, subject);</span>
            }
<span class="fc bfc" id="L793" title="All 2 branches covered.">            if(t instanceof Inheritance) {</span>
<span class="fc" id="L794">                Inheritance inh = (Inheritance) t;</span>
<span class="fc" id="L795">                Term subjT = inh.getSubject();</span>
<span class="fc" id="L796">                Term predT = inh.getPredicate();</span>
<span class="fc bfc" id="L797" title="All 4 branches covered.">                boolean addSubject = subject || subjT instanceof ImageInt; //also allow for images due to equivalence transform</span>
<span class="fc" id="L798">                Set&lt;Term&gt; removals = new LinkedHashSet&lt;Term&gt;();</span>
<span class="fc bfc" id="L799" title="All 4 branches covered.">                if(addSubject &amp;&amp; !subjT.hasVar()) {</span>
<span class="fc" id="L800">                    Set&lt;Term&gt; ret = CompoundTerm.addComponentsRecursively(subjT, null);</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">                    for(Term ct : ret) {</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">                        if(ct instanceof Image) {</span>
<span class="fc" id="L803">                            removals.add(((Image) ct).term[((Image) ct).relationIndex]);</span>
                        }
<span class="fc" id="L805">                        candidates.add(ct);</span>
<span class="fc" id="L806">                    }</span>
                }
<span class="fc bfc" id="L808" title="All 4 branches covered.">                boolean addPredicate = !subject || predT instanceof ImageExt; //also allow for images due to equivalence transform</span>
<span class="fc bfc" id="L809" title="All 4 branches covered.">                if(addPredicate &amp;&amp; !predT.hasVar()) {</span>
<span class="fc" id="L810">                    Set&lt;Term&gt; ret = CompoundTerm.addComponentsRecursively(predT, null);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">                    for(Term ct : ret) {</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">                        if(ct instanceof Image) {</span>
<span class="fc" id="L813">                            removals.add(((Image) ct).term[((Image) ct).relationIndex]);</span>
                        }
<span class="fc" id="L815">                        candidates.add(ct);</span>
<span class="fc" id="L816">                    }</span>
                }
<span class="fc bfc" id="L818" title="All 2 branches covered.">                for(Term remove : removals) { //but do not introduce variables for image relation, only if they appear as product</span>
<span class="fc" id="L819">                    candidates.remove(remove);</span>
<span class="fc" id="L820">                }</span>
            }
        }
<span class="fc" id="L823">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>