<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RuleTables.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.inference</a> &gt; <span class="el_source">RuleTables.java</span></div><h1>RuleTables.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.inference;

import org.opennars.control.DerivationContext;
import org.opennars.entity.*;
import org.opennars.io.Symbols;
import org.opennars.io.events.Events;
import org.opennars.language.*;
import org.opennars.operator.Operation;
import org.opennars.storage.Memory;

import static org.opennars.io.Symbols.*;
import static org.opennars.language.Statement.retOppositeSide;
import static org.opennars.language.Terms.equalSubTermsInRespectToImageAndProduct;

/**
 * Table of inference rules, indexed by the TermLinks for the task and the
 * belief. Used in indirective processing of a task, to dispatch inference cases
 * to the relevant inference rules.
 *
 * @author Pei Wang
 * @author Patrick Hammer
 */
<span class="nc" id="L46">public class RuleTables {</span>
    
    
    /**
     * Entry point of the inference engine
     *
     * @param tLink The selected TaskLink, which will provide a task
     * @param bLink The selected TermLink, which may provide a belief
     */
    public static void reason(final TaskLink tLink, final TermLink bLink, final DerivationContext nal) {

        // REFACTOR&lt; the body should be split into another static function &gt;

<span class="fc" id="L59">        final Memory memory = nal.mem();</span>
        
<span class="fc" id="L61">        final Task task = nal.getCurrentTask();</span>
<span class="fc" id="L62">        final Sentence taskSentence = task.sentence;</span>
        
<span class="fc" id="L64">        final Term taskTerm = taskSentence.term;         // cloning for substitution</span>
<span class="fc" id="L65">        Term beliefTerm = bLink.target;       // cloning for substitution</span>
        
<span class="fc" id="L67">        final Concept beliefConcept = memory.concept(beliefTerm);</span>
        
<span class="fc" id="L69">        Sentence belief = null;</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if(beliefConcept != null) {</span>
<span class="fc" id="L71">            synchronized(beliefConcept) { //we only need the target concept to select a belief</span>
<span class="fc" id="L72">                belief = beliefConcept.getBelief(nal, task);</span>
<span class="fc" id="L73">            }</span>
        }
        
<span class="fc" id="L76">        nal.setCurrentBelief( belief );</span>
        
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if (belief != null) {   </span>
<span class="fc" id="L79">            beliefTerm = belief.term; //because interval handling that differs on conceptual level</span>
            
          /*Sentence belief_event = beliefConcept.getBeliefForTemporalInference(task);
            if(belief_event != null) {
                boolean found_overlap = false;
                if(Stamp.baseOverlap(task.sentence.stamp.evidentialBase, belief_event.stamp.evidentialBase)) {
                    found_overlap = true;
                }
                if(!found_overlap) { //temporal rules are inductive so no chance to succeed if there is an overlap
                                     //and since the temporal rule is relatively expensive the check here was good.
                    Sentence inference_belief = belief;
                    nal.setCurrentBelief(belief_event);
                    nal.setTheNewStamp(task.sentence.stamp, belief_event.stamp, nal.memory.time());
                    TemporalRules.temporalInduction(task.sentence, belief_event, nal, true);
                    nal.setCurrentBelief(inference_belief);
                    nal.setTheNewStamp(task.sentence.stamp, belief.stamp, nal.memory.time());
                }
            }*/
            
            //too restrictive, its checked for non-deductive inference rules in derivedTask (also for single prem)
<span class="fc" id="L99">            nal.evidentalOverlap = Stamp.baseOverlap(task.sentence.stamp, belief.stamp);</span>
<span class="pc bpc" id="L100" title="1 of 6 branches missed.">            if(nal.evidentalOverlap &amp;&amp; (!task.sentence.isEternal() || !belief.isEternal())) {</span>
<span class="fc" id="L101">                return; //only allow for eternal reasoning for now to prevent derived event floods</span>
            }
            
<span class="fc" id="L104">            nal.emit(Events.BeliefReason.class, belief, beliefTerm, taskTerm, nal);</span>
            
<span class="fc bfc" id="L106" title="All 2 branches covered.">            if (LocalRules.match(task, belief, beliefConcept, nal)) { //new tasks resulted from the match, so return</span>
<span class="fc" id="L107">                return;</span>
            }
        }
        
        //current belief and task may have changed, so set again:
<span class="fc" id="L112">        nal.setCurrentBelief(belief);</span>
<span class="fc" id="L113">        nal.setCurrentTask(task);</span>

        //put here since LocalRules match should be possible even if the belief is foreign
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if(equalSubTermsInRespectToImageAndProduct(taskTerm,beliefTerm))</span>
<span class="fc" id="L117">            return;</span>

        /*if ((memory.getNewTaskCount() &gt; 0) &amp;&amp; taskSentence.isJudgment()) {
            return;
        }*/

<span class="fc" id="L123">        applyRuleTable(tLink, bLink, nal, task, taskSentence, taskTerm, beliefTerm, belief);</span>
<span class="fc" id="L124">    }</span>

    private static void applyRuleTable(TaskLink tLink, TermLink bLink, DerivationContext nal, Task task, Sentence taskSentence, Term taskTerm, Term beliefTerm, Sentence belief) {
<span class="fc" id="L127">        final short tIndex = tLink.getIndex(0);</span>
<span class="fc" id="L128">        short bIndex = bLink.getIndex(0);</span>
<span class="pc bpc" id="L129" title="1 of 5 branches missed.">        switch (tLink.type) {          // dispatch first by TaskLink type</span>
            case TermLink.SELF:
<span class="pc bpc" id="L131" title="1 of 7 branches missed.">                switch (bLink.type) {</span>
                    case TermLink.COMPONENT:
<span class="fc" id="L133">                        compoundAndSelf((CompoundTerm) taskTerm, beliefTerm, true, bIndex,  nal);</span>
<span class="fc" id="L134">                        break;</span>
                    case TermLink.COMPOUND:
<span class="fc" id="L136">                        compoundAndSelf((CompoundTerm) beliefTerm, taskTerm, false, bIndex, nal);</span>
<span class="fc" id="L137">                        break;</span>
                    case TermLink.COMPONENT_STATEMENT:
<span class="fc bfc" id="L139" title="All 2 branches covered.">                        if (belief != null) {</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">                            if (taskTerm instanceof Statement) {</span>
<span class="fc" id="L141">                                SyllogisticRules.detachment(taskSentence, belief, bIndex, nal);</span>
                            }
                        } //else {
<span class="fc" id="L144">                        goalFromQuestion(task, taskTerm, nal);</span>
                        //}
<span class="fc" id="L146">                        break;</span>
                    case TermLink.COMPOUND_STATEMENT:
<span class="fc bfc" id="L148" title="All 2 branches covered.">                        if (belief != null) {</span>
<span class="fc" id="L149">                            SyllogisticRules.detachment(belief, taskSentence, bIndex, nal);</span>
                        }
                        break;
                    case TermLink.COMPONENT_CONDITION:
<span class="fc bfc" id="L153" title="All 4 branches covered.">                        if ((belief != null) &amp;&amp; (taskTerm instanceof Implication)) {</span>
<span class="fc" id="L154">                            bIndex = bLink.getIndex(1);</span>
<span class="fc" id="L155">                            SyllogisticRules.conditionalDedInd(task.sentence,(Implication) taskTerm, bIndex, beliefTerm, tIndex, nal);</span>
                        }
                        break;
                    case TermLink.COMPOUND_CONDITION:
<span class="fc bfc" id="L159" title="All 4 branches covered.">                        if ((belief != null) &amp;&amp; (beliefTerm instanceof Implication)) {</span>
<span class="fc" id="L160">                            bIndex = bLink.getIndex(1);</span>
<span class="fc" id="L161">                            SyllogisticRules.conditionalDedInd(belief,(Implication) beliefTerm, bIndex, taskTerm, tIndex, nal);</span>
                        }
                        break;
                }
<span class="fc" id="L165">                break;</span>
            case TermLink.COMPOUND:
<span class="fc bfc" id="L167" title="All 4 branches covered.">                switch (bLink.type) {</span>
                    case TermLink.COMPOUND:
<span class="pc bpc" id="L169" title="2 of 4 branches missed.">                        if(taskTerm instanceof CompoundTerm &amp;&amp; beliefTerm instanceof CompoundTerm) {</span>
<span class="fc" id="L170">                            compoundAndCompound((CompoundTerm) taskTerm, (CompoundTerm) beliefTerm, tIndex, bIndex, nal);</span>
                        }
                        break;
                    case TermLink.COMPOUND_STATEMENT:
<span class="fc" id="L174">                        compoundAndStatement((CompoundTerm) taskTerm, tIndex, (Statement) beliefTerm, bIndex, beliefTerm, nal);</span>
<span class="fc" id="L175">                        break;</span>
                    case TermLink.COMPOUND_CONDITION:
<span class="fc bfc" id="L177" title="All 2 branches covered.">                        if (belief != null) {</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                            if (beliefTerm instanceof Implication) {</span>
<span class="fc" id="L179">                                final Term[] u = new Term[] { beliefTerm, taskTerm };</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                                if (Variables.unify(nal.memory.randomNumber, VAR_INDEPENDENT, ((Statement) beliefTerm).getSubject(), taskTerm, u, true)) { //only secure place that</span>
<span class="fc" id="L181">                                    final Sentence newBelief = belief.clone(u[0]);                                                //allows partial match</span>
<span class="fc" id="L182">                                    final Sentence newTaskSentence = taskSentence.clone(u[1]);</span>
<span class="fc" id="L183">                                    detachmentWithVar(newBelief, newTaskSentence, bIndex, false, nal);</span>
<span class="fc" id="L184">                                } else {</span>
<span class="fc" id="L185">                                    SyllogisticRules.conditionalDedInd(belief, (Implication) beliefTerm, bIndex, taskTerm, -1, nal);</span>
                                }

<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                            } else if (beliefTerm instanceof Equivalence) {</span>
<span class="fc" id="L189">                                SyllogisticRules.conditionalAna((Equivalence) beliefTerm, bIndex, taskTerm, -1, nal);</span>
                            }
                        }
                        break;
                }
<span class="fc" id="L194">                break;</span>
            case TermLink.COMPOUND_STATEMENT:
<span class="fc bfc" id="L196" title="All 5 branches covered.">                switch (bLink.type) {</span>
                    case TermLink.COMPONENT:
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">                        if (taskTerm instanceof Statement) {</span>
<span class="fc" id="L199">                            goalFromWantBelief(task, tIndex, bIndex, taskTerm, nal, beliefTerm);</span>
<span class="fc" id="L200">                            componentAndStatement((CompoundTerm) nal.getCurrentTerm(), bIndex, (Statement) taskTerm, tIndex, nal);</span>
                        }
                        break;
                    case TermLink.COMPOUND:
<span class="pc bpc" id="L204" title="2 of 4 branches missed.">                        if (taskTerm instanceof Statement &amp;&amp; beliefTerm instanceof CompoundTerm) {</span>
<span class="fc" id="L205">                            compoundAndStatement((CompoundTerm) beliefTerm, bIndex, (Statement) taskTerm, tIndex, beliefTerm, nal);</span>
                        }
                        break;
                    case TermLink.COMPOUND_STATEMENT:
<span class="fc bfc" id="L209" title="All 2 branches covered.">                        if (belief != null) {</span>
<span class="fc" id="L210">                            syllogisms(tLink, bLink, taskTerm, beliefTerm, nal);</span>
                        }
                        break;
                    case TermLink.COMPOUND_CONDITION:
<span class="fc bfc" id="L214" title="All 2 branches covered.">                        if (belief != null) {</span>
<span class="fc" id="L215">                            bIndex = bLink.getIndex(1);</span>
<span class="pc bpc" id="L216" title="1 of 4 branches missed.">                            if ((taskTerm instanceof Statement) &amp;&amp; (beliefTerm instanceof Implication)) {</span>
<span class="fc" id="L217">                                conditionalDedIndWithVar(belief, (Implication) beliefTerm, bIndex, (Statement) taskTerm, tIndex, nal);</span>
                            }
                        }
                        break;
                }
<span class="fc" id="L222">                break;</span>
            case TermLink.COMPOUND_CONDITION:
<span class="fc bfc" id="L224" title="All 3 branches covered.">                switch (bLink.type) {</span>
                      case TermLink.COMPOUND:
<span class="fc bfc" id="L226" title="All 2 branches covered.">                        if (belief != null) {</span>
<span class="fc" id="L227">                            detachmentWithVar(taskSentence, belief, tIndex, nal);</span>
                        }
                        break;

                    case TermLink.COMPOUND_STATEMENT:
<span class="fc bfc" id="L232" title="All 2 branches covered.">                        if (belief != null) {</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                            if (taskTerm instanceof Implication) // TODO maybe put instanceof test within conditionalDedIndWithVar()</span>
                            {
<span class="fc" id="L235">                                final Term subj = ((Statement) taskTerm).getSubject();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">                                if (subj instanceof Negation) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">                                    if (taskSentence.isJudgment()) {</span>
<span class="fc" id="L238">                                        componentAndStatement((CompoundTerm) subj, bIndex, (Statement) taskTerm, tIndex, nal);</span>
                                    } else {
<span class="fc" id="L240">                                        componentAndStatement((CompoundTerm) subj, tIndex, (Statement) beliefTerm, bIndex, nal);</span>
                                    }
                                } else {
<span class="fc" id="L243">                                    conditionalDedIndWithVar(task.sentence, (Implication) taskTerm, tIndex, (Statement) beliefTerm, bIndex, nal);</span>
                                }
                            }
                            break;
                        }
                        break;
                }
        }
<span class="fc" id="L251">    }</span>

    public static void goalFromWantBelief(final Task task, final short tIndex, final short bIndex, final Term taskTerm, final DerivationContext nal, final Term beliefTerm) {
<span class="fc bfc" id="L254" title="All 8 branches covered.">        if(task.sentence.isJudgment() &amp;&amp; tIndex == 0 &amp;&amp; bIndex == 1 &amp;&amp; taskTerm instanceof Operation) {</span>
<span class="fc" id="L255">            final Operation op = (Operation) taskTerm;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            if(op.getPredicate() == nal.memory.getOperator(&quot;^want&quot;)) {</span>
<span class="fc" id="L257">                final TruthValue newTruth = TruthFunctions.deduction(task.sentence.truth, nal.narParameters.reliance, nal.narParameters);</span>
<span class="fc" id="L258">                nal.singlePremiseTask(((Operation)taskTerm).getArguments().term[1], Symbols.GOAL_MARK, newTruth, BudgetFunctions.forward(newTruth, nal));</span>
            }
        }
<span class="fc" id="L261">    }</span>

    private static void goalFromQuestion(final Task task, final Term taskTerm, final DerivationContext nal) {
<span class="fc bfc" id="L264" title="All 6 branches covered.">        if(task.sentence.punctuation==Symbols.QUESTION_MARK &amp;&amp; (taskTerm instanceof Implication || taskTerm instanceof Equivalence)) { //&lt;a =/&gt; b&gt;? |- a!</span>
<span class="fc" id="L265">            Term goalterm=null;</span>
<span class="fc" id="L266">            Term goalterm2=null;</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if(taskTerm instanceof Implication) {</span>
<span class="fc" id="L268">                final Implication imp=(Implication)taskTerm;</span>
<span class="pc bpc" id="L269" title="1 of 4 branches missed.">                if(imp.getTemporalOrder()!=TemporalRules.ORDER_BACKWARD || imp.getTemporalOrder()==TemporalRules.ORDER_CONCURRENT) {</span>
<span class="pc bpc" id="L270" title="3 of 4 branches missed.">                    if(!nal.narParameters.CURIOSITY_FOR_OPERATOR_ONLY || imp.getSubject() instanceof Operation) {</span>
<span class="fc" id="L271">                        goalterm=imp.getSubject();</span>
                    }
<span class="pc bpc" id="L273" title="4 of 8 branches missed.">                    if(goalterm instanceof Variable &amp;&amp; goalterm.hasVarQuery() &amp;&amp; (!nal.narParameters.CURIOSITY_FOR_OPERATOR_ONLY || imp.getPredicate() instanceof Operation)) {</span>
<span class="fc" id="L274">                        goalterm=imp.getPredicate(); //overwrite, it is a how question, in case of &lt;?how =/&gt; b&gt; it is b! which is desired</span>
                    }
                }
                else
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">                    if(imp.getTemporalOrder()==TemporalRules.ORDER_BACKWARD) {</span>
<span class="pc bpc" id="L279" title="3 of 4 branches missed.">                        if(!nal.narParameters.CURIOSITY_FOR_OPERATOR_ONLY || imp.getPredicate() instanceof Operation) {</span>
<span class="fc" id="L280">                            goalterm=imp.getPredicate();</span>
                        }
<span class="pc bpc" id="L282" title="4 of 8 branches missed.">                        if(goalterm instanceof Variable &amp;&amp; goalterm.hasVarQuery() &amp;&amp; (!nal.narParameters.CURIOSITY_FOR_OPERATOR_ONLY || imp.getSubject() instanceof Operation)) {</span>
<span class="fc" id="L283">                            goalterm=imp.getSubject(); //overwrite, it is a how question, in case of &lt;?how =/&gt; b&gt; it is b! which is desired</span>
                        }
                    }
<span class="fc" id="L286">            }</span>
            else
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">                if(taskTerm instanceof Equivalence) {</span>
<span class="fc" id="L289">                    final Equivalence qu=(Equivalence)taskTerm;</span>
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">                    if(qu.getTemporalOrder()==TemporalRules.ORDER_FORWARD || qu.getTemporalOrder()==TemporalRules.ORDER_CONCURRENT) {</span>
<span class="pc bpc" id="L291" title="3 of 4 branches missed.">                        if(!nal.narParameters.CURIOSITY_FOR_OPERATOR_ONLY || qu.getSubject() instanceof Operation) {</span>
<span class="fc" id="L292">                            goalterm=qu.getSubject();</span>
                        }
<span class="pc bpc" id="L294" title="3 of 4 branches missed.">                        if(!nal.narParameters.CURIOSITY_FOR_OPERATOR_ONLY || qu.getPredicate() instanceof Operation) {</span>
<span class="fc" id="L295">                            goalterm2=qu.getPredicate();</span>
                        }
                    }
                }
<span class="fc" id="L299">            final TruthValue truth=new TruthValue(1.0f,nal.narParameters.DEFAULT_GOAL_CONFIDENCE*nal.narParameters.CURIOSITY_DESIRE_CONFIDENCE_MUL, nal.narParameters);</span>
<span class="pc bpc" id="L300" title="1 of 6 branches missed.">            if(goalterm!=null &amp;&amp; !(goalterm instanceof Variable) &amp;&amp; goalterm instanceof CompoundTerm) {</span>
<span class="fc" id="L301">                goalterm = goalterm.cloneDeep();</span>
<span class="fc" id="L302">                CompoundTerm.transformIndependentVariableToDependent((CompoundTerm) goalterm);</span>
<span class="fc" id="L303">                ((CompoundTerm)goalterm).invalidateName();</span>
<span class="fc" id="L304">                final Sentence sent=new Sentence(</span>
                    goalterm,
                    Symbols.GOAL_MARK,
                    truth,
<span class="fc" id="L308">                    new Stamp(task.sentence.stamp,nal.time.time()));</span>

<span class="fc" id="L310">                nal.singlePremiseTask(sent, new BudgetValue(task.getPriority()*nal.narParameters.CURIOSITY_DESIRE_PRIORITY_MUL,</span>
<span class="fc" id="L311">                                                            task.getDurability()*nal.narParameters.CURIOSITY_DESIRE_DURABILITY_MUL,</span>
<span class="fc" id="L312">                                                            BudgetFunctions.truthToQuality(truth), nal.narParameters));</span>
            }
<span class="pc bpc" id="L314" title="2 of 8 branches missed.">            if(goalterm instanceof CompoundTerm &amp;&amp; goalterm2!=null &amp;&amp; !(goalterm2 instanceof Variable) &amp;&amp; goalterm2 instanceof CompoundTerm) {</span>
<span class="fc" id="L315">                goalterm2 = goalterm2.cloneDeep();</span>
<span class="fc" id="L316">                CompoundTerm.transformIndependentVariableToDependent((CompoundTerm) goalterm2);</span>
<span class="fc" id="L317">                ((CompoundTerm)goalterm2).invalidateName();</span>
<span class="fc" id="L318">                final Sentence sent=new Sentence(</span>
                    goalterm2,
                    Symbols.GOAL_MARK,
<span class="fc" id="L321">                    truth.clone(),</span>
<span class="fc" id="L322">                    new Stamp(task.sentence.stamp,nal.time.time()));</span>

<span class="fc" id="L324">                nal.singlePremiseTask(sent, new BudgetValue(task.getPriority()*nal.narParameters.CURIOSITY_DESIRE_PRIORITY_MUL,</span>
<span class="fc" id="L325">                                                            task.getDurability()*nal.narParameters.CURIOSITY_DESIRE_DURABILITY_MUL,</span>
<span class="fc" id="L326">                                                            BudgetFunctions.truthToQuality(truth), nal.narParameters));</span>
            }
        }
<span class="fc" id="L329">    }</span>

    /* ----- syllogistic inferences ----- */
    /**
     * Meta-table of syllogistic rules, indexed by the content classes of the
     * taskSentence and the belief
     *
     * @param tLink The link to task
     * @param bLink The link to belief
     * @param taskTerm The content of task
     * @param beliefTerm The content of belief
     * @param nal Reference to the memory
     */
    private static void syllogisms(final TaskLink tLink, final TermLink bLink, final Term taskTerm, final Term beliefTerm, final DerivationContext nal) {
<span class="fc" id="L343">        final Sentence taskSentence = nal.getCurrentTask().sentence;</span>
<span class="fc" id="L344">        final Sentence belief = nal.getCurrentBelief();</span>
        final int figure;
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (taskTerm instanceof Inheritance) {</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">            if (beliefTerm instanceof Inheritance) {</span>
<span class="fc" id="L348">                figure = indexToFigure(tLink, bLink);</span>
<span class="fc" id="L349">                asymmetricAsymmetric(taskSentence, belief, figure, nal);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            } else if (beliefTerm instanceof Similarity) {</span>
<span class="fc" id="L351">                figure = indexToFigure(tLink, bLink);</span>
<span class="fc" id="L352">                asymmetricSymmetric(taskSentence, belief, figure, nal);</span>
            } else {
<span class="fc" id="L354">                detachmentWithVar(belief, taskSentence, bLink.getIndex(0), nal);</span>
            }
<span class="fc bfc" id="L356" title="All 2 branches covered.">        } else if (taskTerm instanceof Similarity) {</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">            if (beliefTerm instanceof Inheritance) {</span>
<span class="fc" id="L358">                figure = indexToFigure(bLink, tLink);</span>
<span class="fc" id="L359">                asymmetricSymmetric(belief, taskSentence, figure, nal);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">            } else if (beliefTerm instanceof Similarity) {</span>
<span class="fc" id="L361">                figure = indexToFigure(bLink, tLink);</span>
<span class="fc" id="L362">                symmetricSymmetric(belief, taskSentence, figure, nal);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            } else if (beliefTerm instanceof Implication) {</span>
                //Bridge to higher order statements:
<span class="fc" id="L365">                figure = indexToFigure(tLink, bLink);</span>
<span class="fc" id="L366">                asymmetricSymmetric(belief, taskSentence, figure, nal);</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            } else if (beliefTerm instanceof Equivalence) {</span>
                //Bridge to higher order statements:
<span class="fc" id="L369">                figure = indexToFigure(tLink, bLink);</span>
<span class="fc" id="L370">                symmetricSymmetric(belief, taskSentence, figure, nal);</span>
            }
<span class="fc bfc" id="L372" title="All 2 branches covered.">        } else if (taskTerm instanceof Implication) {</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (beliefTerm instanceof Implication) {</span>
<span class="fc" id="L374">                figure = indexToFigure(tLink, bLink);</span>
<span class="fc" id="L375">                asymmetricAsymmetric(taskSentence, belief, figure, nal);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">            } else if (beliefTerm instanceof Equivalence) {</span>
<span class="fc" id="L377">                figure = indexToFigure(tLink, bLink);</span>
<span class="fc" id="L378">                asymmetricSymmetric(taskSentence, belief, figure, nal);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">            } else if (beliefTerm instanceof Inheritance) {</span>
<span class="fc" id="L380">                detachmentWithVar(taskSentence, belief, tLink.getIndex(0), nal);</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">            } else if (beliefTerm instanceof Similarity) {</span>
                //Bridge to higher order statements:
<span class="fc" id="L383">                figure = indexToFigure(tLink, bLink);</span>
<span class="fc" id="L384">                asymmetricSymmetric(taskSentence, belief, figure, nal);</span>
            }
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        } else if (taskTerm instanceof Equivalence) {</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">            if (beliefTerm instanceof Implication) {</span>
<span class="fc" id="L388">                figure = indexToFigure(bLink, tLink);</span>
<span class="fc" id="L389">                asymmetricSymmetric(belief, taskSentence, figure, nal);</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">            } else if (beliefTerm instanceof Equivalence) {</span>
<span class="fc" id="L391">                figure = indexToFigure(bLink, tLink);</span>
<span class="fc" id="L392">                symmetricSymmetric(belief, taskSentence, figure, nal);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">            } else if (beliefTerm instanceof Inheritance) {</span>
<span class="fc" id="L394">                detachmentWithVar(taskSentence, belief, tLink.getIndex(0), nal);</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">            } else if (beliefTerm instanceof Similarity) {</span>
                //Bridge to higher order statements:
<span class="fc" id="L397">                figure = indexToFigure(tLink, bLink);</span>
<span class="fc" id="L398">                symmetricSymmetric(belief, taskSentence, figure, nal);</span>
            }
        }
<span class="fc" id="L401">    }</span>

    /**
     * Decide the figure of syllogism according to the locations of the common
     * term in the premises
     *
     * @param link1 The link to the first premise
     * @param link2 The link to the second premise
     * @return The figure of the syllogism, one of the four: 11, 12, 21, or 22
     */
    private static final  int indexToFigure(final TLink link1, final TLink link2) {
<span class="fc" id="L412">        return (link1.getIndex(0) + 1) * 10 + (link2.getIndex(0) + 1);</span>
    }

    /**
     * Syllogistic rules whose both premises are on the same asymmetric relation
     *
     * @param taskSentence The taskSentence in the task
     * @param belief The judgment in the belief
     * @param figure The location of the shared term
     * @param nal Reference to the memory
     */
    private static void asymmetricAsymmetric(final Sentence taskSentence, final Sentence belief, final int figure, final DerivationContext nal) {
<span class="fc" id="L424">        Statement taskStatement = (Statement) taskSentence.term;</span>
<span class="fc" id="L425">        Statement beliefStatement = (Statement) belief.term;</span>
        

<span class="fc" id="L428">        final Term[] u = new Term[] { taskStatement, beliefStatement };</span>

<span class="fc" id="L430">        final Statement.EnumStatementSide figureLeft = retSideFromFigure(figure, EnumFigureSide.LEFT);</span>
<span class="fc" id="L431">        final Statement.EnumStatementSide figureRight = retSideFromFigure(figure, EnumFigureSide.RIGHT);</span>

<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (!Variables.unify(nal.memory.randomNumber, VAR_INDEPENDENT, taskStatement.retBySide(figureLeft), beliefStatement.retBySide(figureRight), u)) {</span>
<span class="fc" id="L434">            return;</span>
        }

<span class="fc" id="L437">        taskStatement = (Statement) u[0];</span>
<span class="fc" id="L438">        beliefStatement = (Statement) u[1];</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">        if (taskStatement.equals(beliefStatement)) {</span>
<span class="fc" id="L440">            return;</span>
        }

        boolean isDeduction;
        Term t1;
        Term t2;

<span class="pc bpc" id="L447" title="1 of 4 branches missed.">        switch (figure) {</span>
            case 11: // induction
            {
<span class="fc" id="L450">                final boolean sensational = SyllogisticRules.abdIndCom(beliefStatement.getPredicate(), taskStatement.getPredicate(), taskSentence, belief, figure, nal);</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                if (sensational) {</span>
<span class="fc" id="L452">                    return;</span>
                }
<span class="fc" id="L454">                CompositionalRules.composeCompound(taskStatement, beliefStatement, 0, nal);</span>
                //if(taskSentence.getOccurenceTime()==Stamp.ETERNAL &amp;&amp; belief.getOccurenceTime()==Stamp.ETERNAL)
<span class="fc" id="L456">                CompositionalRules.introVarOuter(taskStatement, beliefStatement, 0, nal);//introVarImage(taskContent, beliefContent, index, memory);</span>
<span class="fc" id="L457">                CompositionalRules.eliminateVariableOfConditionAbductive(figure, taskSentence, belief, nal);</span>
            }
<span class="fc" id="L459">            break;</span>
            case 22: // abduction
            {
<span class="fc bfc" id="L462" title="All 2 branches covered.">                if (!SyllogisticRules.conditionalAbd(taskStatement.getSubject(), beliefStatement.getSubject(), taskStatement, beliefStatement, nal)) {         // if conditional abduction, skip the following</span>
<span class="fc" id="L463">                    final boolean sensational = SyllogisticRules.abdIndCom(taskStatement.getSubject(), beliefStatement.getSubject(), taskSentence, belief, figure, nal);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">                    if(sensational) {</span>
<span class="fc" id="L465">                        return;</span>
                    }
<span class="fc" id="L467">                    CompositionalRules.composeCompound(taskStatement, beliefStatement, 1, nal);</span>
<span class="fc" id="L468">                    CompositionalRules.introVarOuter(taskStatement, beliefStatement, 1, nal);// introVarImage(taskContent, beliefContent, index, memory);</span>
                }

<span class="fc" id="L471">                CompositionalRules.eliminateVariableOfConditionAbductive(figure,taskSentence,belief,nal);</span>
            }
<span class="fc" id="L473">            break;</span>

            case 12: // deduction
            case 21: // exemplification

<span class="fc bfc" id="L478" title="All 2 branches covered.">            isDeduction = figure == 12;</span>

<span class="fc bfc" id="L480" title="All 2 branches covered.">            t1 = isDeduction ? beliefStatement.getSubject() : taskStatement.getSubject();</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">            t2 = isDeduction ? taskStatement.getPredicate() : beliefStatement.getPredicate();</span>

<span class="fc bfc" id="L483" title="All 2 branches covered.">            if (Variables.unify(nal.memory.randomNumber, VAR_QUERY, t1, t2, new Term[]{taskStatement, beliefStatement})) {</span>
<span class="fc" id="L484">                LocalRules.matchReverse(nal);</span>
            } else {
<span class="fc" id="L486">                SyllogisticRules.dedExe(t1, t2, taskSentence, belief, nal);</span>
            }

<span class="fc" id="L489">            break;</span>

            default:
        }
<span class="fc" id="L493">    }</span>

    /**
     * Syllogistic rules whose first premise is on an asymmetric relation, and
     * the second on a symmetric relation
     *
     * @param asym The asymmetric premise
     * @param sym The symmetric premise
     * @param figure The location of the shared term
     * @param nal Reference to the memory
     */
    private static void asymmetricSymmetric(final Sentence asym, final Sentence sym, final int figure, final DerivationContext nal) {
<span class="fc" id="L505">        Statement asymSt = (Statement) asym.term;</span>
<span class="fc" id="L506">        Statement symSt = (Statement) sym.term;</span>

<span class="fc" id="L508">        final Statement.EnumStatementSide figureLeft = retSideFromFigure(figure, EnumFigureSide.LEFT);</span>
<span class="fc" id="L509">        final Statement.EnumStatementSide figureRight = retSideFromFigure(figure, EnumFigureSide.RIGHT);</span>

<span class="fc" id="L511">        final Term[] u = new Term[] { asymSt, symSt };</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if (!Variables.unify(nal.memory.randomNumber, VAR_INDEPENDENT, asymSt.retBySide(figureLeft), symSt.retBySide(figureRight), u)) {</span>
<span class="fc" id="L513">            return;</span>
        }

<span class="fc" id="L516">        asymSt = (Statement) u[0];</span>
<span class="fc" id="L517">        symSt = (Statement) u[1];</span>
<span class="fc" id="L518">        final Term t1 = asymSt.retBySide(retOppositeSide(figureLeft));</span>
<span class="fc" id="L519">        final Term t2 = symSt.retBySide(retOppositeSide(figureRight));</span>

<span class="fc bfc" id="L521" title="All 2 branches covered.">        if (Variables.unify(nal.memory.randomNumber, VAR_QUERY, t1, t2, u)) {</span>
<span class="fc" id="L522">            LocalRules.matchAsymSym(asym, sym, figure, nal);</span>
        } else {
<span class="pc bpc" id="L524" title="1 of 3 branches missed.">            switch (figure) {</span>
                case 11:
                case 12:
<span class="fc" id="L527">                SyllogisticRules.analogy(t2, t1, asym, sym, figure, nal);</span>
<span class="fc" id="L528">                break;</span>

                case 21:
                case 22:
<span class="fc" id="L532">                SyllogisticRules.analogy(t1, t2, asym, sym, figure, nal);</span>
                break;
            }
        }
<span class="fc" id="L536">    }</span>

    /**
     * converts the side of a figure to a zero based index - which determines the side of the Statement
     *
     * a figure is a encoding for the sides
     * @param figure figure encoding as 11 or 12 or 21 or 22
     * @param sideOfFigure side
     * @return
     */
    private static Statement.EnumStatementSide retSideFromFigure(int figure, EnumFigureSide sideOfFigure) {
<span class="fc bfc" id="L547" title="All 2 branches covered.">        if( sideOfFigure == EnumFigureSide.LEFT ) {</span>
<span class="pc bpc" id="L548" title="1 of 5 branches missed.">            switch(figure) {</span>
<span class="fc" id="L549">                case 11: return Statement.EnumStatementSide.SUBJECT;</span>
<span class="fc" id="L550">                case 12: return Statement.EnumStatementSide.SUBJECT;</span>
<span class="fc" id="L551">                case 21: return Statement.EnumStatementSide.PREDICATE;</span>
<span class="pc" id="L552">                case 22: return Statement.EnumStatementSide.PREDICATE;</span>
            }
        }
        else {
<span class="pc bpc" id="L556" title="1 of 5 branches missed.">            switch(figure) {</span>
<span class="fc" id="L557">                case 11: return Statement.EnumStatementSide.SUBJECT;</span>
<span class="fc" id="L558">                case 12: return Statement.EnumStatementSide.PREDICATE;</span>
<span class="fc" id="L559">                case 21: return Statement.EnumStatementSide.SUBJECT;</span>
<span class="fc" id="L560">                case 22: return Statement.EnumStatementSide.PREDICATE;</span>
            }
        }

<span class="nc" id="L564">        throw new IllegalArgumentException(&quot;figure is invalid&quot;);</span>
    }

<span class="fc" id="L567">    enum EnumFigureSide {</span>
<span class="fc" id="L568">        LEFT,</span>
<span class="fc" id="L569">        RIGHT,</span>
    }


    /**
     * Syllogistic rules whose both premises are on the same symmetric relation
     *
     * @param belief The premise that comes from a belief
     * @param taskSentence The premise that comes from a task
     * @param figure The location of the shared term
     * @param nal Reference to the memory
     */
    private static void symmetricSymmetric(final Sentence belief, final Sentence taskSentence, final int figure, final DerivationContext nal) {
<span class="fc" id="L582">        final Statement s1 = (Statement) belief.term;</span>
<span class="fc" id="L583">        final Statement s2 = (Statement) taskSentence.term;</span>

<span class="fc" id="L585">        final Statement.EnumStatementSide figureLeft = retSideFromFigure(figure, EnumFigureSide.LEFT);</span>
<span class="fc" id="L586">        final Statement.EnumStatementSide figureRight = retSideFromFigure(figure, EnumFigureSide.RIGHT);</span>

        //parameters for unify()
<span class="fc" id="L589">        final Term ut1 = s1.retBySide(figureLeft);</span>
<span class="fc" id="L590">        final Term ut2 = s2.retBySide(figureRight);</span>
        //parameters for resemblance()
<span class="fc" id="L592">        Term rt1 = s1.retBySide(retOppositeSide(figureLeft));</span>
<span class="fc" id="L593">        Term rt2 = s2.retBySide(retOppositeSide(figureRight));</span>
        
<span class="fc" id="L595">        final Term[] u = new Term[] { s1, s2 };</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">        if (Variables.unify(nal.memory.randomNumber, VAR_INDEPENDENT, ut1, ut2, u)) {</span>
            //recalculate rt1, rt2 from above:
<span class="pc bpc" id="L598" title="1 of 5 branches missed.">            switch (figure) {</span>
<span class="fc" id="L599">                case 11: rt1 = s1.getPredicate();   rt2 = s2.getPredicate(); break;</span>
<span class="fc" id="L600">                case 12: rt1 = s1.getPredicate();   rt2 = s2.getSubject();  break;</span>
<span class="fc" id="L601">                case 21: rt1 = s1.getSubject();     rt2 = s2.getPredicate(); break;</span>
<span class="fc" id="L602">                case 22: rt1 = s1.getSubject();     rt2 = s2.getSubject();   break;</span>
            }
            
<span class="fc" id="L605">            SyllogisticRules.resemblance(rt1, rt2, belief, taskSentence, figure, nal);</span>

<span class="fc" id="L607">            CompositionalRules.eliminateVariableOfConditionAbductive(</span>
                    figure, taskSentence, belief, nal);
            
        }

<span class="fc" id="L612">    }</span>

    /* ----- conditional inferences ----- */
    /**
     * The detachment rule, with variable unification
     *
     * @param originalMainSentence The premise that is an Implication or
     * Equivalence
     * @param subSentence The premise that is the subject or predicate of the
     * first one
     * @param index The location of the second premise in the first
     * @param nal Reference to the memory
     */
    private static void detachmentWithVar(final Sentence originalMainSentence, final Sentence subSentence, final int index, final DerivationContext nal) {
<span class="fc" id="L626">        detachmentWithVar(originalMainSentence, subSentence, index, true, nal);</span>
<span class="fc" id="L627">    }</span>
    private static void detachmentWithVar(final Sentence originalMainSentence, Sentence subSentence, final int index, final boolean checkTermAgain, final DerivationContext nal) {
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">        if(originalMainSentence==null)  {</span>
<span class="nc" id="L630">            return;</span>
        }
<span class="fc" id="L632">        Sentence mainSentence = originalMainSentence;   // for substitution</span>
        
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">        if (!(mainSentence.term instanceof Statement))</span>
<span class="nc" id="L635">            return;</span>
        
<span class="fc" id="L637">        final Statement statement = (Statement) mainSentence.term;</span>
        
<span class="fc" id="L639">        final Term component = statement.term[index];</span>
<span class="fc" id="L640">        final Term content = subSentence.term;</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (nal.getCurrentBelief() != null) {</span>
            
<span class="fc" id="L643">            final Term[] u = new Term[] { statement, content };</span>
            
<span class="fc bfc" id="L645" title="All 4 branches covered.">            if (!component.hasVarIndep() &amp;&amp; !component.hasVarDep()) { //because of example: &lt;&lt;(*,w1,#2) --&gt; [good]&gt; ==&gt; &lt;w1 --&gt; TRANSLATE&gt;&gt;. &lt;(*,w1,w2) --&gt; [good]&gt;.</span>
<span class="fc" id="L646">                SyllogisticRules.detachment(mainSentence, subSentence, index, checkTermAgain, nal);</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">            } else if (Variables.unify(nal.memory.randomNumber, VAR_INDEPENDENT, component, content, u)) { //happens through syllogisms</span>
<span class="fc" id="L648">                mainSentence = mainSentence.clone(u[0]);</span>
<span class="fc" id="L649">                subSentence = subSentence.clone(u[1]);</span>
<span class="fc" id="L650">                SyllogisticRules.detachment(mainSentence, subSentence, index, false, nal);</span>
<span class="fc bfc" id="L651" title="All 6 branches covered.">            } else if ((statement instanceof Implication) &amp;&amp; (statement.getPredicate() instanceof Statement) &amp;&amp; (nal.getCurrentTask().sentence.isJudgment())) {</span>
<span class="fc" id="L652">                final Statement s2 = (Statement) statement.getPredicate();</span>
<span class="fc bfc" id="L653" title="All 4 branches covered.">                if ((content instanceof Statement) &amp;&amp; (s2.getSubject().equals(((Statement) content).getSubject()))) {</span>
<span class="fc" id="L654">                    CompositionalRules.introVarInner((Statement) content, s2, statement, nal);</span>
                }
<span class="fc" id="L656">                CompositionalRules.IntroVarSameSubjectOrPredicate(originalMainSentence,subSentence,component,content,index,nal);</span>
<span class="fc bfc" id="L657" title="All 6 branches covered.">            } else if ((statement instanceof Equivalence) &amp;&amp; (statement.getPredicate() instanceof Statement) &amp;&amp; (nal.getCurrentTask().sentence.isJudgment())) {</span>
<span class="fc" id="L658">                CompositionalRules.IntroVarSameSubjectOrPredicate(originalMainSentence,subSentence,component,content,index,nal);                </span>
            }
        }
<span class="fc" id="L661">    }</span>

    /**
     * Conditional deduction or induction, with variable unification
     *
     * @param conditional The premise that is an Implication with a Conjunction
     * as condition
     * @param index The location of the shared term in the condition
     * @param statement The second premise that is a statement
     * @param side The location of the shared term in the statement
     * @param nal Reference to the memory
     */
    private static void conditionalDedIndWithVar(final Sentence conditionalSentence, Implication conditional, final short index, Statement statement, short side, final DerivationContext nal) {
        
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">        if (!(conditional.getSubject() instanceof CompoundTerm))</span>
<span class="nc" id="L676">            return;</span>
        
<span class="fc" id="L678">        final CompoundTerm condition = (CompoundTerm) conditional.getSubject();</span>
        
<span class="fc bfc" id="L680" title="All 2 branches covered.">        if(condition instanceof Conjunction) { //conditionalDedIndWithVar</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">            for(final Term t : condition.term) {     //does not support the case where</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">                if(t instanceof Variable) {    //we have a variable inside of a conjunction</span>
<span class="fc" id="L683">                    return;                    //(this can happen since we have # due to image transform,</span>
                }                              //although not for other conjunctions)
            }
        }
        
<span class="fc" id="L688">        final Term component = condition.term[index];</span>
<span class="fc" id="L689">        Term component2 = null;</span>
<span class="fc bfc" id="L690" title="All 4 branches covered.">        if (statement instanceof Inheritance || statement instanceof Similarity) {</span>
<span class="fc" id="L691">            component2 = statement;</span>
<span class="fc" id="L692">            side = -1;</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">        } else if (statement instanceof Implication) {</span>
<span class="fc" id="L694">            component2 = statement.term[side];</span>
        }

<span class="fc bfc" id="L697" title="All 2 branches covered.">        if (component2 != null) {</span>
<span class="fc" id="L698">            final Term[] u = new Term[] { conditional, statement };</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">            if (Variables.unify(nal.memory.randomNumber, VAR_INDEPENDENT, component, component2, u)) {</span>
<span class="fc" id="L700">                conditional = (Implication) u[0];</span>
<span class="fc" id="L701">                statement = (Statement) u[1];</span>
<span class="fc" id="L702">                SyllogisticRules.conditionalDedInd(conditionalSentence, conditional, index, statement, side, nal);</span>
            }
        }
<span class="fc" id="L705">    }</span>

    /* ----- structural inferences ----- */
    /**
     * Inference between a compound term and a component of it
     *
     * @param compound The compound term
     * @param component The component term
     * @param compoundTask Whether the compound comes from the task
     * @param nal Reference to the memory
     */
     private static void compoundAndSelf(final CompoundTerm compound, final Term component, final boolean compoundTask, final int index, final DerivationContext nal) {
<span class="fc bfc" id="L717" title="All 4 branches covered.">        if ((compound instanceof Conjunction) || (compound instanceof Disjunction)) {</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">            if (nal.getCurrentBelief() != null) {</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">                if(compound.containsTerm(component)) {</span>
<span class="fc" id="L720">                    StructuralRules.structuralCompound(compound, component, compoundTask, index, nal);</span>
                }
<span class="fc" id="L722">                CompositionalRules.decomposeStatement(compound, component, compoundTask, index, nal);</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">            } else if (compound.containsTerm(component)) {</span>
<span class="fc" id="L724">                StructuralRules.structuralCompound(compound, component, compoundTask, index, nal);</span>
            }
<span class="fc bfc" id="L726" title="All 2 branches covered.">        } else if (compound instanceof Negation) {</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">            if (compoundTask) {</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">                if (compound.term[0] instanceof CompoundTerm)</span>
<span class="fc" id="L729">                    StructuralRules.transformNegation((CompoundTerm)compound.term[0], nal);</span>
            } else {
<span class="fc" id="L731">                StructuralRules.transformNegation(compound, nal);</span>
            }
        }
<span class="fc" id="L734">    }</span>

    /**
     * Inference between two compound terms
     *
     * @param taskTerm The compound from the task
     * @param beliefTerm The compound from the belief
     * @param nal Reference to the memory
     */
    private static void compoundAndCompound(final CompoundTerm taskTerm, final CompoundTerm beliefTerm, final int tindex, final int bindex, final DerivationContext nal) {
<span class="fc bfc" id="L744" title="All 2 branches covered.">        if (taskTerm.getClass() == beliefTerm.getClass()) {</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">            if (taskTerm.size() &gt;= beliefTerm.size()) {</span>
<span class="fc" id="L746">                compoundAndSelf(taskTerm, beliefTerm, true, tindex, nal);</span>
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">            } else if (taskTerm.size() &lt; beliefTerm.size()) {</span>
<span class="fc" id="L748">                compoundAndSelf(beliefTerm, taskTerm, false, bindex, nal);</span>
            }
        }
<span class="fc" id="L751">    }</span>

    /**
     * Inference between a compound term and a statement
     *
     * @param compound The compound term
     * @param index The location of the current term in the compound
     * @param statement The statement
     * @param side The location of the current term in the statement
     * @param beliefTerm The content of the belief
     * @param nal Reference to the memory
     */
    private static void compoundAndStatement(CompoundTerm compound, final short index, Statement statement, final short side, final Term beliefTerm, final DerivationContext nal) {
        
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">        if(index &gt;= compound.term.length) {</span>
<span class="nc" id="L766">            return;</span>
        }
<span class="fc" id="L768">        final Term component = compound.term[index];</span>
        
<span class="fc" id="L770">        final Task task = nal.getCurrentTask();</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">        if (component.getClass() == statement.getClass()) {</span>
<span class="fc bfc" id="L772" title="All 4 branches covered.">            if ((compound instanceof Conjunction) &amp;&amp; (nal.getCurrentBelief() != null)) {</span>
<span class="fc" id="L773">                final Conjunction conj = (Conjunction) compound;</span>
<span class="fc" id="L774">                final Term[] u = new Term[] { compound, statement };</span>
<span class="pc bpc" id="L775" title="1 of 6 branches missed.">                if (Variables.unify(nal.memory.randomNumber, VAR_DEPENDENT, component, statement, u) &amp;&amp; u[0] instanceof Conjunction &amp;&amp; u[1] instanceof Statement) {</span>
<span class="fc" id="L776">                    compound = (Conjunction) u[0];</span>
<span class="fc" id="L777">                    statement = (Statement) u[1];</span>
<span class="pc bpc" id="L778" title="1 of 6 branches missed.">                    if(conj.isSpatial || compound.getTemporalOrder() != TemporalRules.ORDER_FORWARD || //only allow dep var elimination</span>
                            index == 0) { //for (&amp;/ on first component!!
<span class="fc" id="L780">                        SyllogisticRules.elimiVarDep(compound, component, </span>
<span class="fc" id="L781">                                statement.equals(beliefTerm),</span>
                                nal);
                    }
<span class="fc bfc" id="L784" title="All 2 branches covered.">                } else if (task.sentence.isJudgment()) { // &amp;&amp; !compound.containsTerm(component)) {</span>
<span class="fc" id="L785">                    CompositionalRules.introVarInner(statement, (Statement) component, compound, nal);</span>
                }
<span class="fc" id="L787">            }</span>
        } else {
<span class="fc bfc" id="L789" title="All 2 branches covered.">            if (task.sentence.isJudgment()) {</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">                if (statement instanceof Inheritance) {</span>
<span class="fc" id="L791">                    StructuralRules.structuralCompose1(compound, index, statement, nal);</span>
<span class="pc bpc" id="L792" title="1 of 10 branches missed.">                    if (!(compound instanceof SetExt || compound instanceof SetInt || compound instanceof Negation</span>
                            || compound instanceof Conjunction || compound instanceof Disjunction)) {
<span class="fc" id="L794">                        StructuralRules.structuralCompose2(compound, index, statement, side, nal);</span>
                    }    // {A --&gt; B, A @ (A&amp;C)} |- (A&amp;C) --&gt; (B&amp;C)
<span class="fc bfc" id="L796" title="All 6 branches covered.">                } else if (!(compound instanceof Negation || compound instanceof Conjunction || compound instanceof Disjunction)) {</span>
<span class="fc" id="L797">                    StructuralRules.structuralCompose2(compound, index, statement, side, nal);</span>
                }       // {A &lt;-&gt; B, A @ (A&amp;C)} |- (A&amp;C) &lt;-&gt; (B&amp;C)
            }
        }
<span class="fc" id="L801">    }</span>

    /**
     * Inference between a component term (of the current term) and a statement
     *
     * @param compound The compound term
     * @param index The location of the current term in the compound
     * @param statement The statement
     * @param side The location of the current term in the statement
     * @param nal Reference to the memory
     */
    private static void componentAndStatement(final CompoundTerm compound, final short index, final Statement statement, final short side, final DerivationContext nal) {
<span class="fc bfc" id="L813" title="All 2 branches covered.">        if (statement instanceof Inheritance) {</span>
<span class="fc" id="L814">            StructuralRules.structuralDecompose1(compound, index, statement, nal);</span>
<span class="fc bfc" id="L815" title="All 4 branches covered.">            if (!(compound instanceof SetExt) &amp;&amp; !(compound instanceof SetInt)) {</span>
<span class="fc" id="L816">                StructuralRules.structuralDecompose2(statement, index, nal);    // {(C-B) --&gt; (C-A), A @ (C-A)} |- A --&gt; B</span>
            } else {
<span class="fc" id="L818">                StructuralRules.transformSetRelation(compound, statement, side, nal);</span>
            }
<span class="fc bfc" id="L820" title="All 2 branches covered.">        } else if (statement instanceof Similarity) {</span>
<span class="fc" id="L821">            StructuralRules.structuralDecompose2(statement, index, nal);        // {(C-B) --&gt; (C-A), A @ (C-A)} |- A --&gt; B</span>
<span class="fc bfc" id="L822" title="All 4 branches covered.">            if ((compound instanceof SetExt) || (compound instanceof SetInt)) {</span>
<span class="fc" id="L823">                StructuralRules.transformSetRelation(compound, statement, side, nal);</span>
            }            
        } 
        
<span class="fc bfc" id="L827" title="All 4 branches covered.">        else if ((statement instanceof Implication) &amp;&amp; (compound instanceof Negation)) {</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">            if (index == 0) {</span>
<span class="fc" id="L829">                StructuralRules.contraposition(statement, nal.getCurrentTask().sentence, nal);</span>
            } else {
<span class="fc" id="L831">                StructuralRules.contraposition(statement, nal.getCurrentBelief(), nal);</span>
            }        
        }
        
<span class="fc" id="L835">    }</span>

    /* ----- inference with one TaskLink only ----- */
    /**
     * The TaskLink is of type TRANSFORM, and the conclusion is an equivalent
     * transformation
     *
     * @param tLink The task link
     * @param nal Reference to the memory
     */
    public static void transformTask(final TaskLink tLink, final DerivationContext nal) {
<span class="fc" id="L846">        final CompoundTerm content = (CompoundTerm) nal.getCurrentTask().getTerm();</span>
<span class="fc" id="L847">        final short[] indices = tLink.index;</span>
<span class="fc" id="L848">        Term expectedInheritanceTerm = null; // we store here the (dereferenced) term which we expect to be a inheritance</span>

        { // this block &quot;dereferences&quot; the term by the address which we are storing in &quot;indices&quot;
<span class="fc bfc" id="L851" title="All 4 branches covered.">            if ((indices.length == 2) || (content instanceof Inheritance)) {          // &lt;(*, term, #) --&gt; #&gt;</span>
<span class="fc" id="L852">                expectedInheritanceTerm = content;</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">            } else if (indices.length == 3) {   // &lt;&lt;(*, term, #) --&gt; #&gt; ==&gt; #&gt;</span>
<span class="fc" id="L854">                expectedInheritanceTerm = content.term[indices[0]];</span>
<span class="pc bpc" id="L855" title="1 of 2 branches missed.">            } else if (indices.length == 4) {   // &lt;(&amp;&amp;, &lt;(*, term, #) --&gt; #&gt;, #) ==&gt; #&gt;</span>
<span class="fc" id="L856">                final Term component = content.term[indices[0]];</span>
<span class="pc bpc" id="L857" title="2 of 8 branches missed.">                if ((component instanceof Conjunction) &amp;&amp; (((content instanceof Implication) &amp;&amp; (indices[0] == 0)) || (content instanceof Equivalence))) {</span>

<span class="fc" id="L859">                    final Term[] cterms = ((CompoundTerm) component).term;</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">                    if (indices[1] &lt; cterms.length - 1) {</span>
<span class="fc" id="L861">                        expectedInheritanceTerm = cterms[indices[1]];</span>
                    } else {
<span class="fc" id="L863">                        return;</span>
                    }
<span class="fc" id="L865">                } else {</span>
<span class="fc" id="L866">                    return;</span>
                }
            }
        }

        // it is not a fatal error if it is not a inheritance, we just ignore it in this case
<span class="fc bfc" id="L872" title="All 2 branches covered.">        if (expectedInheritanceTerm instanceof Inheritance) {</span>
<span class="fc" id="L873">            StructuralRules.transformProductImage((Inheritance) expectedInheritanceTerm, content, indices, nal);</span>
        }
<span class="fc" id="L875">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>