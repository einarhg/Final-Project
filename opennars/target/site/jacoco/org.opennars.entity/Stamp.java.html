<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Stamp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.entity</a> &gt; <span class="el_source">Stamp.java</span></div><h1>Stamp.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.entity;

import org.opennars.inference.TemporalRules;
import org.opennars.interfaces.Timable;
import org.opennars.io.Symbols;
import org.opennars.language.Tense;
import org.opennars.main.Debug;
import org.opennars.storage.Memory;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.Set;

import static org.opennars.inference.TemporalRules.*;
import static org.opennars.language.Tense.*;
import org.opennars.main.Parameters;

/**
 * Stamps are used to keep track of done derivations
 *
 * @author Pei Wang
 * @author Patrick Hammer
 */
public class Stamp implements Cloneable, Serializable {
    /** serial numbers. not to be modified after Stamp constructor has initialized it*/
    public BaseEntry[] evidentialBase;

    /** the length of @see evidentialBase */
    public int baseLength;

    /** creation time of the stamp */
    private long creationTime;

    /** estimated occurrence time of the event */
    private long occurrenceTime;

    /** default for atemporal events means &quot;always&quot; in Judgment/Question, but &quot;current&quot; in Goal/Quest*/
    public static final long ETERNAL = Integer.MIN_VALUE;

    /** caches evidentialBase as a set for comparisons and hashcode, stores the unique Long's in-order for efficiency*/
<span class="fc" id="L66">    private BaseEntry[] evidentialSet = null;</span>

    /** Tense of the item*/
    private Tense tense;

    /** is it a neg confirmation task that was already checked*/
<span class="fc" id="L72">    public boolean alreadyAnticipatedNegConfirmation = false;</span>
    
    /** caches */
<span class="fc" id="L75">    CharSequence name = null;</span>
    
    /**
     * derivation chain containing the used premises and conclusions which made
     * deriving the conclusion c possible
     * Uses LinkedHashSet for optimal contains/indexOf performance.
     * TODO use thread-safety for this
     */
    
    /** cache of hashcode of evidential base */
    private int evidentialHash;

    
    public boolean before(final Stamp s, final int duration) {
<span class="nc bnc" id="L89" title="All 4 branches missed.">        if (isEternal() || s.isEternal())</span>
<span class="nc" id="L90">            return false;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        return order(s.occurrenceTime, occurrenceTime, duration) == TemporalRules.ORDER_BACKWARD;</span>
    }
    
    public boolean after(final Stamp s, final int duration) {
<span class="pc bpc" id="L95" title="1 of 4 branches missed.">        if (isEternal() || s.isEternal())</span>
<span class="fc" id="L96">            return false;</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        return order(s.occurrenceTime, occurrenceTime, duration) == TemporalRules.ORDER_FORWARD;        }</span>

    public float getOriginality() {
<span class="nc" id="L100">        return 1.0f / (evidentialBase.length + 1);</span>
    }
    
    /** used for when the ocrrence time will be set later; so should not be called from externally but through another Stamp constructor */
<span class="fc" id="L104">    protected Stamp(final Tense tense, final BaseEntry serial) {</span>
<span class="fc" id="L105">        this.baseLength = 1;</span>
<span class="fc" id="L106">        this.evidentialBase = new BaseEntry[baseLength];</span>
<span class="fc" id="L107">        this.evidentialBase[0] = serial;</span>
<span class="fc" id="L108">        this.tense = tense;</span>
<span class="fc" id="L109">        this.creationTime = -1;</span>
<span class="fc" id="L110">    }</span>
    
    /**
     * Generate a new stamp, with a new serial number, for a new Task
     *
     * @param time Creation time of the stamp
     */
    public Stamp(final long time, final Tense tense, final BaseEntry serial, final int duration) {    
<span class="fc" id="L118">        this(tense, serial);    </span>
<span class="fc" id="L119">        setCreationTime(time, duration);        </span>
<span class="fc" id="L120">    }</span>

    /**
     * Generate a new stamp identical with a given one
     *
     * @param old The stamp to be cloned
     */
    private Stamp(final Stamp old) {
<span class="fc" id="L128">        this(old, old.creationTime);</span>
<span class="fc" id="L129">    }</span>

    /**
     * Generate a new stamp from an existing one, with the same evidentialBase
     * but different creation time
     * &lt;p&gt;
     * For single-premise rules
     *
     * @param old The stamp of the single premise
     * @param creationTime The current time
     */
    public Stamp(final Stamp old, final long creationTime) {
<span class="fc" id="L141">        this(old, creationTime, old);</span>
<span class="fc" id="L142">    }</span>

<span class="fc" id="L144">    public Stamp(final Stamp old, final long creationTime, final Stamp useEvidentialBase) {        </span>
<span class="fc" id="L145">        this.evidentialBase = useEvidentialBase.evidentialBase;</span>
<span class="fc" id="L146">        this.baseLength = useEvidentialBase.baseLength;</span>
<span class="fc" id="L147">        this.creationTime = creationTime;</span>

<span class="fc" id="L149">        this.occurrenceTime = old.getOccurrenceTime();</span>
<span class="fc" id="L150">    }</span>
    
    /**
     * Generate a new stamp for derived sentence by merging the two from parents
     * the first one is no shorter than the second
     *
     * @param first The first Stamp
     * @param second The second Stamp
     */
<span class="fc" id="L159">    public Stamp(final Stamp first, final Stamp second, final long time, Parameters narParameters) {</span>
        //TODO use iterators instead of repeated first and second .get's?
        
        int i1, i2, j;
<span class="fc" id="L163">        i1 = i2 = j = 0;</span>
<span class="fc" id="L164">        this.baseLength = Math.min(first.baseLength + second.baseLength, narParameters.MAXIMUM_EVIDENTAL_BASE_LENGTH);</span>
<span class="fc" id="L165">        this.evidentialBase = new BaseEntry[baseLength];</span>

<span class="fc" id="L167">        final BaseEntry[] firstBase = first.evidentialBase;</span>
<span class="fc" id="L168">        final BaseEntry[] secondBase = second.evidentialBase;     </span>
<span class="fc" id="L169">        final int firstLength = firstBase.length;</span>
<span class="fc" id="L170">        final int secondLength = secondBase.length;</span>

<span class="fc" id="L172">        creationTime = time;</span>
<span class="fc" id="L173">        occurrenceTime = first.getOccurrenceTime();    // use the occurrence of task</span>
        
        //https://code.google.com/p/open-nars/source/browse/trunk/nars_core_java/nars/entity/Stamp.java#143        
<span class="fc bfc" id="L176" title="All 2 branches covered.">        while (j &lt; baseLength) {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            if(i2 &lt; secondLength) {</span>
<span class="fc" id="L178">                evidentialBase[j++] = secondBase[i2++];</span>
            }
<span class="fc bfc" id="L180" title="All 2 branches covered.">            if(i1 &lt; firstLength) {</span>
<span class="fc" id="L181">                evidentialBase[j++] = firstBase[i1++];</span>
            }
        }
<span class="fc" id="L184">    }</span>

    public Stamp(final Timable time, final Memory memory, final Tense tense) {
<span class="fc" id="L187">        this(time.time(), tense, memory.newStampSerial(), memory.narParameters.DURATION);</span>
<span class="fc" id="L188">    }</span>

    /** creates a stamp with default Present tense */
    public Stamp(final Timable time, final Memory memory) {
<span class="fc" id="L192">        this(time, memory, Tense.Present);</span>
<span class="fc" id="L193">    }</span>
    
    /** Detects evidental base overlaps **/
    public static boolean baseOverlap(final Stamp a, final Stamp b) {
<span class="fc" id="L197">        final BaseEntry[] base1 = a.evidentialBase;</span>
<span class="fc" id="L198">        final BaseEntry[] base2 = b.evidentialBase;</span>

<span class="fc" id="L200">        final Set&lt;BaseEntry&gt; task_base = new LinkedHashSet&lt;&gt;(base1.length + base2.length);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        for (final BaseEntry aBase1 : base1) {</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            if (task_base.contains(aBase1)) { //can have an overlap in itself already</span>
<span class="fc" id="L203">                return true;</span>
            }
<span class="fc" id="L205">            task_base.add(aBase1);</span>
        }
<span class="fc bfc" id="L207" title="All 2 branches covered.">        for (final BaseEntry aBase2 : base2) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (task_base.contains(aBase2)) {</span>
<span class="fc" id="L209">                return true;</span>
            }
<span class="fc" id="L211">            task_base.add(aBase2); //also add to detect collision with itself</span>
        }
<span class="fc" id="L213">        return false;</span>
     }
    
    public boolean evidenceIsCyclic() {
<span class="fc" id="L217">        final Set&lt;BaseEntry&gt; task_base = new LinkedHashSet&lt;&gt;(this.evidentialBase.length);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        for (final BaseEntry anEvidentialBase : this.evidentialBase) {</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (task_base.contains(anEvidentialBase)) { //can have an overlap in itself already</span>
<span class="fc" id="L220">                return true;</span>
            }
<span class="fc" id="L222">            task_base.add(anEvidentialBase);</span>
        }
<span class="fc" id="L224">        return false;</span>
    }

    public boolean isEternal() {
<span class="fc bfc" id="L228" title="All 2 branches covered.">        final boolean eternalOccurrence = occurrenceTime == ETERNAL;</span>
        
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        if (Debug.DETAILED) {</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">            if (eternalOccurrence &amp;&amp; tense!=Tense.Eternal) {</span>
<span class="nc" id="L232">                throw new IllegalStateException(&quot;Stamp has inconsistent tense and eternal ocurrenceTime: tense=&quot; + tense);</span>
            }
        }
        
<span class="fc" id="L236">        return eternalOccurrence;</span>
    }
    /** sets the creation time; used to set input tasks with the actual time they enter Memory */
    public void setCreationTime(final long time, final int duration) {
<span class="fc" id="L240">        creationTime = time;</span>
        
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if (tense == null) {</span>
<span class="fc" id="L243">            occurrenceTime = ETERNAL;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        } else if (tense == Past) {</span>
<span class="fc" id="L245">            occurrenceTime = time - duration;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        } else if (tense == Future) {</span>
<span class="fc" id="L247">            occurrenceTime = time + duration;</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        } else if (tense == Present) {</span>
<span class="fc" id="L249">            occurrenceTime = time;</span>
        } else {
<span class="nc" id="L251">            occurrenceTime = time;</span>
        }
        
<span class="fc" id="L254">    }</span>

    /**
     * Clone a stamp
     *
     * @return The cloned stamp
     */
    @Override
    public Stamp clone() {
<span class="fc" id="L263">        return new Stamp(this);</span>
    }
    
    public static BaseEntry[] toSetArray(final BaseEntry[] x) {
<span class="fc" id="L267">        final BaseEntry[] set = x.clone();</span>
        
<span class="fc bfc" id="L269" title="All 2 branches covered.">        if (x.length &lt; 2)</span>
<span class="fc" id="L270">            return set;</span>
        
        //1. copy evidentialBse
        //2. sort
        //3. count duplicates
        //4. create new array 
        
<span class="fc" id="L277">        Arrays.sort(set);</span>
<span class="fc" id="L278">        BaseEntry lastValue = null;</span>
<span class="fc" id="L279">        int j = 0; //# of unique items</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for (final BaseEntry v : set) {</span>
<span class="fc bfc" id="L281" title="All 4 branches covered.">            if (lastValue == null || !lastValue.equals(v)) {</span>
<span class="fc" id="L282">                j++;</span>
            }
<span class="fc" id="L284">            lastValue = v;</span>
        }
<span class="fc" id="L286">        lastValue = null;</span>
<span class="fc" id="L287">        final BaseEntry[] sorted = new BaseEntry[j];</span>
<span class="fc" id="L288">        j = 0;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        for (final BaseEntry v : set) {</span>
<span class="fc bfc" id="L290" title="All 4 branches covered.">            if (lastValue == null || !lastValue.equals(v)) {</span>
<span class="fc" id="L291">                sorted[j++] = v;</span>
            }
<span class="fc" id="L293">            lastValue = v;</span>
        }
<span class="fc" id="L295">        return sorted;</span>
    }

    /**
     * Convert the evidentialBase into a set
     *
     * @return The NavigableSet representation of the evidential base
     */
    private BaseEntry[] toSet() {        
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (evidentialSet == null) {        </span>
<span class="fc" id="L305">            evidentialSet = toSetArray(evidentialBase);</span>
<span class="fc" id="L306">            evidentialHash = Arrays.hashCode(evidentialSet);</span>
        }
        
<span class="fc" id="L309">        return evidentialSet;</span>
    }

    
    @Override public boolean equals(final Object that) {
<span class="nc" id="L314">        throw new IllegalStateException(&quot;Use other equals() method&quot;);</span>
    }
    
    /**
     * Check if two stamps contains the same types of content
     *
     * @param s The Stamp to be compared
     * @return Whether the two have contain the same evidential base
     */
    public boolean equals(final Stamp s, final boolean creationTime, final boolean ocurrenceTime, final boolean evidentialBase) {
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (this == s) return true;</span>

<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (creationTime)</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">            if (getCreationTime()!=s.getCreationTime()) return false;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (ocurrenceTime)</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">            if (getOccurrenceTime()!=s.getOccurrenceTime()) return false;       </span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (evidentialBase) {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            if (evidentialHash() != s.evidentialHash()) return false;</span>
<span class="fc" id="L332">            return Arrays.equals(toSet(), s.toSet());</span>
        }
        
<span class="nc" id="L335">        return true;        </span>
    }
    
    /**
     * hash code of Stamp
     *
     * @return hash code
     */
    public final int evidentialHash() {
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (evidentialSet==null)</span>
<span class="fc" id="L345">            toSet();       </span>
<span class="fc" id="L346">        return evidentialHash;</span>
    }
    
    public Stamp cloneWithNewOccurrenceTime(final long newOcurrenceTime) {
<span class="fc" id="L350">        final Stamp s = clone();</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (newOcurrenceTime == ETERNAL)</span>
<span class="fc" id="L352">            s.tense = Tense.Eternal;</span>
<span class="fc" id="L353">        s.setOccurrenceTime(newOcurrenceTime);</span>
<span class="fc" id="L354">        return s;</span>
    }

    /**
     * Get the occurrenceTime of the truth-value
     *
     * @return occurrence time
     */
    public long getOccurrenceTime() {
<span class="fc" id="L363">        return occurrenceTime;</span>
    }
    
    /**
     * 
     */
    public void setEternal() {
<span class="fc" id="L370">        occurrenceTime=ETERNAL;</span>
<span class="fc" id="L371">    }</span>
    
    public StringBuilder appendOcurrenceTime(final StringBuilder sb) {
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (occurrenceTime != ETERNAL) {</span>
<span class="fc" id="L375">            final int estTimeLength = 8; /* # digits */</span>
<span class="fc" id="L376">            sb.ensureCapacity(estTimeLength + 1 + 1);</span>
<span class="fc" id="L377">            sb.append('[').append(occurrenceTime).append(']').toString();</span>
        }
<span class="fc" id="L379">        return sb;</span>
    }
            
    /**
     * Get the occurrenceTime of the truth-value
     *
     * @return occurrence time
     */
    public String getOccurrenceTimeString() {
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (isEternal()) {</span>
<span class="nc" id="L389">            return &quot;&quot;;</span>
        } else {
<span class="nc" id="L391">            return appendOcurrenceTime(new StringBuilder()).toString();</span>
        }
    }

    public String getTense(final long currentTime, final int duration) {
        
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (isEternal()) {</span>
<span class="nc" id="L398">            return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L400" title="All 3 branches missed.">        switch (TemporalRules.order(currentTime, occurrenceTime, duration)) {</span>
            case ORDER_FORWARD:
<span class="nc" id="L402">                return Symbols.TENSE_FUTURE;</span>
            case ORDER_BACKWARD:
<span class="nc" id="L404">                return Symbols.TENSE_PAST;</span>
            default:
<span class="nc" id="L406">                return Symbols.TENSE_PRESENT;</span>
        }        
    }

    public void setOccurrenceTime(final long time) {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (occurrenceTime!=time) {</span>
<span class="fc" id="L412">            occurrenceTime = time;</span>
            
<span class="fc bfc" id="L414" title="All 2 branches covered.">            if (time == ETERNAL)</span>
<span class="fc" id="L415">                tense = Tense.Eternal;</span>
                        
<span class="fc" id="L417">            name = null;</span>
        }
<span class="fc" id="L419">    }</span>

    public CharSequence name() {
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (name == null) {</span>
            
<span class="nc" id="L424">            final int estimatedInitialSize = 10 * baseLength;</span>

<span class="nc" id="L426">            final StringBuilder buffer = new StringBuilder(estimatedInitialSize);</span>
<span class="nc" id="L427">            buffer.append(Symbols.STAMP_OPENER).append(getCreationTime());</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            if (!isEternal()) {</span>
<span class="nc" id="L429">                buffer.append('|').append(occurrenceTime);</span>
            }
<span class="nc" id="L431">            buffer.append(' ').append(Symbols.STAMP_STARTER).append(' ');</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">            for (int i = 0; i &lt; baseLength; i++) {</span>
<span class="nc" id="L433">                buffer.append(evidentialBase[i].toString());</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                if (i &lt; (baseLength - 1)) {</span>
<span class="nc" id="L435">                    buffer.append(Symbols.STAMP_SEPARATOR);</span>
                }
            }
<span class="nc" id="L438">            buffer.append(Symbols.STAMP_CLOSER).append(' ');</span>

            //this is for estimating an initial size of the stringbuffer
            //System.out.println(baseLength + &quot; &quot; + derivationChain.size() + &quot; &quot; + buffer.baseLength());
<span class="nc" id="L442">            name = buffer;</span>
        }
<span class="nc" id="L444">        return name;</span>
    }

    @Override
    public String toString() {        
<span class="nc" id="L449">        return name().toString();</span>
    }

    /**
     * @return time of creation
     */
    public long getCreationTime() {
<span class="fc" id="L456">        return creationTime;</span>
    }



    /**
     * Element of the evidential base of stamp
     */
    public static class BaseEntry implements Comparable, Serializable {
        public final long narId; //the NAR in which the input evidence was added
        public long getNarId() {
<span class="fc" id="L467">            return narId;</span>
        }
        public final long inputId;
        public long getInputId() {
<span class="fc" id="L471">            return inputId;</span>
        }

        /**
         * The evidential base entry
         *
         * @param narId The id of the NAR the input evidence was obtained from
         * @param inputId The nar-specific input id of the input
         */
<span class="fc" id="L480">        public BaseEntry(long narId, long inputId) {</span>
<span class="fc" id="L481">            this.narId = narId;</span>
<span class="fc" id="L482">            this.inputId = inputId;</span>
<span class="fc" id="L483">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L487">            return &quot;(&quot; + narId + &quot;,&quot; + inputId + &quot;)&quot;;</span>
        }

        @Override
        public boolean equals(Object other) {
<span class="fc bfc" id="L492" title="All 2 branches covered.">            if (other == this) {</span>
<span class="fc" id="L493">                return true;</span>
            }
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">            if (!(other instanceof BaseEntry)){</span>
<span class="nc" id="L496">                return false;</span>
            }
<span class="fc" id="L498">            BaseEntry other_ = (BaseEntry) other;</span>
<span class="pc bpc" id="L499" title="1 of 4 branches missed.">            return other_.inputId == this.inputId &amp;&amp; other_.narId == this.narId;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L504">            final int prime = 31;</span>
<span class="fc" id="L505">            int result = 1;</span>
<span class="fc" id="L506">            result = prime * result + Long.hashCode(narId);</span>
<span class="fc" id="L507">            result = prime * result + Long.hashCode(inputId);</span>
<span class="fc" id="L508">            return result;</span>
        }

        @Override
        public int compareTo(Object o) {
<span class="fc" id="L513">            return Comparator.comparing(BaseEntry::getNarId).thenComparing(BaseEntry::getInputId).compare(this, (BaseEntry) o);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>