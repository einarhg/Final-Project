<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Task.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.entity</a> &gt; <span class="el_source">Task.java</span></div><h1>Task.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.entity;

import org.opennars.interfaces.Timable;
import org.opennars.language.Term;
import org.opennars.plugin.mental.InternalExperience;
import org.opennars.storage.Memory;

import java.io.Serializable;

/**
 * A task to be processed, consists of a Sentence and a BudgetValue.
 * A task references its parent and an optional causal factor (usually an Operation instance).  These are implemented as WeakReference to allow forgetting via the
 * garbage collection process.  Otherwise, Task ancestry would grow unbounded,
 * violating the assumption of insufficient resources (AIKR).
 *
 * @author Pei Wang
 * @author Patrick Hammer
 */
public class Task&lt;T extends Term&gt; extends Item&lt;Sentence&lt;T&gt;&gt; implements Serializable  {

    /* The sentence of the Task*/
    public final Sentence&lt;T&gt; sentence;
    /* Belief from which the Task is derived, or null if derived from a theorem*/
    public final Sentence parentBelief;
    /* Tasklink from which the Task is derived, null unless Debug.PARENTS is turned on*/
    public Sentence parentTask;
    /* For Question and Goal: best solution found so far*/
    private Sentence bestSolution;
    /* Whether the task should go into event bag or not*/
<span class="fc" id="L53">    private boolean partOfSequenceBuffer = false;</span>
    /* Whether it is an input task or not */
<span class="fc" id="L55">    private boolean isInput = false;</span>

    /**
     * Constructor for input task and single premise derived task
     *
     * @param s The sentence
     * @param b The budget
     */ 
    public Task(final Sentence&lt;T&gt; s, final BudgetValue b, EnumType type) {
<span class="fc" id="L64">        this(s, b, null, null);  </span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">        this.isInput = type == EnumType.INPUT;</span>
<span class="fc" id="L66">    }</span>
    
    /***
     * Constructors for double premise derived task 
     * 
     * @param s The sentence
     * @param b The budget
     * @param parentBelief The belief used for deriving the task
     */
    public Task(final Sentence&lt;T&gt; s, final BudgetValue b, final Sentence parentBelief) {
<span class="fc" id="L76">        this(s, b, parentBelief, null);</span>
<span class="fc" id="L77">    }</span>
    
    /***
     * Constructors for solved double premise derived task 
     * 
     * @param s The sentence
     * @param b The budget
     * @param parentBelief The belief used for deriving the task 
     * @param solution The solution to the task
     */
    public Task(final Sentence&lt;T&gt; s, final BudgetValue b, final Sentence parentBelief, final Sentence solution) {
<span class="fc" id="L88">        super(b);</span>
<span class="fc" id="L89">        this.sentence = s;</span>
<span class="fc" id="L90">        this.parentBelief = parentBelief;</span>
<span class="fc" id="L91">        this.bestSolution = solution;   </span>
<span class="fc" id="L92">    }</span>
    
    @Override public Sentence name() {
<span class="fc" id="L95">        return sentence;</span>
    }

    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (obj == this) return true;</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (obj instanceof Task) {</span>
<span class="fc" id="L102">            final Task t = (Task)obj;</span>
<span class="fc" id="L103">            return t.sentence.equals(sentence);</span>
        }
<span class="nc" id="L105">        return false;        </span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L110">        return sentence.hashCode();</span>
    }

    /**
     * Directly get the creation time of the sentence
     *
     * @return The creation time of the sentence
     */
    public long getCreationTime() {
<span class="fc" id="L119">        return sentence.stamp.getCreationTime();</span>
    }

    /**
     * Check if a Task is a direct input
     *
     * @return Whether the Task is derived from another task
     */
    public boolean isInput() {
<span class="fc" id="L128">        return isInput;</span>
    }
    
    public boolean aboveThreshold() {
<span class="fc" id="L132">        return budget.aboveThreshold();</span>
    }
    
    /**
     * Merge one Task into another
     *
     * @param that The other Task
     */
    @Override
    public Item merge(final Item that) {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (getCreationTime() &gt;= ((Task) that).getCreationTime()) {</span>
<span class="fc" id="L143">            return super.merge(that);</span>
        } else {
<span class="fc" id="L145">            return that.merge(this);</span>
        }
    }

    /**
     * Get the best-so-far solution for a Question or Goal
     *
     * @return The stored Sentence or null
     */
    public Sentence getBestSolution() {
<span class="fc" id="L155">        return bestSolution;</span>
    }

    /**
     * Set the best-so-far solution for a Question or Goal, and report answer
     * for input question
     *
     * @param judg The solution to be remembered
     */
    public void setBestSolution(final Memory memory,final Sentence judg, final Timable time) {
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if(memory.internalExperience != null) {</span>
<span class="fc" id="L166">            InternalExperience.InternalExperienceFromBelief(memory, this, judg, time);</span>
        }
<span class="fc" id="L168">        bestSolution = judg;</span>
<span class="fc" id="L169">    }</span>

    /**
     * Get the parent belief of a task
     *
     * @return The belief from which the task is derived
     */
    public Sentence getParentBelief() {
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (parentBelief == null) return null;</span>
<span class="fc" id="L178">        return parentBelief;</span>
    }

    /**
     * Get a String representation of the Task
     *
     * @return The Task as a String
     */
    @Override
    public String toStringLong() {
<span class="nc" id="L188">        final StringBuilder s = new StringBuilder();</span>
<span class="nc" id="L189">        s.append(super.toString()).append(' ').append(sentence.stamp.name());</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (bestSolution != null) {</span>
<span class="nc" id="L191">            s.append(&quot;  \n solution: &quot;).append(bestSolution.toString());</span>
        }
<span class="nc" id="L193">        return s.toString();</span>
    }

    /** flag to indicate whether this Event Task participates in tempporal induction */
    public void setElemOfSequenceBuffer(final boolean b) {
<span class="fc" id="L198">        this.partOfSequenceBuffer = b;</span>
<span class="fc" id="L199">    }</span>

    public boolean isElemOfSequenceBuffer() {
<span class="pc bpc" id="L202" title="2 of 6 branches missed.">        return !this.sentence.isEternal() &amp;&amp; (this.isInput() || partOfSequenceBuffer);</span>
    }

    public T getTerm() {
<span class="fc" id="L206">        return sentence.getTerm();</span>
    }

<span class="fc" id="L209">    public enum EnumType {</span>
<span class="fc" id="L210">        INPUT,</span>
<span class="fc" id="L211">        DERIVED,</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>