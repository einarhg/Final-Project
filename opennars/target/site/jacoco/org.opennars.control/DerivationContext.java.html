<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DerivationContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.control</a> &gt; <span class="el_source">DerivationContext.java</span></div><h1>DerivationContext.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.control;

import org.opennars.entity.*;
import org.opennars.inference.TruthFunctions;
import org.opennars.interfaces.Timable;
import org.opennars.io.events.Events;
import org.opennars.main.Parameters;
import org.opennars.language.*;
import org.opennars.operator.Operation;
import org.opennars.storage.Memory;
import org.opennars.main.Debug;

import java.util.ArrayList;
import java.util.List;

/**
 * NAL Reasoner Process.  Includes all reasoning process state.
 *
 * @author Patrick Hammer
 */
public class DerivationContext {
<span class="fc" id="L45">    public boolean evidentalOverlap = false;</span>
    public final Memory memory;
    protected Term currentTerm;
    protected Concept currentConcept;
    protected Task currentTask;
    protected TermLink currentBeliefLink;
    protected TaskLink currentTaskLink;
    protected Sentence currentBelief;
    protected Stamp newStamp;
    public StampBuilder newStampBuilder;

    public Parameters narParameters;

    public Timable time;
    
    public DerivationContext(final Memory mem, final Parameters narParameters, final Timable time) {
<span class="fc" id="L61">        super();</span>
<span class="fc" id="L62">        this.memory = mem;</span>
<span class="fc" id="L63">        this.narParameters = narParameters;</span>
<span class="fc" id="L64">        this.time = time;</span>
<span class="fc" id="L65">    }</span>
   
    public void emit(final Class c, final Object... o) {
<span class="fc" id="L68">        memory.emit(c, o);</span>
<span class="fc" id="L69">    }</span>

    /**
     * Derived task comes from the inference rules.
     *
     * @param task the derived task
     * @param overlapAllowed //https://groups.google.com/forum/#!topic/open-nars/FVbbKq5En-M
     */
    public boolean derivedTask(final Task task, final boolean revised, final boolean single, final boolean overlapAllowed) {
<span class="fc" id="L78">        return derivedTask(task, revised, single, overlapAllowed, true);</span>
    }
    public boolean derivedTask(final Task task, final boolean revised, final boolean single, final boolean overlapAllowed, final boolean addToMemory) {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        if (Debug.PARENTS) {</span>
<span class="nc" id="L82">            task.parentTask = getCurrentTask().sentence;</span>
        }

<span class="pc bpc" id="L85" title="1 of 8 branches missed.">        if((task.sentence.isGoal() || task.sentence.isQuest()) &amp;&amp; (task.sentence.term instanceof Implication ||</span>
                                      task.sentence.term instanceof Equivalence)) {
<span class="fc" id="L87">            return false; //implication and equivalence goals and quests are not supported anymore</span>
        }
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (!task.budget.aboveThreshold()) {</span>
<span class="nc" id="L90">            memory.removeTask(task, &quot;Insufficient Budget&quot;);</span>
<span class="nc" id="L91">            return false;</span>
        } 
<span class="pc bpc" id="L93" title="1 of 4 branches missed.">        if (task.sentence != null &amp;&amp; task.sentence.truth != null) {</span>
<span class="fc" id="L94">            final double conf = task.sentence.truth.getConfidence();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            if (conf &lt; narParameters.TRUTH_EPSILON) {</span>
                //no confidence - we can delete the wrongs out that way.
<span class="fc" id="L97">                memory.removeTask(task, &quot;Ignored (zero confidence)&quot;);</span>
<span class="fc" id="L98">                return false;</span>
            }
        }
<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (task.sentence.term instanceof Operation) {</span>
<span class="fc" id="L102">            final Operation op = (Operation) task.sentence.term;</span>
<span class="pc bpc" id="L103" title="2 of 4 branches missed.">            if (op.getSubject() instanceof Variable || op.getPredicate() instanceof Variable) {</span>
<span class="nc" id="L104">                memory.removeTask(task, &quot;Operation with variable as subject or predicate&quot;);</span>
<span class="nc" id="L105">                return false;</span>
            }
        }
<span class="fc bfc" id="L108" title="All 2 branches covered.">        if(task.sentence.term.cloneDeep() == null) {</span>
            //sorted subterm version leaded to a invalid term that remained undetected while the term was constructed optimistically
            //example: (&amp;,a,b) --&gt; (&amp;,b,a) which gets normalized to (&amp;,a,b) --&gt; (&amp;,a,b) which is invalid.
<span class="fc" id="L111">            memory.removeTask(task, &quot;Wrong Format&quot;);</span>
<span class="fc" id="L112">            return false;</span>
        }

<span class="fc" id="L115">        final Stamp stamp = task.sentence.stamp;</span>
        
        //its revision, of course its cyclic, apply evidental base policy
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if(!overlapAllowed) { //todo reconsider</span>
            //!single since the derivation shouldn't depend on whether there is a current belief or not!!
<span class="fc bfc" id="L120" title="All 4 branches covered.">            final boolean doublePremiseEvidentalBaseOverlap = !single &amp;&amp; this.evidentalOverlap;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            if (doublePremiseEvidentalBaseOverlap) {</span>
<span class="fc" id="L122">                memory.removeTask(task, &quot;overlapping evidential base&quot;);</span>
<span class="fc" id="L123">                return false;</span>
            }

<span class="fc" id="L126">            final boolean selfOverlap = stamp.evidenceIsCyclic();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (selfOverlap) {</span>
<span class="fc" id="L128">                memory.removeTask(task, &quot;overlapping evidential base&quot;);</span>
<span class="fc" id="L129">                return false;</span>
            }
        }
        
        //deactivated, new anticipation handling is attempted instead
        /*if(task.sentence.getOccurenceTime()&gt;memory.time() &amp;&amp; ((this.getCurrentTask()!=null &amp;&amp; (this.getCurrentTask().isInput() || this.getCurrentTask().sentence.producedByTemporalInduction)) || (this.getCurrentBelief()!=null &amp;&amp; this.getCurrentBelief().producedByTemporalInduction))) {
            Anticipate ret = ((Anticipate)memory.getOperator(&quot;^anticipate&quot;));
            if(ret!=null) {
                ret.anticipate(task.sentence.term, memory, task.sentence.getOccurenceTime(),task);
            }
        }*/
        
<span class="fc" id="L141">        task.setElemOfSequenceBuffer(false);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if(!revised) {</span>
<span class="fc" id="L143">            task.getBudget().setDurability(task.getBudget().getDurability()*narParameters.DERIVATION_DURABILITY_LEAK);</span>
<span class="fc" id="L144">            task.getBudget().setPriority(task.getBudget().getPriority()*narParameters.DERIVATION_PRIORITY_LEAK);</span>
        }
<span class="fc" id="L146">        memory.event.emit(Events.TaskDerive.class, task, revised, single);</span>
        //memory.logic.TASK_DERIVED.commit(task.budget.getPriority());
        
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if(addToMemory) {</span>
<span class="fc" id="L150">            addTask(task, &quot;Derived&quot;);</span>
        }
<span class="fc" id="L152">        return true;</span>
    }

    /* --------------- new task building --------------- */
    /**
     * Shared final operations by all double-premise rules, called from the
     * rules except StructuralRules
     *
     * @param newContent The content of the sentence in task
     * @param newTruth The truth value of the sentence in task
     * @param newBudget The budget value in task
     */
    public boolean doublePremiseTaskRevised(final Term newContent, final TruthValue newTruth, final BudgetValue newBudget, final long counter) {
<span class="fc" id="L165">        final Stamp derived_stamp = getTheNewStamp().clone();</span>
<span class="fc" id="L166">        this.resetOccurrenceTime(); //stamp was already obsorbed</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">        final boolean isCounterValid = counter != -1;</span>
<span class="fc" id="L169">        Term conclusionTerm = newContent;</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (isCounterValid) {</span>
            // assert newContent is implication

<span class="fc" id="L173">            Term conclusionSubject = ((Implication)conclusionTerm).getSubject();</span>
<span class="fc" id="L174">            Term conclusionPredicate = ((Implication)conclusionTerm).getPredicate();</span>
<span class="fc" id="L175">            conclusionTerm = new Implication(new Term[]{conclusionSubject, conclusionPredicate}, newContent.getTemporalOrder(), counter);</span>
        }

<span class="fc" id="L178">        final Sentence newSentence = new Sentence(</span>
            conclusionTerm,
<span class="fc" id="L180">            getCurrentTask().sentence.punctuation,</span>
            newTruth,
            derived_stamp);

<span class="fc" id="L184">        final Task newTask = new Task(newSentence, newBudget, getCurrentBelief());</span>

<span class="fc" id="L186">        return derivedTask(newTask, true, false, true); //allows overlap since overlap was already checked on revisable( function</span>
    }                                                               //which is not the case for other single premise tasks


    /**
     * Shared final operations by all double-premise rules, called from the
     * rules except StructuralRules
     *
     * @param newContent The content of the sentence in task
     * @param newTruth The truth value of the sentence in task
     * @param newBudget The budget value in task
     * @param temporalInduction
     * @param overlapAllowed // https://groups.google.com/forum/#!topic/open-nars/FVbbKq5En-M
     */
    public List&lt;Task&gt; doublePremiseTask(final Term newContent, final TruthValue newTruth, final BudgetValue newBudget, final boolean temporalInduction, final boolean overlapAllowed) {
<span class="fc" id="L201">        return doublePremiseTask(newContent, newTruth, newBudget, temporalInduction, overlapAllowed, true);</span>
    }
    public List&lt;Task&gt; doublePremiseTask(final Term newContent, final TruthValue newTruth, final BudgetValue newBudget, final boolean temporalInduction, final boolean overlapAllowed, final boolean addToMemory) {
        
<span class="fc" id="L205">        final List&lt;Task&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L206" title="All 4 branches covered.">        if(newContent == null || !newBudget.aboveThreshold()) {</span>
<span class="fc" id="L207">            return null;</span>
        }
<span class="pc bpc" id="L209" title="1 of 6 branches missed.">        if ((newContent != null) &amp;&amp; (!(newContent instanceof Interval)) &amp;&amp; (!(newContent instanceof Variable))) {</span>
            
<span class="fc bfc" id="L211" title="All 2 branches covered.">            if(newContent.subjectOrPredicateIsIndependentVar()) {</span>
<span class="fc" id="L212">                return null;</span>
            }
<span class="fc" id="L214">            final Stamp derive_stamp = getTheNewStamp().clone(); //because occurrence time will be reset:</span>
<span class="fc" id="L215">            this.resetOccurrenceTime(); //stamp was already obsorbed into task</span>

<span class="fc" id="L217">            Sentence newSentence = new Sentence(</span>
                newContent,
<span class="fc" id="L219">                getCurrentTask().sentence.punctuation,</span>
                newTruth,
                derive_stamp);

<span class="fc" id="L223">            newSentence.producedByTemporalInduction=temporalInduction;</span>
<span class="fc" id="L224">            Task newTask = new Task(newSentence, newBudget, getCurrentBelief());</span>

<span class="pc bpc" id="L226" title="1 of 2 branches missed.">            if (newTask!=null) {</span>
<span class="fc" id="L227">                final boolean added = derivedTask(newTask, false, false, overlapAllowed, addToMemory);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">                if(added) {</span>
<span class="fc" id="L229">                    ret.add(newTask);</span>
                }
            }
            
            
            //&quot;Since in principle it is always valid to eternalize a tensed belief&quot;
<span class="pc bpc" id="L235" title="1 of 4 branches missed.">            if(temporalInduction &amp;&amp; narParameters.IMMEDIATE_ETERNALIZATION) { //temporal induction generated ones get eternalized directly</span>
<span class="fc" id="L236">                final TruthValue truthEt=TruthFunctions.eternalize(newTruth, this.narParameters);</span>
<span class="fc" id="L237">                final Stamp st=derive_stamp.clone();</span>
<span class="fc" id="L238">                st.setEternal();</span>
<span class="fc" id="L239">                newSentence = new Sentence(</span>
                    newContent,
<span class="fc" id="L241">                    getCurrentTask().sentence.punctuation,</span>
                    truthEt,
                    st);

<span class="fc" id="L245">                newSentence.producedByTemporalInduction=temporalInduction;</span>
<span class="fc" id="L246">                newTask = new Task(newSentence, newBudget, getCurrentBelief());</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                if (newTask!=null) {</span>
<span class="fc" id="L248">                    final boolean added = derivedTask(newTask, false, false, overlapAllowed, addToMemory);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                    if(added) {</span>
<span class="fc" id="L250">                        ret.add(newTask);</span>
                    }
                }
            }
<span class="fc" id="L254">            return ret;</span>
        }
<span class="fc" id="L256">        return null;</span>
    }

    /**
     * Shared final operations by all single-premise rules, called in
     * StructuralRules
     *
     * @param newContent The content of the sentence in task
     * @param newTruth The truth value of the sentence in task
     * @param newBudget The budget value in task
     */
    public boolean singlePremiseTask(final Term newContent, final TruthValue newTruth, final BudgetValue newBudget) {
<span class="fc" id="L268">        return singlePremiseTask(newContent, getCurrentTask().sentence.punctuation, newTruth, newBudget);</span>
    }

    /**
     * Shared final operations by all single-premise rules, called in
     * StructuralRules
     *
     * @param newContent The content of the sentence in task
     * @param punctuation The punctuation of the sentence in task
     * @param newTruth The truth value of the sentence in task
     * @param newBudget The budget value in task
     */
    public boolean singlePremiseTask( Term newContent, final char punctuation, final TruthValue newTruth, final BudgetValue newBudget) {
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (!newBudget.aboveThreshold())</span>
<span class="fc" id="L282">            return false;</span>
        
<span class="fc" id="L284">        final Sentence taskSentence = getCurrentTask().sentence;</span>
<span class="fc bfc" id="L285" title="All 6 branches covered.">        if (taskSentence.isGoal() || taskSentence.isJudgment() || getCurrentBelief() == null) {</span>
<span class="fc" id="L286">            setTheNewStamp(new Stamp(taskSentence.stamp, getTime()));</span>
        } else {
            // to answer a question with negation in NAL-5 --- move to activated task?
<span class="fc" id="L289">            setTheNewStamp(new Stamp(getCurrentBelief().stamp, getTime()));</span>
        }
        
<span class="fc bfc" id="L292" title="All 2 branches covered.">        if(newContent.subjectOrPredicateIsIndependentVar()) {</span>
<span class="fc" id="L293">            return false;</span>
        }
        
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if(newContent instanceof Interval) {</span>
<span class="nc" id="L297">            return false;</span>
        }
        
<span class="fc" id="L300">        final Stamp derive_stamp = this.getTheNewStamp().clone();</span>
<span class="fc" id="L301">        this.resetOccurrenceTime(); //stamp was already obsorbed into task</span>

<span class="fc" id="L303">        final Sentence newSentence = new Sentence(</span>
            newContent,
            punctuation,
            newTruth,
            derive_stamp);

<span class="fc" id="L309">        final Task newTask = new Task(newSentence, newBudget, Task.EnumType.DERIVED);</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (newTask!=null) {</span>
<span class="fc" id="L311">            return derivedTask(newTask, false, true, false);</span>
        }
<span class="nc" id="L313">        return false;</span>
    }

    public boolean singlePremiseTask(final Sentence newSentence, final BudgetValue newBudget) {
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (!newBudget.aboveThreshold()) {</span>
<span class="fc" id="L318">            return false;</span>
        }

<span class="fc" id="L321">        final Task newTask = new Task(newSentence, newBudget, Task.EnumType.DERIVED);</span>
<span class="fc" id="L322">        return derivedTask(newTask, false, true, false);</span>
    }

    public long getTime() {
<span class="fc" id="L326">        return time.time();</span>
    }

    public Stamp getNewStamp() {
<span class="nc" id="L330">        return newStamp;</span>
    }

    public void setNewStamp(final Stamp newStamp) {
<span class="nc" id="L334">        this.newStamp = newStamp;</span>
<span class="nc" id="L335">    }</span>

    /**
     * @return the currentTask
     */
    public Task getCurrentTask() {
<span class="fc" id="L341">        return currentTask;</span>
    }

    /**
     * @param currentTask the currentTask to set
     */
    public void setCurrentTask(final Task currentTask) {
<span class="fc" id="L348">        this.currentTask = currentTask;</span>
<span class="fc" id="L349">    }</span>

    public void setCurrentConcept(final Concept currentConcept) {
<span class="fc" id="L352">        this.currentConcept = currentConcept;</span>
<span class="fc" id="L353">    }</span>


<span class="fc" id="L356">    private long original_time = 0;</span>

    /**
     * @return the created stamp
     */
    public Stamp getTheNewStamp() {
<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (newStamp == null) {</span>
            //if newStamp==null then newStampBuilder must be available. cache it's return value as newStamp
<span class="fc" id="L364">            newStamp = newStampBuilder.build();</span>
<span class="fc" id="L365">            original_time = newStamp.getOccurrenceTime();</span>
<span class="fc" id="L366">            newStampBuilder = null;</span>
        }
<span class="fc" id="L368">        return newStamp;</span>
    }
    
    public void resetOccurrenceTime() {
<span class="fc" id="L372">        newStamp.setOccurrenceTime(original_time);</span>
<span class="fc" id="L373">    }</span>

    /**
     * @param newStamp the newStamp to set
     */
    public Stamp setTheNewStamp(final Stamp newStamp) {
<span class="fc" id="L379">        this.newStamp = newStamp;</span>
<span class="fc" id="L380">        this.newStampBuilder = null;</span>
<span class="fc" id="L381">        return newStamp;</span>
    }

    public interface StampBuilder {

        Stamp build();
    }

    /** creates a lazy/deferred StampBuilder which only constructs the stamp if getTheNewStamp() is actually invoked */
    public void setTheNewStamp(final Stamp first, final Stamp second, final long time) {
<span class="fc" id="L391">        newStamp = null;</span>
<span class="fc" id="L392">        newStampBuilder = () -&gt; new Stamp(first, second, time, this.narParameters);</span>
<span class="fc" id="L393">    }</span>

    /**
     * @return the currentBelief
     */
    public Sentence getCurrentBelief() {
<span class="fc" id="L399">        return currentBelief;</span>
    }

    /**
     * @param currentBelief the currentBelief to set
     */
    public void setCurrentBelief(final Sentence currentBelief) {
<span class="fc" id="L406">        this.currentBelief = currentBelief;</span>
<span class="fc" id="L407">    }</span>

    /**
     * @return the currentBeliefLink
     */
    public TermLink getCurrentBeliefLink() {
<span class="fc" id="L413">        return currentBeliefLink;</span>
    }

    /**
     * @param currentBeliefLink the currentBeliefLink to set
     */
    public void setCurrentBeliefLink(final TermLink currentBeliefLink) {
<span class="fc" id="L420">        this.currentBeliefLink = currentBeliefLink;</span>
<span class="fc" id="L421">    }</span>

    /**
     * @return the currentTaskLink
     */
    public TaskLink getCurrentTaskLink() {
<span class="fc" id="L427">        return currentTaskLink;</span>
    }

    /**
     * @param currentTaskLink the currentTaskLink to set
     */
    public void setCurrentTaskLink(final TaskLink currentTaskLink) {
<span class="fc" id="L434">        this.currentTaskLink = currentTaskLink;</span>
<span class="fc" id="L435">    }</span>

    /**
     * @return the currentTerm
     */
    public Term getCurrentTerm() {
<span class="fc" id="L441">        return currentTerm;</span>
    }

    /**
     * @param currentTerm the currentTerm to set
     */
    public void setCurrentTerm(final Term currentTerm) {
<span class="fc" id="L448">        this.currentTerm = currentTerm;</span>
<span class="fc" id="L449">    }</span>

    /**
     * @return the currentConcept
     */
    public Concept getCurrentConcept() {
<span class="fc" id="L455">        return currentConcept;</span>
    }

    public Memory mem() {
<span class="fc" id="L459">        return memory;</span>
    }
    
    /** tasks added with this method will be remembered by this NAL instance; useful for feedback */
    public void addTask(final Task t, final String reason) {
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if(t.sentence.term==null) {</span>
<span class="nc" id="L465">            return;</span>
        }
<span class="fc" id="L467">        memory.addNewTask(t, reason);</span>
<span class="fc" id="L468">    }</span>
    
    /**
     * Activated task called in MatchingRules.trySolution and
     * Concept.processGoal
     *
     * @param budget The budget value of the new Task
     * @param sentence The content of the new Task
     * @param candidateBelief The belief to be used in future inference, for
     * forward/backward correspondence
     */
    public void addTask(final Task currentTask, final BudgetValue budget, final Sentence sentence, final Sentence candidateBelief) {
<span class="fc" id="L480">        addTask(new Task(sentence, budget, sentence, candidateBelief), &quot;Activated&quot;);</span>
<span class="fc" id="L481">    }    </span>
    
    @Override
    public String toString() {
<span class="nc" id="L485">        return &quot;DerivationContext[&quot; + currentConcept + &quot;,&quot; + currentTaskLink + &quot;]&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>