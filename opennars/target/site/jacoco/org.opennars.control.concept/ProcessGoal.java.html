<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProcessGoal.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.control.concept</a> &gt; <span class="el_source">ProcessGoal.java</span></div><h1>ProcessGoal.java</h1><pre class="source lang-java linenums">/*
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.control.concept;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.opennars.control.DerivationContext;
import org.opennars.entity.BudgetValue;
import org.opennars.entity.Concept;
import org.opennars.entity.Sentence;
import org.opennars.entity.Stamp;
import org.opennars.entity.Stamp.BaseEntry;
import org.opennars.entity.Task;
import org.opennars.entity.TruthValue;
import org.opennars.inference.LocalRules;
import static org.opennars.inference.LocalRules.revisible;
import static org.opennars.inference.LocalRules.revision;
import static org.opennars.inference.LocalRules.trySolution;
import org.opennars.inference.TemporalRules;
import org.opennars.inference.TruthFunctions;
import org.opennars.io.Symbols;
import org.opennars.io.events.Events;
import org.opennars.language.CompoundTerm;
import org.opennars.language.Conjunction;
import org.opennars.language.Equivalence;
import org.opennars.language.Implication;
import org.opennars.language.Interval;
import org.opennars.language.Product;
import org.opennars.language.Term;
import org.opennars.language.Variable;
import org.opennars.language.Variables;
import org.opennars.main.Debug;
import org.opennars.operator.FunctionOperator;
import org.opennars.operator.Operation;
import org.opennars.operator.Operator;
import org.opennars.plugin.mental.InternalExperience;

/**
 *
 * @author Patrick Hammer
 */
<span class="nc" id="L67">public class ProcessGoal {</span>
    /**
     * To accept a new goal, and check for revisions and realization, then
     * decide whether to actively pursue it, potentially executing in case of an operation goal
     *
     * @param concept The concept of the goal
     * @param nal The derivation context
     * @param task The goal task to be processed
     */
    protected static void processGoal(final Concept concept, final DerivationContext nal, final Task task) {
<span class="fc" id="L77">        final Sentence goal = task.sentence;</span>
<span class="fc" id="L78">        final Task oldGoalT = concept.selectCandidate(task, concept.desires, nal.time); // revise with the existing desire values</span>
<span class="fc" id="L79">        Sentence oldGoal = null;</span>
<span class="fc" id="L80">        final Stamp newStamp = goal.stamp;</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        if (oldGoalT != null) {</span>
<span class="fc" id="L82">            oldGoal = oldGoalT.sentence;</span>
<span class="fc" id="L83">            final Stamp oldStamp = oldGoal.stamp;</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            if (newStamp.equals(oldStamp,false,false,true)) {</span>
<span class="fc" id="L85">                return; // duplicate</span>
            }
        }

<span class="fc" id="L89">        Task beliefT = null;</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if(task.aboveThreshold()) {</span>
<span class="fc" id="L91">            beliefT = concept.selectCandidate(task, concept.beliefs, nal.time);</span>

<span class="pc bpc" id="L93" title="1 of 2 branches missed.">            for (final Task iQuest : concept.quests ) {</span>
<span class="nc" id="L94">                trySolution(task.sentence, iQuest, nal, true);</span>
<span class="nc" id="L95">            }</span>

            // check if the Goal is already satisfied
<span class="fc bfc" id="L98" title="All 2 branches covered.">            if (beliefT != null) {</span>
                // check if the Goal is already satisfied (manipulate budget)
<span class="fc" id="L100">                trySolution(beliefT.sentence, task, nal, true);</span>
            }
        }

<span class="fc bfc" id="L104" title="All 4 branches covered.">        if (oldGoalT != null &amp;&amp; revisible(goal, oldGoal, nal.narParameters)) {</span>
<span class="fc" id="L105">            final Stamp oldStamp = oldGoal.stamp;</span>
<span class="fc" id="L106">            nal.setTheNewStamp(newStamp, oldStamp, nal.time.time());</span>
<span class="fc" id="L107">            final Sentence projectedGoal = oldGoal.projection(task.sentence.getOccurenceTime(), newStamp.getOccurrenceTime(), concept.memory);</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">            if (projectedGoal!=null) {</span>
<span class="fc" id="L109">                nal.setCurrentBelief(projectedGoal);</span>
<span class="fc" id="L110">                final boolean wasRevised = revision(task.sentence, projectedGoal, concept, false, nal);</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">                if (wasRevised) {</span>
                    /* It was revised, so there is a new task for which this method will be called
                     * with higher/lower desire.
                     * We return because it is not allowed to go on directly due to decision making.
                     * see https://groups.google.com/forum/#!topic/open-nars/lQD0no2ovx4
                     */
<span class="fc" id="L117">                    return;</span>
                }
            }
        }

<span class="fc" id="L122">        final Stamp s2=goal.stamp.clone();</span>
<span class="fc" id="L123">        s2.setOccurrenceTime(nal.time.time());</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if(s2.after(task.sentence.stamp, nal.narParameters.DURATION)) {</span>
            // this task is not up to date we have to project it first

<span class="fc" id="L127">            final Sentence projGoal = task.sentence.projection(nal.time.time(), nal.narParameters.DURATION, nal.memory);</span>
<span class="pc bpc" id="L128" title="1 of 4 branches missed.">            if(projGoal!=null &amp;&amp; projGoal.truth.getExpectation() &gt; nal.narParameters.DECISION_THRESHOLD) {</span>

                // keep goal updated
<span class="fc" id="L131">                nal.singlePremiseTask(projGoal, task.budget.clone());</span>

                // we don't return here, allowing &quot;roundtrips now&quot;, relevant for executing multiple steps of learned implication chains
            }
        }


<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (!task.aboveThreshold()) {</span>
<span class="fc" id="L139">            return;</span>
        }

<span class="fc" id="L142">        double AntiSatisfaction = 0.5f; // we dont know anything about that goal yet</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (beliefT != null) {</span>
<span class="fc" id="L144">            final Sentence belief = beliefT.sentence;</span>
<span class="fc" id="L145">            final Sentence projectedBelief = belief.projection(task.sentence.getOccurenceTime(), nal.narParameters.DURATION, nal.memory);</span>
<span class="fc" id="L146">            AntiSatisfaction = task.sentence.truth.getExpDifAbs(projectedBelief.truth);</span>
        }

<span class="fc" id="L149">        task.setPriority(task.getPriority()* (float)AntiSatisfaction);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (!task.aboveThreshold()) {</span>
<span class="fc" id="L151">            return;</span>
        }

<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        final boolean isFullfilled = AntiSatisfaction &lt; nal.narParameters.SATISFACTION_TRESHOLD;</span>
<span class="fc" id="L155">        final Sentence projectedGoal = goal.projection(nal.time.time(), nal.time.time(), nal.memory);</span>
<span class="pc bpc" id="L156" title="3 of 6 branches missed.">        if (!(projectedGoal != null &amp;&amp; task.aboveThreshold() &amp;&amp; !isFullfilled)) {</span>
<span class="nc" id="L157">            return;</span>
        }
<span class="pc bpc" id="L159" title="1 of 4 branches missed.">        final boolean inhitedBabblingGoal = task.isInput() &amp;&amp; !concept.allowBabbling;</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if(inhitedBabblingGoal) {</span>
<span class="nc" id="L161">            return;</span>
        }
<span class="fc" id="L163">        bestReactionForGoal(concept, nal, projectedGoal, task);</span>
<span class="fc" id="L164">        questionFromGoal(task, nal);</span>
<span class="fc" id="L165">        concept.addToTable(task, false, concept.desires, nal.narParameters.CONCEPT_GOALS_MAX, Events.ConceptGoalAdd.class, Events.ConceptGoalRemove.class);</span>
<span class="fc" id="L166">        InternalExperience.InternalExperienceFromTask(concept.memory, task, false, nal.time);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if(!(task.sentence.getTerm() instanceof Operation)) {</span>
<span class="fc" id="L168">            return;</span>
        }
<span class="fc" id="L170">        processOperationGoal(projectedGoal, nal, concept, oldGoalT, task);</span>
<span class="fc" id="L171">    }</span>

    /**
     * To process an operation for potential execution
     * only called by processGoal
     *
     * @param projectedGoal The current goal
     * @param nal The derivation context
     * @param concept The concept of the current goal
     * @param oldGoalT The best goal in the goal table
     * @param task The goal task
     */
    protected static void processOperationGoal(final Sentence projectedGoal, final DerivationContext nal, final Concept concept, final Task oldGoalT, final Task task) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if(projectedGoal.truth.getExpectation() &gt; nal.narParameters.DECISION_THRESHOLD) {</span>
            //see whether the goal evidence is fully included in the old goal, if yes don't execute
            //as execution for this reason already happened (or did not since there was evidence against it)
<span class="fc" id="L187">            final Set&lt;BaseEntry&gt; oldEvidence = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L188">            boolean Subset=false;</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if(oldGoalT != null) {</span>
<span class="fc" id="L190">                Subset = true;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">                for(final BaseEntry l: oldGoalT.sentence.stamp.evidentialBase) {</span>
<span class="fc" id="L192">                    oldEvidence.add(l);</span>
                }
<span class="fc bfc" id="L194" title="All 2 branches covered.">                for(final BaseEntry l: task.sentence.stamp.evidentialBase) {</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">                    if(!oldEvidence.contains(l)) {</span>
<span class="fc" id="L196">                        Subset = false;</span>
<span class="fc" id="L197">                        break;</span>
                    }
                }
            }
<span class="fc bfc" id="L201" title="All 4 branches covered.">            if(!Subset &amp;&amp; !executeOperation(nal, task)) {</span>
<span class="fc" id="L202">                concept.memory.emit(Events.UnexecutableGoal.class, task, concept, nal);</span>
<span class="fc" id="L203">                return; //it was made true by itself</span>
            }
        }
<span class="fc" id="L206">    }</span>

    /**
     * Generate &amp;lt;?how =/&amp;gt; g&amp;gt;? question for g! goal.
     * only called by processGoal
     *
     * @param task the task for which the question should be processed
     * @param nal The derivation context
     */
    public static void questionFromGoal(final Task task, final DerivationContext nal) {
<span class="pc bpc" id="L216" title="2 of 4 branches missed.">        if(nal.narParameters.QUESTION_GENERATION_ON_DECISION_MAKING || nal.narParameters.HOW_QUESTION_GENERATION_ON_DECISION_MAKING) {</span>
            //ok, how can we achieve it? add a question of whether it is fullfilled
<span class="nc" id="L218">            final List&lt;Term&gt; qu= new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if(nal.narParameters.HOW_QUESTION_GENERATION_ON_DECISION_MAKING) {</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">                if(!(task.sentence.term instanceof Equivalence) &amp;&amp; !(task.sentence.term instanceof Implication)) {</span>
<span class="nc" id="L221">                    final Variable how=new Variable(&quot;?how&quot;);</span>
                    //Implication imp=Implication.make(how, task.sentence.term, TemporalRules.ORDER_CONCURRENT);
<span class="nc" id="L223">                    final Implication imp2=Implication.make(how, task.sentence.term, TemporalRules.ORDER_FORWARD);</span>
                    //qu.add(imp);
<span class="nc bnc" id="L225" title="All 2 branches missed.">                    if(!(task.sentence.term instanceof Operation)) {</span>
<span class="nc" id="L226">                        qu.add(imp2);</span>
                    }
                }
            }
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if(nal.narParameters.QUESTION_GENERATION_ON_DECISION_MAKING) {</span>
<span class="nc" id="L231">                qu.add(task.sentence.term);</span>
            }
<span class="nc bnc" id="L233" title="All 2 branches missed.">            for(final Term q : qu) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                if(q!=null) {</span>
<span class="nc" id="L235">                    final Stamp st = new Stamp(task.sentence.stamp, nal.time.time());</span>
<span class="nc" id="L236">                    st.setOccurrenceTime(task.sentence.getOccurenceTime()); //set tense of question to goal tense</span>
<span class="nc" id="L237">                    final Sentence s = new Sentence(</span>
                        q,
                        Symbols.QUESTION_MARK,
                        null,
                        st);

<span class="nc bnc" id="L243" title="All 2 branches missed.">                    if(s!=null) {</span>
<span class="nc" id="L244">                        final BudgetValue budget=new BudgetValue(task.getPriority()*nal.narParameters.CURIOSITY_DESIRE_PRIORITY_MUL,</span>
<span class="nc" id="L245">                            task.getDurability()*nal.narParameters.CURIOSITY_DESIRE_DURABILITY_MUL,</span>
                            1, nal.narParameters);
<span class="nc" id="L247">                        nal.singlePremiseTask(s, budget);</span>
                    }
                }
<span class="nc" id="L250">            }</span>
        }
<span class="fc" id="L252">    }</span>

<span class="fc" id="L254">    private static class ExecutablePrecondition {</span>
<span class="fc" id="L255">        public Operation bestop = null;</span>
<span class="fc" id="L256">        public float bestop_truthexp = 0.0f;</span>
<span class="fc" id="L257">        public TruthValue bestop_truth = null;</span>
<span class="fc" id="L258">        public Task executable_precond = null;</span>
<span class="fc" id="L259">        public long mintime = -1;</span>
<span class="fc" id="L260">        public long maxtime = -1;</span>
        public float timeOffset;
        public Map&lt;Term,Term&gt; substitution;
    }

    /**
     * When a goal is processed, use the best memorized reaction
     * that is applicable to the current context (recent events) in case that it exists.
     * This is a special case of the choice rule and allows certain behaviors to be automated.
     *
     * @param concept The concept of the goal to realize
     * @param nal The derivation context
     * @param projectedGoal The current goal
     * @param task The goal task
     */
    public static void bestReactionForGoal(final Concept concept, final DerivationContext nal, final Sentence projectedGoal, final Task task) {
<span class="fc" id="L276">        concept.incAcquiredQuality(); //useful as it is represents a goal concept that can hold important procedure knowledge</span>
        //1. pull up variable based preconditions from component concepts without replacing them
<span class="fc" id="L278">        Map&lt;Term, Integer&gt; ret = (projectedGoal.getTerm()).countTermRecursively(null);</span>
<span class="fc" id="L279">        List&lt;Task&gt; generalPreconditions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for(Term t : ret.keySet()) {</span>
<span class="fc" id="L281">            final Concept get_concept = nal.memory.concept(t); //the concept to pull preconditions from</span>
<span class="fc bfc" id="L282" title="All 4 branches covered.">            if(get_concept == null || get_concept == concept) { //target concept does not exist or is the same as the goal concept</span>
<span class="fc" id="L283">                continue;</span>
            }
            //pull variable based preconditions from component concepts
<span class="fc" id="L286">            synchronized(get_concept) {</span>
<span class="fc" id="L287">                boolean useful_component = false;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">                for(Task precon : get_concept.general_executable_preconditions) {</span>
                    //check whether the conclusion matches
<span class="fc bfc" id="L290" title="All 2 branches covered.">                    if(Variables.findSubstitute(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT, ((Implication)precon.sentence.term).getPredicate(), projectedGoal.term, new LinkedHashMap&lt;&gt;(), new LinkedHashMap&lt;&gt;())) {</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">                        for(Task prec : get_concept.general_executable_preconditions) {</span>
<span class="fc" id="L292">                            generalPreconditions.add(prec);</span>
<span class="fc" id="L293">                            useful_component = true;</span>
<span class="fc" id="L294">                        }</span>
                    }
<span class="fc" id="L296">                }</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">                if(useful_component) {</span>
<span class="fc" id="L298">                    get_concept.incAcquiredQuality(); //useful as it contributed predictive hypotheses</span>
                }
<span class="fc" id="L300">            }</span>
<span class="fc" id="L301">        }</span>
        //2. Accumulate all general preconditions of itself too and create list for anticipations
<span class="fc" id="L303">        generalPreconditions.addAll(concept.general_executable_preconditions);</span>
<span class="fc" id="L304">        Map&lt;Operation,List&lt;ExecutablePrecondition&gt;&gt; anticipationsToMake = new LinkedHashMap&lt;&gt;();</span>
        //3. For the more specific hypotheses first and then the general
<span class="fc bfc" id="L306" title="All 2 branches covered.">        for(List&lt;Task&gt; table : new List[] {concept.executable_preconditions, generalPreconditions}) {</span>
            //4. Apply choice rule, using the highest truth expectation solution and anticipate the results
<span class="fc" id="L308">            ExecutablePrecondition bestOpWithMeta = calcBestExecutablePrecondition(nal, concept, projectedGoal, table, anticipationsToMake);</span>
            //5. And executing it, also forming an expectation about the result
<span class="fc bfc" id="L310" title="All 2 branches covered.">            if(executePrecondition(nal, bestOpWithMeta, concept, projectedGoal, task)) {</span>
<span class="fc" id="L311">                Concept op = nal.memory.concept(bestOpWithMeta.bestop);</span>
<span class="pc bpc" id="L312" title="1 of 4 branches missed.">                if(op != null &amp;&amp; bestOpWithMeta.executable_precond.sentence.truth.getConfidence() &gt; nal.narParameters.MOTOR_BABBLING_CONFIDENCE_THRESHOLD) {</span>
<span class="fc" id="L313">                    synchronized(op) {</span>
<span class="fc" id="L314">                        op.allowBabbling = false;</span>
<span class="fc" id="L315">                    }</span>
                }
<span class="fc" id="L317">                System.out.println(&quot;Executed based on: &quot; + bestOpWithMeta.executable_precond);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">                for(ExecutablePrecondition precon : anticipationsToMake.get(bestOpWithMeta.bestop)) {</span>
<span class="fc" id="L319">                    float distance = precon.timeOffset - nal.time.time();</span>
<span class="fc" id="L320">                    float urgency = 2.0f + 1.0f/distance;</span>

<span class="fc" id="L322">                    ProcessAnticipation.anticipate(nal, precon.executable_precond.sentence, precon.executable_precond.budget, precon.mintime, precon.maxtime, urgency, precon.substitution);</span>
<span class="fc" id="L323">                }</span>
<span class="fc" id="L324">                return; //don't try the other table as a specific solution was already used</span>
            }
        }
<span class="fc" id="L327">    }</span>

    /**
     * Search for the best precondition that best matches recent events, and is most successful in leading to goal fulfilment
     *
     * @param nal The derivation context
     * @param concept The goal concept
     * @param projectedGoal The goal projected to the current time
     * @param execPreconditions The procedural hypotheses with the executable preconditions
     * @return The procedural hypothesis with the highest result truth expectation
     */
    private static ExecutablePrecondition calcBestExecutablePrecondition(final DerivationContext nal, final Concept concept, final Sentence projectedGoal, List&lt;Task&gt; execPreconditions, Map&lt;Operation,List&lt;ExecutablePrecondition&gt;&gt; anticipationsToMake) {
<span class="fc" id="L339">        ExecutablePrecondition result = new ExecutablePrecondition();</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">        for(final Task t: execPreconditions) {</span>
<span class="fc" id="L341">            final CompoundTerm precTerm = ((Conjunction) ((Implication) t.getTerm()).getSubject());</span>
<span class="fc" id="L342">            final Term[] prec = precTerm.term;</span>
<span class="fc" id="L343">            final Term[] newprec = new Term[prec.length-3];</span>
<span class="fc" id="L344">            System.arraycopy(prec, 0, newprec, 0, prec.length - 3);</span>
<span class="fc" id="L345">            float timeOffset = (long) (((Interval)prec[prec.length-1]).time);</span>
<span class="fc" id="L346">            float timeWindowHalf = timeOffset * nal.narParameters.ANTICIPATION_TOLERANCE;</span>
<span class="fc" id="L347">            final Operation op = (Operation) prec[prec.length-2];</span>
<span class="fc" id="L348">            final Term precondition = Conjunction.make(newprec,TemporalRules.ORDER_FORWARD);</span>
<span class="fc" id="L349">            long newesttime = -1;</span>
<span class="fc" id="L350">            Task bestsofar = null;</span>
<span class="fc" id="L351">            List&lt;Float&gt; prec_intervals = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            for(Long l : CompoundTerm.extractIntervals(nal.memory, precTerm)) {</span>
<span class="fc" id="L353">                prec_intervals.add((float) l);</span>
<span class="fc" id="L354">            }</span>
<span class="fc" id="L355">            Map&lt;Term,Term&gt; subsconc = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L356">            boolean conclusionMatches = Variables.findSubstitute(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT,</span>
<span class="fc" id="L357">                            CompoundTerm.replaceIntervals(((Implication) t.getTerm()).getPredicate()),</span>
<span class="fc" id="L358">                            CompoundTerm.replaceIntervals(projectedGoal.getTerm()), subsconc, new LinkedHashMap&lt;&gt;());</span>
            //ok we can look now how much it is fullfilled
            //check recent events in event bag
<span class="fc" id="L361">            Map&lt;Term,Term&gt; subsBest = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L362">            synchronized(concept.memory.seq_current) {</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">                for(final Task p : concept.memory.seq_current) {</span>
<span class="pc bpc" id="L364" title="3 of 8 branches missed.">                    if(p.sentence.isJudgment() &amp;&amp; !p.sentence.isEternal() &amp;&amp; p.sentence.getOccurenceTime() &gt; newesttime &amp;&amp; p.sentence.getOccurenceTime() &lt;= nal.time.time()) {</span>
<span class="fc" id="L365">                        Map&lt;Term,Term&gt; subs = new LinkedHashMap&lt;&gt;(subsconc);</span>
<span class="fc" id="L366">                        boolean preconditionMatches = Variables.findSubstitute(nal.memory.randomNumber, Symbols.VAR_INDEPENDENT,</span>
<span class="fc" id="L367">                            CompoundTerm.replaceIntervals(precondition),</span>
<span class="fc" id="L368">                            CompoundTerm.replaceIntervals(p.sentence.term), subs, new LinkedHashMap&lt;&gt;());</span>
<span class="pc bpc" id="L369" title="1 of 4 branches missed.">                        if(preconditionMatches &amp;&amp; conclusionMatches){</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">                            Task pNew = new Task(p.sentence.clone(), p.budget.clone(), p.isInput() ? Task.EnumType.INPUT : Task.EnumType.DERIVED);</span>
<span class="fc" id="L371">                            newesttime = p.sentence.getOccurenceTime();</span>
                            //Apply interval penalty for interval differences in the precondition
<span class="fc" id="L373">                            LocalRules.intervalProjection(nal, pNew.sentence.term, precondition, prec_intervals, pNew.sentence.truth);</span>
<span class="fc" id="L374">                            bestsofar = pNew;</span>
<span class="fc" id="L375">                            subsBest = subs;</span>
                        }
                    }
<span class="fc" id="L378">                }</span>
<span class="fc" id="L379">            }</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            if(bestsofar == null) {</span>
<span class="fc" id="L381">                continue;</span>
            }
            //ok now we can take the desire value:
<span class="fc" id="L384">            final TruthValue A = projectedGoal.getTruth();</span>
            //and the truth of the hypothesis:
<span class="fc" id="L386">            final TruthValue Hyp = t.sentence.truth;</span>
            //and derive the conjunction of the left side:
<span class="fc" id="L388">            final TruthValue leftside = TruthFunctions.desireDed(A, Hyp, concept.memory.narParameters);</span>
            //overlap will almost never happen, but to make sure
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">            if(Stamp.baseOverlap(projectedGoal.stamp, t.sentence.stamp) ||</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">                Stamp.baseOverlap(bestsofar.sentence.stamp, t.sentence.stamp) ||</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">                Stamp.baseOverlap(projectedGoal.stamp, bestsofar.sentence.stamp)) {</span>
<span class="nc" id="L393">                continue;</span>
            }
            //and the truth of the precondition:
<span class="fc" id="L396">            final Sentence projectedPrecon = bestsofar.sentence.projection(nal.time.time() /*- distance*/, nal.time.time(), concept.memory);</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">            if(projectedPrecon.isEternal()) {</span>
<span class="nc" id="L398">                continue; //projection wasn't better than eternalization, too long in the past</span>
            }
<span class="fc" id="L400">            final TruthValue precon = projectedPrecon.truth;</span>

            //in order to derive the operator desire value:
<span class="fc" id="L403">            final TruthValue opdesire = TruthFunctions.desireDed(precon, leftside, concept.memory.narParameters);</span>
<span class="fc" id="L404">            final float expecdesire = opdesire.getExpectation();</span>
<span class="fc" id="L405">            Operation bestop = (Operation) ((CompoundTerm)op).applySubstitute(subsBest);</span>
<span class="fc" id="L406">            long mintime = (long) (nal.time.time() + timeOffset - timeWindowHalf);</span>
<span class="fc" id="L407">            long maxtime = (long) (nal.time.time() + timeOffset + timeWindowHalf);</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">            if(expecdesire &gt; result.bestop_truthexp) {</span>
<span class="fc" id="L409">                result.bestop = bestop;</span>
<span class="fc" id="L410">                result.bestop_truthexp = expecdesire;</span>
<span class="fc" id="L411">                result.bestop_truth = opdesire;</span>
<span class="fc" id="L412">                result.executable_precond = t;</span>
<span class="fc" id="L413">                result.substitution = subsBest;</span>
<span class="fc" id="L414">                result.mintime = mintime;</span>
<span class="fc" id="L415">                result.maxtime = maxtime;</span>
<span class="fc" id="L416">                result.timeOffset = timeOffset;</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">                if(anticipationsToMake.get(result.bestop) == null) {</span>
<span class="fc" id="L418">                    anticipationsToMake.put(result.bestop, new ArrayList&lt;ExecutablePrecondition&gt;());</span>
                }
<span class="fc" id="L420">                anticipationsToMake.get(result.bestop).add(result);</span>
            }
<span class="fc" id="L422">        }</span>
<span class="fc" id="L423">        return result;</span>
    }

    /**
     * Execute the operation suggested by the most applicable precondition
     *
     * @param nal The derivation context
     * @param precon The procedural hypothesis leading to goal
     * @param concept The concept of the goal
     * @param projectedGoal The goal projected to the current time
     * @param task The goal task
     */
    private static boolean executePrecondition(final DerivationContext nal, ExecutablePrecondition precon, final Concept concept, final Sentence projectedGoal, final Task task) {
<span class="pc bpc" id="L436" title="1 of 4 branches missed.">        if(precon.bestop != null &amp;&amp; precon.bestop_truthexp &gt; nal.narParameters.DECISION_THRESHOLD /*&amp;&amp; Math.random() &lt; bestop_truthexp */) {</span>
<span class="fc" id="L437">            final Sentence createdSentence = new Sentence(</span>
                precon.bestop,
                Symbols.GOAL_MARK,
                precon.bestop_truth,
                projectedGoal.stamp);
<span class="fc" id="L442">            final Task t = new Task(createdSentence,</span>
                new BudgetValue(1.0f,1.0f,1.0f, nal.narParameters),
                Task.EnumType.DERIVED);
            //System.out.println(&quot;used &quot; +t.getTerm().toString() + String.valueOf(nal.memory.randomNumber.nextInt()));
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            if(!task.sentence.stamp.evidenceIsCyclic()) {</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">                if(!executeOperation(nal, t)) { //this task is just used as dummy</span>
<span class="nc" id="L448">                    concept.memory.emit(Events.UnexecutableGoal.class, task, concept, nal);</span>
<span class="nc" id="L449">                    return false;</span>
                }
<span class="fc" id="L451">                return true;</span>
            }
        }
<span class="fc" id="L454">        return false;</span>
    }

    /**
     * Entry point for all potentially executable operation tasks.
     * Returns true if the Task has a Term which can be executed
     *
     * @param nal The derivation concept
     * @param t The operation goal task
     */
    public static boolean executeOperation(final DerivationContext nal, final Task t) {
<span class="fc" id="L465">        final Term content = t.getTerm();</span>
<span class="pc bpc" id="L466" title="2 of 4 branches missed.">        if(!(nal.memory.allowExecution) || !(content instanceof Operation)) {</span>
<span class="nc" id="L467">            return false;</span>
        }
<span class="fc" id="L469">        final Operation op=(Operation)content;</span>
<span class="fc" id="L470">        final Operator oper = op.getOperator();</span>
<span class="fc" id="L471">        final Product prod = (Product) op.getSubject();</span>
<span class="fc" id="L472">        final Term arg = prod.term[0];</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if(oper instanceof FunctionOperator) {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">            for(int i=0;i&lt;prod.term.length-1;i++) { //except last one, the output arg</span>
<span class="pc bpc" id="L475" title="1 of 4 branches missed.">                if(prod.term[i].hasVarDep() || prod.term[i].hasVarIndep()) {</span>
<span class="fc" id="L476">                    return false;</span>
                }
            }
        } else {
<span class="pc bpc" id="L480" title="1 of 4 branches missed.">            if(content.hasVarDep() || content.hasVarIndep()) {</span>
<span class="fc" id="L481">                return false;</span>
            }
        }
<span class="fc bfc" id="L484" title="All 2 branches covered.">        if(!arg.equals(Term.SELF)) { //will be deprecated in the future</span>
<span class="fc" id="L485">            return false;</span>
        }

<span class="fc" id="L488">        op.setTask(t);</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">        if(!oper.call(op, nal.memory, nal.time)) {</span>
<span class="fc" id="L490">            return false;</span>
        }
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">        if (Debug.DETAILED) {</span>
<span class="nc" id="L493">            System.out.println(t.toStringLong());</span>
        }
<span class="fc" id="L495">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>