<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProcessAnticipation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.control.concept</a> &gt; <span class="el_source">ProcessAnticipation.java</span></div><h1>ProcessAnticipation.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.control.concept;

import java.util.*;

import org.opennars.control.DerivationContext;
import org.opennars.entity.BudgetValue;
import org.opennars.entity.Concept;
import org.opennars.entity.Sentence;
import org.opennars.entity.Stamp;
import org.opennars.entity.Task;
import org.opennars.entity.TaskLink;
import org.opennars.entity.TermLink;
import org.opennars.entity.TruthValue;
import org.opennars.inference.RuleTables;
import org.opennars.inference.TemporalRules;
import org.opennars.interfaces.Timable;
import org.opennars.io.Symbols;
import org.opennars.io.events.OutputHandler;
import org.opennars.language.*;
import org.opennars.main.Nar;
import org.opennars.main.Parameters;
import org.opennars.operator.Operator;
import org.opennars.operator.mental.Anticipate;

import static org.opennars.inference.UtilityFunctions.c2w;
import static org.opennars.inference.UtilityFunctions.w2c;

/**
 *
 * @author Patrick Hammer
 */
<span class="nc" id="L55">public class ProcessAnticipation {</span>

    public static void anticipate(final DerivationContext nal, final Sentence mainSentence, final BudgetValue budget, 
            final long mintime, final long maxtime, final float urgency, Map&lt;Term,Term&gt; substitution) {
        //derivation was successful and it was a judgment event
<span class="fc" id="L60">        final Stamp stamp = new Stamp(nal.time, nal.memory);</span>
<span class="fc" id="L61">        stamp.setOccurrenceTime(Stamp.ETERNAL);</span>
<span class="fc" id="L62">        float eternalized_induction_confidence = nal.memory.narParameters.ANTICIPATION_CONFIDENCE;</span>
<span class="fc" id="L63">        final Sentence s = new Sentence(</span>
            mainSentence.term,
            mainSentence.punctuation,
            new TruthValue(0.0f, eternalized_induction_confidence, nal.narParameters),
            stamp);
<span class="fc" id="L68">        final Task t = new Task(s, new BudgetValue(0.99f,0.1f,0.1f, nal.narParameters), Task.EnumType.DERIVED); //Budget for one-time processing</span>
<span class="fc" id="L69">        Term specificAnticipationTerm = ((CompoundTerm)((Statement) mainSentence.term).getPredicate()).applySubstitute(substitution);</span>
<span class="fc" id="L70">        final Concept c = nal.memory.concept(specificAnticipationTerm); //put into consequence concept</span>
<span class="pc bpc" id="L71" title="4 of 8 branches missed.">        if(c != null /*&amp;&amp; mintime &gt; nal.memory.time()*/ &amp;&amp; c.observable &amp;&amp; (mainSentence.getTerm() instanceof Implication || mainSentence.getTerm() instanceof Equivalence) &amp;&amp; </span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">                mainSentence.getTerm().getTemporalOrder() == TemporalRules.ORDER_FORWARD) {</span>
<span class="fc" id="L73">            Concept.AnticipationEntry toDelete = null;</span>
<span class="fc" id="L74">            Concept.AnticipationEntry toInsert = new Concept.AnticipationEntry(urgency, t, mintime, maxtime);</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">            boolean fullCapacity = c.anticipations.size() &gt;= nal.narParameters.ANTICIPATIONS_PER_CONCEPT_MAX;</span>
            //choose an element to replace with the new, in case that we are already at full capacity
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">            if(fullCapacity) {</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">                for(Concept.AnticipationEntry entry : c.anticipations) {</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">                    if(urgency &gt; entry.negConfirmationPriority /*|| t.getPriority() &gt; c.negConfirmation.getPriority() */) {</span>
                        //prefer to replace one that is more far in the future, takes longer to be disappointed about
<span class="nc bnc" id="L81" title="All 4 branches missed.">                        if(toDelete == null || entry.negConfirm_abort_maxtime &gt; toDelete.negConfirm_abort_maxtime) {</span>
<span class="nc" id="L82">                            toDelete = entry;</span>
                        }
                    }
<span class="nc" id="L85">                }</span>
            }
            //we were at full capacity but there was no item that can be replaced with the new one
<span class="pc bpc" id="L88" title="3 of 4 branches missed.">            if(fullCapacity &amp;&amp; toDelete == null) {</span>
<span class="nc" id="L89">                return;</span>
            }
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">            if(toDelete != null) {</span>
<span class="nc" id="L92">                c.anticipations.remove(toDelete);</span>
            }
<span class="fc" id="L94">            c.anticipations.add(toInsert);</span>
<span class="fc" id="L95">            final Statement impOrEqu = (Statement) toInsert.negConfirmation.sentence.term;</span>
<span class="fc" id="L96">            final Concept ctarget = nal.memory.concept(impOrEqu.getPredicate());</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">            if(ctarget != null) {</span>
<span class="fc" id="L98">                Operator anticipate_op = ((Anticipate)c.memory.getOperator(&quot;^anticipate&quot;));</span>
<span class="pc bpc" id="L99" title="2 of 4 branches missed.">                if(anticipate_op != null &amp;&amp; anticipate_op instanceof Anticipate) {</span>
<span class="fc" id="L100">                    ((Anticipate)anticipate_op).anticipationFeedback(impOrEqu.getPredicate(), null, c.memory, nal.time);</span>
                }
            }
<span class="fc" id="L103">            nal.memory.emit(OutputHandler.ANTICIPATE.class, specificAnticipationTerm); //disappoint/confirm printed anyway</span>
        }
   
<span class="fc" id="L106">    }</span>

    /**
     * Process outdated anticipations within the concept,
     * these which are outdated generate negative feedback
     * 
     * @param narParameters The reasoner parameters
     * @param concept The concept which potentially outdated anticipations should be processed
     * @param nar the reasoner
     */
    public static void maintainDisappointedAnticipations(final Parameters narParameters, final Concept concept, final Nar nar) {
        //here we can check the expiration of the feedback:
<span class="fc" id="L118">        List&lt;Concept.AnticipationEntry&gt; confirmed = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L119">        List&lt;Concept.AnticipationEntry&gt; disappointed = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        for(Concept.AnticipationEntry entry : concept.anticipations) {</span>
<span class="pc bpc" id="L121" title="1 of 4 branches missed.">            if(entry.negConfirmation == null || nar.time() &lt;= entry.negConfirm_abort_maxtime) {</span>
<span class="fc" id="L122">                continue;</span>
            }
            //at first search beliefs for input tasks:
<span class="fc" id="L125">            boolean gotConfirmed = false;</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">            if(narParameters.RETROSPECTIVE_ANTICIPATIONS) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                for(final TaskLink tl : concept.taskLinks) { //search for input in tasklinks (beliefs alone can not take temporality into account as the eternals will win)</span>
<span class="nc" id="L128">                    final Task t = tl.targetTask;</span>
<span class="nc bnc" id="L129" title="All 8 branches missed.">                    if(t!= null &amp;&amp; t.sentence.isJudgment() &amp;&amp; /*t.isInput() &amp;&amp;*/ !t.sentence.isEternal() &amp;&amp; t.sentence.truth.getExpectation() &gt; concept.memory.narParameters.DEFAULT_CONFIRMATION_EXPECTATION &amp;&amp;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">                            CompoundTerm.replaceIntervals(t.sentence.term).equals(CompoundTerm.replaceIntervals(concept.getTerm()))) {</span>
<span class="nc bnc" id="L131" title="All 4 branches missed.">                        if(t.sentence.getOccurenceTime() &gt;= entry.negConfirm_abort_mintime &amp;&amp; t.sentence.getOccurenceTime() &lt;= entry.negConfirm_abort_maxtime) {</span>
<span class="nc" id="L132">                            confirmed.add(entry);</span>
<span class="nc" id="L133">                            gotConfirmed = true;</span>
<span class="nc" id="L134">                            break;</span>
                        }
                    }
<span class="nc" id="L137">                }</span>
            }
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">            if(!gotConfirmed) {</span>
<span class="fc" id="L140">                disappointed.add(entry);</span>
            }
<span class="fc" id="L142">        }</span>
        //confirmed by input, nothing to do
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if(confirmed.size() &gt; 0) {</span>
<span class="nc" id="L145">            concept.memory.emit(OutputHandler.CONFIRM.class,concept.getTerm());</span>
        }
<span class="fc" id="L147">        concept.anticipations.removeAll(confirmed);</span>
        //not confirmed and time is out, generate disappointment
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if(disappointed.size() &gt; 0) {</span>
<span class="fc" id="L150">            concept.memory.emit(OutputHandler.DISAPPOINT.class,concept.getTerm());</span>
        }
<span class="fc bfc" id="L152" title="All 2 branches covered.">        for(Concept.AnticipationEntry entry : disappointed) {</span>
<span class="fc" id="L153">            final Term term = entry.negConfirmation.getTerm();</span>
<span class="fc" id="L154">            final Term termWithRplacedIntervals = CompoundTerm.replaceIntervals(term);</span>

            { // revise with negative evidence
<span class="fc" id="L157">                TruthValue truthOfBeliefWithTerm = null;</span>
                {
<span class="fc" id="L159">                    final Concept targetConcept = nar.memory.concept(termWithRplacedIntervals);</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">                    if (targetConcept == null) { // target concept does not exist</span>
<span class="nc" id="L161">                        continue;</span>
                    }

<span class="fc" id="L164">                    synchronized (targetConcept) {</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">                        for( final Task iBeliefTask : targetConcept.beliefs ) {</span>
<span class="fc" id="L166">                            Term iBeliefTerm = iBeliefTask.getTerm();</span>

<span class="fc" id="L168">                            boolean found = iBeliefTerm.equals(term);</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">                            if (found) {</span>
<span class="fc" id="L170">                                truthOfBeliefWithTerm = iBeliefTask.sentence.truth;</span>
<span class="fc" id="L171">                                break;</span>
                            }
<span class="nc" id="L173">                        }</span>
<span class="fc" id="L174">                    }</span>
                }



<span class="pc bpc" id="L179" title="1 of 2 branches missed.">                if(truthOfBeliefWithTerm != null) {</span>
                    // compute amount of negative evidence based on current evidence
                    // we just take the counter and don't add one because we want to compute a w &quot;unit&quot; which will be revised
<span class="fc" id="L182">                    long countWithNegativeEvidence = ((Implication)term).counter;</span>
<span class="fc" id="L183">                    double negativeEvidenceRatio = 1.0 / (double) countWithNegativeEvidence;</span>

                    // compute confidence by negative evidence
<span class="fc" id="L186">                    double w = c2w(truthOfBeliefWithTerm.getConfidence(), narParameters);</span>
<span class="fc" id="L187">                    w *= negativeEvidenceRatio;</span>
<span class="fc" id="L188">                    double c = w2c((float) w, narParameters);</span>

<span class="fc" id="L190">                    final TruthValue truth = new TruthValue(0.0f, c, narParameters); // frequency of negative confirmation is 0.0</span>

<span class="fc" id="L192">                    final Sentence sentenceForNewTask = new Sentence(</span>
                        term,
                        Symbols.JUDGMENT_MARK,
                        truth,
                        new Stamp(nar, nar.memory, Tense.Eternal));
<span class="fc" id="L197">                    final BudgetValue budget = new BudgetValue(0.99f, 0.1f, 0.1f, nar.narParameters);</span>
<span class="fc" id="L198">                    final Task t = new Task(sentenceForNewTask, budget, Task.EnumType.DERIVED);</span>

<span class="fc" id="L200">                    concept.memory.inputTask(nar, t, false);</span>
                }
            }

<span class="fc" id="L204">            concept.anticipations.remove(entry);</span>
<span class="fc" id="L205">        }</span>
<span class="fc" id="L206">    }</span>
    
    /**
     * Whether a processed judgement task satisfies the anticipations within concept
     * 
     * @param task The judgement task be checked
     * @param concept The concept that is processed
     * @param nal The derivation context
     */
    public static void confirmAnticipation(Task task, Concept concept, final DerivationContext nal) {
<span class="fc bfc" id="L216" title="All 4 branches covered.">        final boolean satisfiesAnticipation = task.isInput() &amp;&amp; !task.sentence.isEternal();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        final boolean isExpectationAboveThreshold = task.sentence.truth.getExpectation() &gt; nal.narParameters.DEFAULT_CONFIRMATION_EXPECTATION;</span>
<span class="fc" id="L218">        List&lt;Concept.AnticipationEntry&gt; confirmed = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        for(Concept.AnticipationEntry entry : concept.anticipations) {</span>
<span class="pc bpc" id="L220" title="3 of 8 branches missed.">            if(satisfiesAnticipation &amp;&amp; isExpectationAboveThreshold &amp;&amp; task.sentence.getOccurenceTime() &gt;= entry.negConfirm_abort_mintime &amp;&amp; task.sentence.getOccurenceTime() &lt;= entry.negConfirm_abort_maxtime) {</span>
<span class="fc" id="L221">                confirmed.add(entry);</span>
            }
<span class="fc" id="L223">        }</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if(confirmed.size() &gt; 0) {</span>
<span class="fc" id="L225">            nal.memory.emit(OutputHandler.CONFIRM.class, concept.getTerm());</span>
        }
<span class="fc" id="L227">        concept.anticipations.removeAll(confirmed);</span>
<span class="fc" id="L228">    }</span>
    
    /**
     * Fire predictictive inference based on beliefs that are known to the concept's neighbours
     * 
     * @param judgementTask judgement task
     * @param concept concept that is processed
     * @param nal derivation context
     * @param time used to retrieve current time
     * @param tasklink coresponding tasklink
     */
    public static void firePredictions(final Task judgementTask, final Concept concept, final DerivationContext nal, Timable time, TaskLink tasklink) {
<span class="fc bfc" id="L240" title="All 6 branches covered.">        if(!judgementTask.sentence.isEternal() &amp;&amp; judgementTask.isInput() &amp;&amp; judgementTask.sentence.isJudgment()) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">            for(TermLink tl : concept.termLinks) {</span>
<span class="fc" id="L242">                Term term = tl.getTarget();</span>
<span class="fc" id="L243">                Concept tc = nal.memory.concept(term);</span>
<span class="fc bfc" id="L244" title="All 6 branches covered.">                if(tc != null &amp;&amp; !tc.beliefs.isEmpty() &amp;&amp; term instanceof Implication) {</span>
<span class="fc" id="L245">                    Implication imp = (Implication) term;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">                    if(imp.getTemporalOrder() == TemporalRules.ORDER_FORWARD) {</span>
<span class="fc" id="L247">                        Term precon = imp.getSubject();</span>
<span class="fc" id="L248">                        Term component = precon;</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                        if(precon instanceof Conjunction) {</span>
<span class="fc" id="L250">                            Conjunction conj = (Conjunction) imp.getSubject();</span>
<span class="fc bfc" id="L251" title="All 6 branches covered.">                            if(conj.getTemporalOrder() == TemporalRules.ORDER_FORWARD &amp;&amp; conj.term.length == 2 &amp;&amp; conj.term[1] instanceof Interval) {</span>
<span class="fc" id="L252">                                component = conj.term[0]; //(&amp;/,a,+i), so use a</span>
                            }
                        }
<span class="fc bfc" id="L255" title="All 2 branches covered.">                        if(CompoundTerm.replaceIntervals(concept.getTerm()).equals(CompoundTerm.replaceIntervals(component))) {</span>
                            //trigger inference of the task with the belief
<span class="fc" id="L257">                            DerivationContext cont = new DerivationContext(nal.memory, nal.narParameters, time);</span>
<span class="fc" id="L258">                            cont.setCurrentTask(judgementTask); //a</span>
<span class="fc" id="L259">                            cont.setCurrentBeliefLink(tl); // a =/&gt; b</span>
<span class="fc" id="L260">                            cont.setCurrentTaskLink(tasklink); // a</span>
<span class="fc" id="L261">                            cont.setCurrentConcept(concept); //a</span>
<span class="fc" id="L262">                            cont.setCurrentTerm(concept.getTerm()); //a</span>
<span class="fc" id="L263">                            RuleTables.reason(tasklink, tl, cont); //generate b</span>
                        }
                    }
                }
<span class="fc" id="L267">            }</span>
        }
<span class="fc" id="L269">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>