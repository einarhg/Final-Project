<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Variables.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.language</a> &gt; <span class="el_source">Variables.java</span></div><h1>Variables.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.language;

import org.opennars.inference.TemporalRules;
import org.opennars.io.Symbols;
import org.opennars.storage.Memory;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;

/**
 * Static utility class for static methods related to Variables
 *
 * @author Patrick Hammer
 */
<span class="nc" id="L41">public class Variables {</span>
    
    public static boolean findSubstitute(Random rnd, final char type, final Term term1, final Term term2, final Map&lt;Term, Term&gt; map1, final Map&lt;Term, Term&gt; map2) {
<span class="fc" id="L44">        return findSubstitute(rnd, type, term1, term2, new Map[] { map1, map2 });</span>
    }
    
    public static boolean allowUnification(final char type, final char uniType)
    { //it is valid to allow dependent var unification in case that a independent var unification is happening,
        //as shown in the 
        // &lt;(&amp;&amp;,&lt;$1 --&gt; [ENGLISH]&gt;, &lt;$2 --&gt; [CHINESE]&gt;, &lt;(*, $1, #3) --&gt; REPRESENT&gt;, &lt;(*, $2, #3) --&gt; REPRESENT&gt;) ==&gt; &lt;(*, $1, $2) --&gt; TRANSLATE&gt;&gt;.
        //example by Kai Liu.
        //1.7.0 and 2.0.1 also already allowed this, so this is for v1.6.x now.
        
<span class="fc bfc" id="L54" title="All 2 branches covered.">        if(uniType == type) { //the usual case</span>
<span class="fc" id="L55">            return true;</span>
        }
<span class="fc bfc" id="L57" title="All 2 branches covered.">        if(uniType == Symbols.VAR_INDEPENDENT) { //the now allowed case</span>
<span class="pc bpc" id="L58" title="1 of 4 branches missed.">            if(type == Symbols.VAR_DEPENDENT ||</span>
               type == Symbols.VAR_QUERY) {
<span class="fc" id="L60">                return true;</span>
            }
        }
<span class="fc bfc" id="L63" title="All 2 branches covered.">        if(uniType == Symbols.VAR_DEPENDENT) { //the now allowed case</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">            return type == Symbols.VAR_QUERY;</span>
        }
<span class="fc" id="L66">        return false;</span>
    }
    
    /** map is a 2-element array of Map&amp;lt;Term,Term&amp;gt;. it may be null, in which case
     * the maps will be instantiated as necessary.  
     * this is to delay the instantiation of the 2 Map until necessary to avoid
     * wasting them if they are not used.
     */
    public static boolean findSubstitute(Random rnd, final char type, final Term term1, final Term term2, final Map&lt;Term, Term&gt;[] map) {
<span class="fc" id="L75">        return findSubstitute(rnd, type, term1, term2, map, false);</span>
    }
    public static boolean findSubstitute(Random rnd, final char type, final Term term1, final Term term2, final Map&lt;Term, Term&gt;[] map, final boolean allowPartial) {

<span class="fc" id="L79">        boolean term1HasVar = term1.hasVar(type);</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if(type == Symbols.VAR_INDEPENDENT) {</span>
<span class="fc" id="L81">            term1HasVar |= term1.hasVarDep();</span>
<span class="fc" id="L82">            term1HasVar |= term1.hasVarQuery();</span>
        }
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if(type == Symbols.VAR_DEPENDENT) {</span>
<span class="fc" id="L85">            term1HasVar |= term1.hasVarQuery();</span>
        }
<span class="fc" id="L87">        final boolean term2HasVar = term2.hasVar(type);</span>
        
        
<span class="fc" id="L90">        final boolean term1Var = term1 instanceof Variable;</span>
<span class="fc" id="L91">        final boolean term2Var = term2 instanceof Variable;</span>
        
<span class="fc bfc" id="L93" title="All 6 branches covered.">        if(allowPartial &amp;&amp; term1 instanceof Conjunction &amp;&amp; term2 instanceof Conjunction) {</span>
<span class="fc" id="L94">            final Conjunction c1 = (Conjunction) term1;</span>
<span class="fc" id="L95">            final Conjunction c2 = (Conjunction) term2;</span>
            //more effective matching for NLP
<span class="fc bfc" id="L97" title="All 2 branches covered.">            if(c1.getTemporalOrder() == TemporalRules.ORDER_FORWARD &amp;&amp;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">                    c2.getTemporalOrder() == TemporalRules.ORDER_FORWARD) {</span>
<span class="fc" id="L99">                final int size_smaller = c1.size();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">                if(c1.size() &lt; c2.size()) {</span>
                    //find an offset that works
<span class="fc bfc" id="L102" title="All 2 branches covered.">                    for(int k=0;k&lt;(c2.term.length - c1.term.length);k++) {</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">                        if(map[0] == null) {</span>
<span class="fc" id="L105">                            map[0] = new LinkedHashMap&lt;&gt;();</span>
                        }
<span class="fc bfc" id="L107" title="All 2 branches covered.">                        if(map[1] == null) {</span>
<span class="fc" id="L108">                            map[1] = new LinkedHashMap&lt;&gt;();</span>
                        }

<span class="fc" id="L111">                        final Map&lt;Term, Term&gt;[] mapk = copyMapFrom(map);</span>
<span class="fc" id="L112">                        boolean succeeded = true;</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">                        for(int j=k;j&lt;k+size_smaller;j++) {</span>
<span class="fc" id="L114">                            final int i = j-k;</span>
<span class="fc" id="L115">                            final Map&lt;Term, Term&gt;[] mapNew = copyMapFrom(map);</span>
                            //attempt unification:
<span class="fc bfc" id="L117" title="All 2 branches covered.">                            if(findSubstitute(rnd, type,c1.term[i],c2.term[j],mapNew)) {</span>
<span class="fc" id="L118">                                appendToMap(mapNew[0], mapk[0]);</span>
<span class="fc" id="L119">                                appendToMap(mapNew[1], mapk[1]);</span>
                            } else { //another shift k is needed
<span class="fc" id="L121">                                succeeded = false;</span>
<span class="fc" id="L122">                                break;</span>
                            }
                        }
<span class="fc bfc" id="L125" title="All 2 branches covered.">                        if(succeeded) {</span>
<span class="fc" id="L126">                            appendToMap(mapk[0], map[0]);</span>
<span class="fc" id="L127">                            appendToMap(mapk[1], map[1]);</span>
<span class="fc" id="L128">                            return true;</span>
                        }
                    }
                }
            }
        }
        
<span class="fc" id="L135">        final boolean termsEqual = term1.equals(term2);</span>
<span class="fc bfc" id="L136" title="All 6 branches covered.">        if (!term1Var &amp;&amp; !term2Var &amp;&amp; termsEqual)  {</span>
<span class="fc" id="L137">            return true;</span>
        }
        
        //variable &quot;renaming&quot; to variable of same type is always valid
<span class="fc bfc" id="L141" title="All 4 branches covered.">        if(term1 instanceof Variable &amp;&amp; term2 instanceof Variable) {</span>
<span class="fc" id="L142">            final Variable v1 = (Variable) term1;</span>
<span class="fc" id="L143">            final Variable v2 = (Variable) term2;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if(v1.getType() == v2.getType()) {</span>
<span class="fc" id="L145">                final Variable CommonVar = makeCommonVariable(term1, term2);</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">                if (map[0] == null) {  map[0] = new LinkedHashMap&lt;&gt;(); map[1] = new LinkedHashMap&lt;&gt;(); }</span>
<span class="fc" id="L147">                map[0].put(v1, CommonVar);</span>
<span class="fc" id="L148">                map[1].put(v2, CommonVar);</span>
<span class="fc" id="L149">                return true;</span>
            }
        }

<span class="fc bfc" id="L153" title="All 4 branches covered.">        final boolean term1VarUnifyAllowed = term1Var &amp;&amp; allowUnification(((Variable) term1).getType(), type);</span>
<span class="fc bfc" id="L154" title="All 4 branches covered.">        final boolean term2VarUnifyAllowed = term2Var &amp;&amp; allowUnification(((Variable) term2).getType(), type);</span>

<span class="fc bfc" id="L156" title="All 4 branches covered.">        if (term1VarUnifyAllowed || term2VarUnifyAllowed) {</span>

<span class="fc bfc" id="L158" title="All 2 branches covered.">            Term termA = term1VarUnifyAllowed ? term1 : term2;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            Term termB = term1VarUnifyAllowed ? term2 : term1;</span>
<span class="fc" id="L160">            Variable termAAsVariable = (Variable)termA;</span>
            //https://github.com/opennars/opennars/issues/482:
<span class="fc bfc" id="L162" title="All 2 branches covered.">            int mapIdx = term1VarUnifyAllowed ? 0 : 1;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            final Term t = map[mapIdx]!=null ? map[mapIdx].get(termAAsVariable) : null;</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (t != null) {</span>
<span class="fc" id="L165">                return findSubstitute(rnd, type, t, termB, map);</span>
            }

<span class="fc bfc" id="L168" title="All 2 branches covered.">            if (map[0] == null) {  map[0] = new LinkedHashMap&lt;&gt;(); map[1] = new LinkedHashMap&lt;&gt;(); }</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (term1VarUnifyAllowed) {</span>

<span class="fc bfc" id="L172" title="All 4 branches covered.">                if ((termB instanceof Variable) &amp;&amp; allowUnification(((Variable) termB).getType(), type)) {</span>
<span class="fc" id="L173">                    final Variable CommonVar = makeCommonVariable(termA, termB);</span>
<span class="fc" id="L174">                    map[0].put(termAAsVariable, CommonVar);</span>
<span class="fc" id="L175">                    map[1].put(termB, CommonVar);</span>
<span class="fc" id="L176">                } else {</span>
<span class="pc bpc" id="L177" title="3 of 6 branches missed.">                    if(termB instanceof Variable &amp;&amp; ((((Variable)termB).getType()==Symbols.VAR_QUERY &amp;&amp; ((Variable)termA).getType()!=Symbols.VAR_QUERY) ||</span>
<span class="pc bpc" id="L178" title="1 of 4 branches missed.">                        (((Variable)termB).getType()!=Symbols.VAR_QUERY &amp;&amp; ((Variable)termA).getType()==Symbols.VAR_QUERY))) {</span>
<span class="fc" id="L179">                        return false;</span>
                    }
<span class="fc" id="L181">                    map[0].put(termAAsVariable, termB);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">                    if (termAAsVariable.isCommon()) {</span>
<span class="fc" id="L183">                        map[1].put(termAAsVariable, termB);</span>
                    }
                }
            } else {
<span class="fc" id="L187">                map[1].put(termAAsVariable, termB);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">                if (termAAsVariable.isCommon()) {</span>
<span class="fc" id="L189">                    map[0].put(termAAsVariable, termB);</span>
                }
            }

<span class="fc" id="L193">            return true;</span>

        } else {
<span class="fc bfc" id="L196" title="All 4 branches covered.">            final boolean hasAnyTermVars = term1HasVar || term2HasVar;</span>
<span class="fc" id="L197">            final boolean termsHaveSameClass = term1.getClass().equals(term2.getClass());</span>
            
<span class="pc bpc" id="L199" title="1 of 6 branches missed.">            if (!(hasAnyTermVars &amp;&amp; termsHaveSameClass &amp;&amp; term1 instanceof CompoundTerm)) {</span>
<span class="fc" id="L200">                return termsEqual;</span>
            }

<span class="fc" id="L203">            final CompoundTerm cTerm1 = (CompoundTerm) term1;</span>
<span class="fc" id="L204">            final CompoundTerm cTerm2 = (CompoundTerm) term2;</span>

            //consider temporal order on term matching
<span class="fc bfc" id="L207" title="All 2 branches covered.">            final boolean isSameOrder = term1.getTemporalOrder() == term2.getTemporalOrder();</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">            final boolean isSameSpatial = term1.getIsSpatial() == term2.getIsSpatial();</span>
<span class="pc bpc" id="L209" title="1 of 4 branches missed.">            final boolean isSameOrderAndSameSpatial = isSameOrder &amp;&amp; isSameSpatial;</span>

<span class="pc bpc" id="L211" title="1 of 4 branches missed.">            final boolean areBothConjunctions = term1 instanceof Conjunction &amp;&amp; term2 instanceof Conjunction;</span>
<span class="pc bpc" id="L212" title="1 of 4 branches missed.">            final boolean areBothImplication = term1 instanceof Implication &amp;&amp; term2 instanceof Implication;</span>
<span class="pc bpc" id="L213" title="1 of 4 branches missed.">            final boolean areBothEquivalence = term1 instanceof Equivalence &amp;&amp; term2 instanceof Equivalence;</span>

<span class="fc bfc" id="L215" title="All 10 branches covered.">            if((areBothConjunctions &amp;&amp; !isSameOrderAndSameSpatial) ||</span>
                ((areBothEquivalence || areBothImplication) &amp;&amp; !isSameOrder)
            ) {
<span class="fc" id="L218">                return false;</span>
            }

<span class="fc bfc" id="L221" title="All 2 branches covered.">            if (cTerm1.size() != cTerm2.size()) {</span>
<span class="fc" id="L222">                return false;</span>
            }
<span class="fc bfc" id="L224" title="All 8 branches covered.">            if ((cTerm1 instanceof ImageExt) &amp;&amp; (((ImageExt) cTerm1).relationIndex != ((ImageExt) cTerm2).relationIndex) || (cTerm1 instanceof ImageInt) &amp;&amp; (((ImageInt) cTerm1).relationIndex != ((ImageInt) cTerm2).relationIndex)) {</span>
<span class="fc" id="L225">                return false;</span>
            }
<span class="fc" id="L227">            final Term[] list = cTerm1.cloneTerms();</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (cTerm1.isCommutative()) {</span>
<span class="fc" id="L229">                CompoundTerm.shuffle(list, rnd);</span>
                //ok attempt unification
<span class="pc bpc" id="L231" title="3 of 6 branches missed.">                if(list == null || cTerm2.term == null || list.length != cTerm2.term.length) {</span>
<span class="nc" id="L232">                    return false;</span>
                }
<span class="fc" id="L234">                final Set&lt;Integer&gt; matchedJ = new LinkedHashSet&lt;&gt;(list.length * 2);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">                for(int i = 0; i &lt; list.length; i++) {</span>
<span class="fc" id="L236">                    boolean succeeded = false;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">                    for(int j = 0; j &lt; list.length; j++) {</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                        if(matchedJ.contains(j)) { //this one already was used to match one of the i's</span>
<span class="fc" id="L239">                            continue;</span>
                        }
<span class="fc" id="L241">                        final Term ti = list[i].clone();</span>
                        //clone map also:

<span class="fc bfc" id="L244" title="All 2 branches covered.">                        if(map[0] == null) {</span>
<span class="fc" id="L245">                            map[0] = new LinkedHashMap&lt;&gt;();</span>
                        }
<span class="fc bfc" id="L247" title="All 2 branches covered.">                        if(map[1] == null) {</span>
<span class="fc" id="L248">                            map[1] = new LinkedHashMap&lt;&gt;();</span>
                        }

<span class="fc" id="L251">                        final Map&lt;Term, Term&gt;[] mapNew = copyMapFrom(map);</span>
                        //attempt unification:
<span class="fc bfc" id="L253" title="All 2 branches covered.">                        if(findSubstitute(rnd, type,ti,cTerm2.term[j],mapNew)) {</span>
<span class="fc" id="L254">                            appendToMap(mapNew[0], map[0]);</span>
<span class="fc" id="L255">                            appendToMap(mapNew[1], map[1]);</span>
<span class="fc" id="L256">                            succeeded = true;</span>
<span class="fc" id="L257">                            matchedJ.add(j);</span>
<span class="fc" id="L258">                            break;</span>
                        }
                    }
<span class="fc bfc" id="L261" title="All 2 branches covered.">                    if(!succeeded) {</span>
<span class="fc" id="L262">                        return false;</span>
                    }
                }
<span class="fc" id="L265">                return true;</span>
            }
<span class="fc bfc" id="L267" title="All 2 branches covered.">            for (int i = 0; i &lt; cTerm1.size(); i++) {</span>
<span class="fc" id="L268">                final Term t1 = list[i];</span>
<span class="fc" id="L269">                final Term t2 = cTerm2.term[i];</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">                if (!findSubstitute(rnd, type, t1, t2, map)) {</span>
<span class="fc" id="L271">                    return false;</span>
                }
            }
<span class="fc" id="L274">            return true;</span>

        }
    }

    /**
     * copies two maps from source into two new maps
     * @param source source maps (two)
     * @return copied maps
     */
    private static Map&lt;Term, Term&gt;[] copyMapFrom(Map&lt;Term, Term&gt;[] source) {
<span class="fc" id="L285">        final Map&lt;Term, Term&gt;[] destination = (Map&lt;Term, Term&gt;[]) new LinkedHashMap&lt;?,?&gt;[2];</span>

<span class="fc" id="L287">        destination[0] = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L288">        destination[1] = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L290">        appendToMap(source[0], destination[0]);</span>
<span class="fc" id="L291">        appendToMap(source[1], destination[1]);</span>
<span class="fc" id="L292">        return destination;</span>
    }

    private static void appendToMap(Map&lt;Term, Term&gt; source, Map&lt;Term, Term&gt; target) {
<span class="fc bfc" id="L296" title="All 2 branches covered.">        for(final Term c : source.keySet()) {</span>
<span class="fc" id="L297">            target.put(c, source.get(c));</span>
<span class="fc" id="L298">        }</span>
<span class="fc" id="L299">    }</span>


    /**
     * Check whether a string represent a name of a term that contains a
     * variable
     *
     * @param n The string name to be checked
     * @return Whether the name contains a variable
     */
    public static boolean containVar(final CharSequence n) {
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (n == null) return false;</span>
<span class="fc" id="L311">        final int l = n.length();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        for (int i = 0; i &lt; l; i++) {</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">            switch (n.charAt(i)) {                </span>
                case Symbols.VAR_INDEPENDENT:
                case Symbols.VAR_DEPENDENT:
                case Symbols.VAR_QUERY:
<span class="fc" id="L317">                    return true;</span>
            }
        }        
<span class="fc" id="L320">        return false;</span>
    }
    
    public static final boolean containVar(final Term[] t) {
<span class="nc bnc" id="L324" title="All 2 branches missed.">        for (final Term x : t)</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (x instanceof Variable)</span>
<span class="nc" id="L326">                return true;</span>
<span class="nc" id="L327">        return false;</span>
    }
    

    /**
     * To unify two terms
     *
     * @param type The type of variable that can be substituted
     * @param t The first and second term as an array, which will have been modified upon returning true
     * @return Whether the unification is possible.  't' will refer to the unified terms
     */
    public static boolean unify(Random rnd, final char type, final Term[] t) {
<span class="fc" id="L339">        return unify(rnd, type, t[0], t[1], t);</span>
    }

 
    /**
     * To unify two terms
     *
     * @param type The type of variable that can be substituted
     * @param t1 The compound containing the first term, possibly modified
     * @param t2 The compound containing the second term, possibly modified
     * @param compound The first and second term as an array, which will have been modified upon returning true
     * @return Whether the unification is possible.  't' will refer to the unified terms
     */
    public static boolean unify(Random rnd, final char type, final Term t1, final Term t2, final Term[] compound) { 
<span class="fc" id="L353">        return unify(rnd, type, t1, t2, compound, false);</span>
    }
    public static boolean unify(Random rnd, final char type, final Term t1, final Term t2, final Term[] compound, final boolean allowPartial) {
<span class="fc" id="L356">        final Map&lt;Term, Term&gt; map[] = new Map[2]; //begins empty: null,null</span>
        
<span class="fc" id="L358">        final boolean hasSubs = findSubstitute(rnd, type, t1, t2, map, allowPartial);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (hasSubs) {</span>
<span class="pc bpc" id="L360" title="1 of 4 branches missed.">            final Term a = (compound[0] instanceof Variable &amp;&amp; map[0].containsKey(compound[0])) ? </span>
<span class="fc" id="L361">                            map[0].get(compound[0]) : </span>
<span class="fc" id="L362">                            applySubstituteAndRenameVariables(((CompoundTerm)compound[0]), map[0]);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            if (a == null) return false;</span>
<span class="pc bpc" id="L364" title="3 of 4 branches missed.">            final Term b = (compound[1] instanceof Variable &amp;&amp; map[1].containsKey(compound[1])) ? </span>
<span class="pc" id="L365">                            map[1].get(compound[1]) :</span>
<span class="fc" id="L366">                            applySubstituteAndRenameVariables(((CompoundTerm)compound[1]), map[1]);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            if (b == null) return false;</span>
            //only set the values if it will return true, otherwise if it returns false the callee can expect its original values untouched
<span class="pc bpc" id="L369" title="5 of 8 branches missed.">            if(compound[0] instanceof Variable &amp;&amp; compound[0].hasVarQuery() &amp;&amp; (a.hasVarIndep() || a.hasVarIndep()) ) {</span>
<span class="nc" id="L370">                return false;</span>
            }
<span class="pc bpc" id="L372" title="7 of 8 branches missed.">            if(compound[1] instanceof Variable &amp;&amp; compound[1].hasVarQuery() &amp;&amp; (b.hasVarIndep() || b.hasVarIndep()) ) {</span>
<span class="nc" id="L373">                return false;</span>
            }
<span class="fc" id="L375">            compound[0] = a;</span>
<span class="fc" id="L376">            compound[1] = b;</span>
<span class="fc" id="L377">            return true;</span>
        }
<span class="fc" id="L379">        return false;</span>
    }

    /** appliesSubstitute and renameVariables, resulting in a cloned object, 
     *  will not change this instance  */
    private static Term applySubstituteAndRenameVariables(final CompoundTerm t, final Map&lt;Term, Term&gt; subs) {
<span class="fc bfc" id="L385" title="All 4 branches covered.">        if ((subs == null) || (subs.isEmpty())) {</span>
            //no change needed
<span class="fc" id="L387">            return t;</span>
        }
        
<span class="fc" id="L390">        final Term r = t.applySubstitute(subs);</span>
        
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (r == null) return null;</span>
        
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (r.equals(t)) return t;</span>
        
<span class="fc" id="L396">        return r;</span>
    }

    public static Variable makeCommonVariable(final Term v1, final Term v2) {
        //TODO use more efficient string construction
<span class="fc" id="L401">        return new Variable(v2.toString() + v1.toString() + '$'); //v2 first since when type does not match</span>
    } //but it is an allowed rename like $1 -&gt; #1 then the second type should be used
    
    /**
     * examines whether a term is using an
     * independent variable in an invalid way
     *
     * @param T term to be examined
     * @return Whether the term contains an independent variable
     */
    public static boolean indepVarUsedInvalid(final Term T) {
        
        //if its a conjunction/disjunction, this is invalid: (&amp;&amp;,&lt;$1 --&gt; test&gt;,&lt;$1 --&gt; test2&gt;), while this isnt: (&amp;&amp;,&lt;$1 --&gt; test ==&gt; &lt;$1 --&gt; test2&gt;,others)
        //this means we have to go through the conjunction, and check if the component is a indepVarUsedInvalid instance, if yes, return true
        //
<span class="fc bfc" id="L416" title="All 4 branches covered.">        if(T instanceof Conjunction || T instanceof Disjunction) {</span>
<span class="fc" id="L417">            final Term[] part=((CompoundTerm)T).term;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">            for(final Term t : part) {</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">                if(indepVarUsedInvalid(t)) {</span>
<span class="fc" id="L420">                    return true;</span>
                }
            }
        }
        
<span class="pc bpc" id="L425" title="1 of 4 branches missed.">        if(!(T instanceof Inheritance) &amp;&amp; !(T instanceof Similarity)) {</span>
<span class="fc" id="L426">            return false;</span>
        }

<span class="fc" id="L429">        return T.hasVarIndep();</span>
    }

    /**
     * Check if two terms can be unified
     *
     * @param type The type of variable that can be substituted
     * @param term1 The first term to be unified
     * @param term2 The second term to be unified
     * @return Whether there is a substitution
     */
    public static boolean hasSubstitute(Random rnd, final char type, final Term term1, final Term term2) {
<span class="fc" id="L441">        return findSubstitute(rnd, type, term1, term2, new LinkedHashMap&lt;&gt;(), new LinkedHashMap&lt;&gt;());</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>