<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompoundTerm.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.language</a> &gt; <span class="el_source">CompoundTerm.java</span></div><h1>CompoundTerm.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.language;

import com.google.common.collect.Iterators;
import org.opennars.entity.TermLink;
import org.opennars.inference.TemporalRules;
import org.opennars.io.Symbols;
import org.opennars.io.Symbols.NativeOperator;
import org.opennars.main.Debug;
import org.opennars.storage.Memory;

import java.nio.CharBuffer;
import java.util.*;

import static org.opennars.io.Symbols.NativeOperator.COMPOUND_TERM_CLOSER;
import static org.opennars.io.Symbols.NativeOperator.COMPOUND_TERM_OPENER;


/**
 * Compound term as defined in the NARS-theory
 *
 * @author Pei Wang
 * @author Patrick Hammer
 */
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">public abstract class CompoundTerm extends Term implements Iterable&lt;Term&gt; {</span>
    
    /**
     * list of (direct) term
     *
     */
    // TODO make final again
    public final Term[] term;
    
    /**
     * syntactic complexity of the compound, the sum of those of its term plus 1
     */
    // TODO make final again
    public short complexity;
    
    
    /** Whether contains a variable */
    private boolean hasVariables, hasVarQueries, hasVarIndeps, hasVarDeps, hasIntervals;
    
<span class="fc" id="L66">    int containedTemporalRelations = -1;</span>
    int hash;
    private boolean normalized;
    

    /**
     * method to get the operator of the compound
     */
    @Override public abstract NativeOperator operator();

    /**
     * clone method
     *
     * @return A clone of the compound term
     */
    @Override public abstract CompoundTerm clone();

    
    /** subclasses should be sure to call init() in their constructors;
     * it is not done here to allow subclass constructors to set data before calling init() */
    public CompoundTerm(final Term[] components) {
<span class="fc" id="L87">        super();</span>
<span class="fc" id="L88">        this.term = components;</span>
<span class="fc" id="L89">    }</span>
    
    public static class ConvRectangle
    {
<span class="fc" id="L93">        public String index_variable = null;</span>
<span class="fc" id="L94">        public int[] term_indices = null; //size X, size Y, pos X, pos Y, min size X, min size Y</span>
<span class="fc" id="L95">        public ConvRectangle(){} //the latter two for being able to assing a relative index for size too</span>
    }
    public static ConvRectangle UpdateConvRectangle(final Term[] term) {
<span class="fc" id="L98">        String index_last_var = null;</span>
<span class="fc" id="L99">        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE, maxX = 0, maxY = 0, </span>
<span class="fc" id="L100">                minsX = Integer.MAX_VALUE, minsY = Integer.MAX_VALUE;</span>
<span class="fc" id="L101">        boolean hasTermIndices = false;</span>
<span class="fc" id="L102">        boolean calculateTermIndices = true;</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        for (final Term t : term) {</span>
<span class="pc bpc" id="L104" title="1 of 4 branches missed.">            if(t != null &amp;&amp; t.term_indices != null) {</span>
<span class="pc bpc" id="L105" title="3 of 6 branches missed.">                if(!calculateTermIndices || </span>
                        (t.index_variable != null &amp;&amp; index_last_var != null &amp;&amp;
<span class="nc bnc" id="L107" title="All 2 branches missed.">                        (!t.index_variable.equals(index_last_var)))) {</span>
<span class="nc" id="L108">                    calculateTermIndices = false;</span>
<span class="nc" id="L109">                    hasTermIndices = false;</span>
<span class="nc" id="L110">                    continue; //different &quot;channels&quot;, don't calculate term indices</span>
                }
<span class="fc" id="L112">                hasTermIndices = true;</span>
<span class="fc" id="L113">                final int size_X = t.term_indices[0];</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">                if(size_X &lt; minsX)</span>
<span class="fc" id="L115">                    minsX = size_X;</span>
<span class="fc" id="L116">                final int size_Y = t.term_indices[1];</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">                if(size_Y &lt; minsY)</span>
<span class="fc" id="L118">                    minsY = size_Y;</span>
<span class="fc" id="L119">                final int pos_X = t.term_indices[2];</span>
<span class="fc" id="L120">                final int pos_Y = t.term_indices[3];</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">                if(pos_X &lt; minX)</span>
<span class="fc" id="L122">                    minX = pos_X;</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">                if(pos_Y &lt; minY)</span>
<span class="fc" id="L124">                    minY = pos_Y;</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">                if(pos_X+size_X &gt; maxX)</span>
<span class="fc" id="L126">                    maxX = pos_X+size_X;</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">                if(pos_Y+size_Y &gt; maxY)</span>
<span class="fc" id="L128">                    maxY = pos_Y+size_Y;</span>
                
<span class="fc" id="L130">                index_last_var = t.index_variable;</span>
            }
        }
<span class="fc" id="L133">        final ConvRectangle rect = new ConvRectangle();// = new ConvRectangle();</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        if(hasTermIndices) {</span>
<span class="fc" id="L135">            rect.term_indices = new int[6];</span>
<span class="fc" id="L136">            rect.term_indices[0] = maxX-minX;</span>
<span class="fc" id="L137">            rect.term_indices[1] = maxY-minY;</span>
<span class="fc" id="L138">            rect.term_indices[2] = minX;</span>
<span class="fc" id="L139">            rect.term_indices[3] = minY;</span>
<span class="fc" id="L140">            rect.term_indices[4] = minsX;</span>
<span class="fc" id="L141">            rect.term_indices[5] = minsY;</span>
<span class="fc" id="L142">            rect.index_variable = index_last_var;</span>
        }
<span class="fc" id="L144">        return rect;</span>
    }
    
    /** call this after changing Term[] contents */
    protected void init(final Term[] term) {

<span class="fc" id="L150">        this.complexity = 1;</span>
<span class="fc" id="L151">        this.hasVariables = this.hasVarDeps = this.hasVarIndeps = this.hasVarQueries = false;</span>
        
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        if(this.term_indices == null) {</span>
<span class="fc" id="L154">            final ConvRectangle rect = UpdateConvRectangle(term);</span>
<span class="fc" id="L155">            this.index_variable = rect.index_variable;</span>
<span class="fc" id="L156">            this.term_indices = rect.term_indices;</span>
        }
        
<span class="fc bfc" id="L159" title="All 2 branches covered.">        for (final Term t : term) {</span>

<span class="fc" id="L161">            this.complexity += t.getComplexity();</span>
<span class="fc" id="L162">            hasVariables |= t.hasVar();</span>
<span class="fc" id="L163">            hasVarDeps |= t.hasVarDep();</span>
<span class="fc" id="L164">            hasVarIndeps |= t.hasVarIndep();</span>
<span class="fc" id="L165">            hasVarQueries |= t.hasVarQuery();</span>
<span class="fc" id="L166">            hasIntervals |= t.hasInterval();</span>
        }
        
<span class="fc" id="L169">        invalidateName();        </span>
        
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (!hasVar())</span>
<span class="fc" id="L172">            setNormalized(true);</span>
<span class="fc" id="L173">    }</span>

    
    public void invalidateName() {        
<span class="fc" id="L177">        this.setName(null); //invalidate name so it will be (re-)created lazily</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (final Term t : term) {</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            if (t.hasVar())</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                if (t instanceof CompoundTerm)</span>
<span class="fc" id="L181">                    ((CompoundTerm)t).invalidateName();</span>
        }     
<span class="fc" id="L183">        setNormalized(false);</span>
<span class="fc" id="L184">    }</span>

    /** Must be Term return type because the type of Term may change with different arguments */
    abstract public Term clone(final Term[] replaced);
    
    @Override
    public CompoundTerm cloneDeep() {
<span class="fc" id="L191">        final Term c = clone(cloneTermsDeep());</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (c == null)</span>
<span class="fc" id="L193">            return null;</span>
<span class="pc bpc" id="L194" title="3 of 4 branches missed.">        if (Debug.DETAILED &amp;&amp; c.getClass()!=getClass()) //debug relevant, while it is natural due to interval </span>
                                                          //simplification to reduce to other term type,
                                                          //other cases should not appear
<span class="nc" id="L197">            System.out.println(&quot;cloneDeep resulted in different class: &quot; + c + &quot; from &quot; + this);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (isNormalized())</span>
<span class="fc" id="L199">            ((CompoundTerm)c).setNormalized(true);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if(!(c instanceof CompoundTerm)) {</span>
<span class="nc" id="L201">            return null;</span>
        }
<span class="fc" id="L203">        return (CompoundTerm)c;</span>
    }
    
    public static void transformIndependentVariableToDependent(final CompoundTerm T) { //a special instance of transformVariableTermsDeep in 1.7
<span class="fc" id="L207">        final Term[] term=T.term;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">        for (int i = 0; i &lt; term.length; i++) {</span>
<span class="fc" id="L209">            final Term t = term[i];</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (t.hasVar()) {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">                if (t instanceof CompoundTerm) {</span>
<span class="fc" id="L212">                    transformIndependentVariableToDependent((CompoundTerm) t);</span>
<span class="pc bpc" id="L213" title="1 of 4 branches missed.">                } else if (t instanceof Variable &amp;&amp; ((Variable)t).isIndependentVariable()) {  /* it's a variable */</span>
<span class="fc" id="L214">                    term[i] = new Variable(&quot;&quot;+Symbols.VAR_DEPENDENT+t.name().subSequence(1, t.name().length())); // vars.get(t.toString());</span>
<span class="pc bpc" id="L215" title="2 of 4 branches missed.">                    assert term[i] != null;</span>
                }
            }
        }
<span class="fc" id="L219">    }</span>
    
<span class="fc" id="L221">    static final Interval conceptival = new Interval(1);</span>
    private static void ReplaceIntervals(final CompoundTerm comp) {
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (!comp.hasIntervals) {</span>
<span class="fc" id="L224">            return;</span>
        }

<span class="fc" id="L227">        comp.invalidateName();</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">        for(int i=0; i&lt;comp.term.length; i++) {</span>
<span class="fc" id="L229">            final Term t = comp.term[i];</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">            if(t instanceof Interval) {</span>
<span class="pc bpc" id="L231" title="2 of 4 branches missed.">                assert conceptival != null;</span>
<span class="fc" id="L232">                comp.term[i] = conceptival;</span>
<span class="fc" id="L233">                comp.invalidateName();</span>
            }
            else
<span class="fc bfc" id="L236" title="All 2 branches covered.">            if(t instanceof CompoundTerm) {</span>
<span class="fc" id="L237">                ReplaceIntervals((CompoundTerm) t);</span>
            }
        }
<span class="fc" id="L240">    }</span>

    public static Term replaceIntervals(Term T) {
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if(T instanceof CompoundTerm) {</span>
<span class="fc" id="L244">            T=T.cloneDeep(); //we will operate on a copy</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">            if(T == null) {</span>
<span class="nc" id="L246">                return null; //not a valid concept term</span>
            }
<span class="fc" id="L248">            ReplaceIntervals((CompoundTerm) T);</span>
        }
<span class="fc" id="L250">        return T;</span>
    }
    
    private static void ExtractIntervals(final Memory mem, final List&lt;Long&gt; ivals, final CompoundTerm comp) {
<span class="fc bfc" id="L254" title="All 2 branches covered.">        for(int i=0; i&lt;comp.term.length; i++) {</span>
<span class="fc" id="L255">            final Term t = comp.term[i];</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            if(t instanceof Interval) {</span>
<span class="fc" id="L257">                ivals.add(((Interval) t).time);</span>
            }
            else
<span class="fc bfc" id="L260" title="All 2 branches covered.">            if(t instanceof CompoundTerm) {</span>
<span class="fc" id="L261">                ExtractIntervals(mem, ivals, (CompoundTerm) t);</span>
            }
        }
<span class="fc" id="L264">    }</span>

    public static List&lt;Long&gt; extractIntervals(final Memory mem, final Term T) {
<span class="fc" id="L267">        final List&lt;Long&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">        if(T instanceof CompoundTerm) {</span>
<span class="fc" id="L269">            ExtractIntervals(mem, ret, (CompoundTerm) T);</span>
        }
<span class="fc" id="L271">        return ret;</span>
    }

    public static class UnableToCloneException extends RuntimeException {

        public UnableToCloneException(final String message) {
<span class="nc" id="L277">            super(message);</span>
<span class="nc" id="L278">        }</span>

        @Override
        public synchronized Throwable fillInStackTrace() {
<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (Debug.DETAILED) {</span>
<span class="nc" id="L283">                return super.fillInStackTrace();</span>
            }
            else {
                //avoid recording stack trace for efficiency reasons
<span class="nc" id="L287">                return this;</span>
            }
        }
        
        
    }
    
    public CompoundTerm cloneDeepVariables() {                
<span class="fc" id="L295">        final Term c = clone( cloneVariableTermsDeep() );</span>
        
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (c == null)</span>
<span class="fc" id="L298">            return null;</span>
        
<span class="pc bpc" id="L300" title="3 of 4 branches missed.">        if (Debug.DETAILED &amp;&amp; c.getClass()!=getClass())</span>
<span class="nc" id="L301">            System.out.println(&quot;cloneDeepVariables resulted in different class: &quot; + c + &quot; from &quot; + this);                </span>
        
<span class="fc" id="L303">        final CompoundTerm cc = (CompoundTerm)c;</span>
<span class="fc" id="L304">        cc.setNormalized(isNormalized());</span>
<span class="fc" id="L305">        return cc;</span>
    }

    @Override
    public int containedTemporalRelations() {
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (containedTemporalRelations == -1) {</span>
            
<span class="fc" id="L312">            containedTemporalRelations = 0;</span>
            
<span class="fc bfc" id="L314" title="All 4 branches covered.">            if ((this instanceof Equivalence) || (this instanceof Implication)) {</span>
<span class="fc" id="L315">                final int temporalOrder = this.getTemporalOrder();</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">                switch (temporalOrder) {</span>
                    case TemporalRules.ORDER_FORWARD:
                    case TemporalRules.ORDER_CONCURRENT:
                    case TemporalRules.ORDER_BACKWARD:
<span class="fc" id="L320">                        containedTemporalRelations = 1;</span>
                }                
            }
            
<span class="fc bfc" id="L324" title="All 2 branches covered.">            for (final Term t : term)</span>
<span class="fc" id="L325">                containedTemporalRelations += t.containedTemporalRelations();</span>
        }
<span class="fc" id="L327">        return this.containedTemporalRelations;</span>
    }
    
    


    /**
     * build a component list from terms
     * @return the component list
     */
    public static Term[] termArray(final Term... t) {
<span class="nc" id="L338">        return t;</span>
    }
    public static List&lt;Term&gt; termList(final Term... t) {
<span class="nc" id="L341">        return Arrays.asList((Term[])t);</span>
    }
    
    

    /* ----- utilities for oldName ----- */
    /**
     * default method to make the oldName of the current term from existing
     * fields.  needs overridden in certain subclasses
     *
     * @return the oldName of the term
     */
    protected CharSequence makeName() {
<span class="fc" id="L354">        return makeCompoundName(operator(), term);</span>
    }

    @Override
    public CharSequence name() {
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (this.nameInternal() == null) {</span>
<span class="fc" id="L360">            this.setName(makeName());</span>
        }
<span class="fc" id="L362">        return this.nameInternal();</span>
    }
    
    
    
    /**
     * default method to make the oldName of a compound term from given fields
     *
     * @param op the term operator
     * @param arg the list of term
     * @return the oldName of the term
     */
    protected static CharSequence makeCompoundName(final NativeOperator op, final Term... arg) {
<span class="fc" id="L375">        int size = 1 + 1;</span>
        
<span class="fc" id="L377">        final String opString = op.toString();</span>
<span class="fc" id="L378">        size += opString.length();</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">        for (final Term t : arg) </span>
<span class="fc" id="L380">            size += 1 + t.name().length();</span>
        
<span class="fc" id="L382">        final CharBuffer n = CharBuffer.allocate(size)</span>
<span class="fc" id="L383">            .append(COMPOUND_TERM_OPENER.ch).append(opString);</span>
            
<span class="fc bfc" id="L385" title="All 2 branches covered.">        for (final Term t : arg) {            </span>
<span class="fc" id="L386">            n.append(Symbols.ARGUMENT_SEPARATOR).append(t.name());</span>
        }
        
<span class="fc" id="L389">        n.append(COMPOUND_TERM_CLOSER.ch);</span>
                        
<span class="fc" id="L391">        return n.compact().toString();</span>
    }
    

 

    /* ----- utilities for other fields ----- */
    /**
     * report the term's syntactic complexity
     *
     * @return the complexity value
     */    
    @Override public short getComplexity() {
<span class="fc" id="L404">        return complexity;</span>
    }


    /**
     * Check if the order of the term matters
     * &lt;p&gt;
     * commutative CompoundTerms: Sets, Intersections Commutative Statements:
     * Similarity, Equivalence (except the one with a temporal order)
     * Commutative CompoundStatements: Disjunction, Conjunction (except the one
     * with a temporal order)
     *
     * @return The default value is false
     */
    public boolean isCommutative() {
<span class="fc" id="L419">        return false;</span>
    }

    /* ----- extend Collection methods to component list ----- */
    /**
     * get the number of term
     *
     * @return the size of the component list
     */
    final public int size() {
<span class="fc" id="L429">        return term.length;</span>
    }


    /** Gives a set of all contained term, recursively */
    public Set&lt;Term&gt; getContainedTerms() {
<span class="nc" id="L435">        final Set&lt;Term&gt; s = new LinkedHashSet(getComplexity());</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">        for (final Term t : term) {</span>
<span class="nc" id="L437">            s.add(t);</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (t instanceof CompoundTerm)</span>
<span class="nc" id="L439">                s.addAll( ((CompoundTerm)t).getContainedTerms() );</span>
        }
<span class="nc" id="L441">        return s;</span>
    }

    /**
     * Clone the component list
     *
     * @return The cloned component list
     */
    public Term[] cloneTerms(final Term... additional) {
<span class="fc" id="L450">        return cloneTermsAppend(term, additional);</span>
    }
    

    /**
     * Cloned array of Terms, except for one or more Terms.
     * @param toRemove
     * @return the cloned array with the missing terms removed, OR null if no terms were actually removed when requireModification=true
     */
    public Term[] cloneTermsExcept(final boolean requireModification, final Term[] toRemove) {
        //TODO if deep, this wastes created clones that are then removed.  correct this inefficiency?
        
<span class="fc" id="L462">        final List&lt;Term&gt; l = asTermList();</span>
<span class="fc" id="L463">        boolean removed = false;</span>
                
<span class="fc bfc" id="L465" title="All 2 branches covered.">        for (final Term t : toRemove) {</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">            if (l.remove(t))</span>
<span class="fc" id="L467">                removed = true;</span>
        }
<span class="pc bpc" id="L469" title="1 of 4 branches missed.">        if ((!removed) &amp;&amp; (requireModification))</span>
<span class="fc" id="L470">            return null;</span>
                
<span class="fc" id="L472">        return l.toArray(new Term[0]);</span>
    }
    

    
    /**
     * Deep clone an array list of terms
     *
     * @param original The original component list
     * @return an identical and separate copy of the list
     */
    public static Term[] cloneTermsAppend(final Term[] original, final Term[] additional) {
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        if (original == null) {</span>
<span class="nc" id="L485">            return null;</span>
        }        

<span class="fc" id="L488">        final int L = original.length + additional.length;</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">        if (L == 0)</span>
<span class="nc" id="L490">            return original;</span>
        
        //TODO apply preventUnnecessaryDeepCopy to more cases
        
<span class="fc" id="L494">        final Term[] arr = new Term[L];</span>
        
        int i;
<span class="fc" id="L497">        int j = 0;</span>
<span class="fc" id="L498">        Term[] srcArray = original;</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">        for (i = 0; i &lt; L; i++) {            </span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">            if (i == original.length) {</span>
<span class="nc" id="L501">                srcArray = additional;</span>
<span class="nc" id="L502">                j = 0;</span>
            }
            
<span class="fc" id="L505">            arr[i] = srcArray[j++];</span>
        }

<span class="fc" id="L508">        return arr;</span>
        
    }

    public List&lt;Term&gt; asTermList() {        
<span class="fc" id="L513">        final List l = new ArrayList(term.length);</span>
<span class="fc" id="L514">        addTermsTo(l);</span>
<span class="fc" id="L515">        return l;</span>
    }

    /** forced deep clone of terms */
    public Term[] cloneTermsDeep() {
<span class="fc" id="L520">        final Term[] l = new Term[term.length];</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">        for (int i = 0; i &lt; l.length; i++) {</span>
<span class="fc" id="L522">            l[i] = term[i].cloneDeep();</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if(l[i] == null) {</span>
<span class="fc" id="L524">                return null;</span>
            }
        }
<span class="fc" id="L527">        return l;        </span>
    }    
    public Term[] cloneVariableTermsDeep() {
<span class="fc" id="L530">        final Term[] l = new Term[term.length];</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">        for (int i = 0; i &lt; l.length; i++)  {     </span>
<span class="fc" id="L532">            Term t = term[i];</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">            if (t.hasVar()) {</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">                if (t instanceof CompoundTerm) {</span>
<span class="fc" id="L535">                    t = ((CompoundTerm)t).cloneDeepVariables();</span>
                }
                else  /* it's a variable */
<span class="fc" id="L538">                    t = t.clone();</span>
            }
<span class="fc" id="L540">            l[i] = t;            </span>
        }
<span class="fc" id="L542">        return l;</span>
    }
    
    /** forced deep clone of terms */
    public List&lt;Term&gt; cloneTermsListDeep() {
<span class="nc" id="L547">        final List&lt;Term&gt; l = new ArrayList(term.length);</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">        for (final Term t : term)</span>
<span class="nc" id="L549">            l.add(t.clone());</span>
<span class="nc" id="L550">        return l;        </span>
    }
    
    static void shuffle(final Term[] ar,final Random randomNumber)
    {
<span class="fc bfc" id="L555" title="All 2 branches covered.">        if (ar.length &lt; 2)  {</span>
<span class="fc" id="L556">            return;</span>
        }

<span class="fc bfc" id="L559" title="All 2 branches covered.">      for (int i = ar.length - 1; i &gt; 0; i--)</span>
      {
<span class="fc" id="L561">        final int index = randomNumber.nextInt(i + 1);</span>
        // Simple swap
<span class="fc" id="L563">        final Term a = ar[index];</span>
<span class="fc" id="L564">        ar[index] = ar[i];</span>
<span class="fc" id="L565">        ar[i] = a;</span>
      }
<span class="fc" id="L567">    }</span>
    
    

    /**
     * Check whether the compound contains a certain component
     * Also matches variables, ex: (&amp;amp;&amp;amp;,&amp;lt;a --&amp;gt; b&amp;gt;,&amp;lt;b --&amp;gt; c&amp;gt;) also contains &amp;lt;a --&amp;gt; #1&amp;gt;
     *
     * @param t The component to be checked
     * @return Whether the component is in the compound
     */
    /*
     * extra comment because it is a Implementation detail - question:
     *
     * Check whether the compound contains a certain component
     * Also matches variables, ex: (&amp;amp;&amp;amp;,&amp;lt;a --&amp;gt; b&amp;gt;,&amp;lt;b --&amp;gt; c&amp;gt;) also contains &amp;lt;a --&amp;gt; #1&amp;gt;
     *  ^^^ is this right? if so then try containsVariablesAsWildcard
     */
    @Override
    public boolean containsTerm(final Term t) {        
<span class="fc" id="L587">        return Terms.contains(term, t);</span>
        //return Terms.containsVariablesAsWildcard(term, t);
    }

    /**
     * Recursively check if a compound contains a term
     *
     * @param target The term to be searched
     * @return Whether the target is in the current term
     */
    @Override
    public boolean containsTermRecursively(final Term target) { 
<span class="fc bfc" id="L599" title="All 2 branches covered.">        if (super.containsTermRecursively(target))</span>
<span class="fc" id="L600">            return true;</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">        for (final Term term : term) {            </span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">            if (term.containsTermRecursively(target)) {</span>
<span class="fc" id="L603">                return true;</span>
            }
        }
<span class="fc" id="L606">        return false;</span>
    }

    /**
     * Recursively count how often the terms are contained
     *
     * @param map The count map that will be created to count how often each term occurs
     * @return The counts of the terms
     */
    @Override
    public Map&lt;Term, Integer&gt; countTermRecursively(Map&lt;Term,Integer&gt; map) { 
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if(map == null) {</span>
<span class="fc" id="L618">            map = new LinkedHashMap&lt;Term, Integer&gt;();</span>
        }
<span class="fc" id="L620">        map.put(this, map.getOrDefault(this, 0) + 1);</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">        for (final Term term : term) {            </span>
<span class="fc" id="L622">            term.countTermRecursively(map);</span>
        }
<span class="fc" id="L624">        return map;</span>
    }
    
    /**
     * Add all the components of term t into components recursively
     * 
     * @param t The term
     * @param components The components
     * @return 
     */
    public static Set&lt;Term&gt; addComponentsRecursively(Term t, Set&lt;Term&gt; components) {
<span class="fc bfc" id="L635" title="All 2 branches covered.">        if(components == null) {</span>
<span class="fc" id="L636">            components = new LinkedHashSet&lt;Term&gt;();</span>
        }
<span class="fc" id="L638">        components.add(t);</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">        if(t instanceof CompoundTerm) {</span>
<span class="fc" id="L640">            CompoundTerm cTerm = (CompoundTerm) t;</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">            for(Term component : cTerm) {</span>
<span class="fc" id="L642">                addComponentsRecursively(component, components);</span>
<span class="fc" id="L643">            }</span>
        }
<span class="fc" id="L645">        return components;</span>
    }

    /**
     * Check whether the compound contains all term of another term, or
 that term as a whole
     *
     * @param t The other term
     * @return Whether the term are all in the compound
     */
    public boolean containsAllTermsOf(final Term t) {
<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (getClass() == t.getClass()) { //(t instanceof CompoundTerm) {</span>
<span class="fc" id="L657">            return Terms.containsAll(term, ((CompoundTerm) t).term );</span>
        } else {
<span class="fc" id="L659">            return Terms.contains(term, t);</span>
        }
    }

    /**
     * Try to replace a component in a compound at a given index by another one
     *
     * @param index The location of replacement
     * @param t The new component
     * @param memory Reference to the memory
     * @return The new compound
     */
    public Term setComponent(final int index, final Term t, final Memory memory) {
<span class="fc" id="L672">        final List&lt;Term&gt; list = asTermList();//Deep();</span>
<span class="fc" id="L673">        list.remove(index);</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">        if (t != null) {</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">            if (getClass() != t.getClass()) {</span>
<span class="fc" id="L676">                list.add(index, t);</span>
            } else {
                //final List&lt;Term&gt; list2 = ((CompoundTerm) t).cloneTermsList();
<span class="fc" id="L679">                final Term[] tt = ((CompoundTerm)t).term;</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">                for (int i = 0; i &lt; tt.length; i++) {</span>
<span class="fc" id="L681">                    list.add(index + i, tt[i]);</span>
                }
            }
        }
<span class="fc bfc" id="L685" title="All 2 branches covered.">        if(this.isCommutative()) {</span>
<span class="fc" id="L686">            Term[] ret = list.toArray(new Term[0]);</span>
<span class="fc" id="L687">            return Terms.term(this, ret);</span>
        }
<span class="fc" id="L689">        return Terms.term(this, list);</span>
    }

    /* ----- variable-related utilities ----- */
    /**
     * Whether this compound term contains any variable term
     *
     * @return Whether the name contains a variable
     */
    @Override
    public boolean hasVar() {
<span class="fc" id="L700">        return hasVariables;    </span>
    }

    @Override
    public boolean hasVarDep() {
<span class="fc" id="L705">        return hasVarDeps;</span>
    }

    @Override
    public boolean hasVarIndep() {
<span class="fc" id="L710">        return hasVarIndeps;</span>
    }

    @Override
    public boolean hasVarQuery() {
<span class="fc" id="L715">        return hasVarQueries;</span>
    }
    
    @Override
    public boolean hasInterval() {
<span class="fc" id="L720">        return hasIntervals;</span>
    }
    
    /**
     * Recursively apply a substitute to the current CompoundTerm
     * May return null if the term can not be created
     * @param subs
     */
    public Term applySubstitute(final Map&lt;Term, Term&gt; subs) {   
<span class="pc bpc" id="L729" title="1 of 4 branches missed.">        if ((subs == null) || (subs.isEmpty())) {            </span>
<span class="fc" id="L730">            return this;//.clone();</span>
        }
                
<span class="fc" id="L733">        final Term[] tt = new Term[term.length];</span>
<span class="fc" id="L734">        boolean modified = false;</span>
        
<span class="fc bfc" id="L736" title="All 2 branches covered.">        for (int i = 0; i &lt; tt.length; i++) {</span>
<span class="fc" id="L737">            final Term t1 = tt[i] = term[i];</span>
            
<span class="fc bfc" id="L739" title="All 2 branches covered.">            if (subs.containsKey(t1)) {</span>
<span class="fc" id="L740">                Term t2 = subs.get(t1);                            </span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">                while (subs.containsKey(t2)) {</span>
<span class="fc" id="L742">                    t2 = subs.get(t2);</span>
                }
                //prevents infinite recursion
<span class="fc bfc" id="L745" title="All 2 branches covered.">                if (!t2.containsTerm(t1)) {</span>
<span class="fc" id="L746">                    tt[i] = t2; //t2.clone();</span>
<span class="fc" id="L747">                    modified = true;</span>
                }
<span class="fc bfc" id="L749" title="All 2 branches covered.">            } else if (t1 instanceof CompoundTerm) {</span>
<span class="fc" id="L750">                final Term ss = ((CompoundTerm) t1).applySubstitute(subs);</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">                if (ss!=null) {</span>
<span class="fc" id="L752">                    tt[i] = ss;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">                    if (!tt[i].equals(term[i]))</span>
<span class="fc" id="L754">                        modified = true;</span>
                }
            }
        }
<span class="fc bfc" id="L758" title="All 2 branches covered.">        if (!modified)</span>
<span class="fc" id="L759">            return this;</span>
        
<span class="fc bfc" id="L761" title="All 2 branches covered.">        if (this.isCommutative()) {         </span>
<span class="fc" id="L762">            Arrays.sort(tt);</span>
        }        

<span class="fc" id="L765">        return this.clone(tt);</span>
    }

    /** returns result of applySubstitute, if and only if it's a CompoundTerm. 
     * otherwise it is null */
    public CompoundTerm applySubstituteToCompound(final Map&lt;Term, Term&gt; substitute) {
<span class="fc" id="L771">        final Term t = applySubstitute(substitute);</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">        if (t instanceof CompoundTerm)</span>
<span class="fc" id="L773">            return ((CompoundTerm)t);</span>
<span class="nc" id="L774">        return null;</span>
    }

    
    /* ----- link CompoundTerm and its term ----- */
    /**
     * Build TermLink templates to constant term and subcomponents
     * &lt;p&gt;
     * The compound type determines the link type; the component type determines
     * whether to build the link.
     *
     * @return A list of TermLink templates
     */
    public List&lt;TermLink&gt; prepareComponentLinks() {
        //complexity seems like an upper bound for the resulting number of componentLinks. 
        //so use it as an initial size for the array list
<span class="fc" id="L790">        final List&lt;TermLink&gt; componentLinks = new ArrayList&lt;&gt;( getComplexity() );</span>
<span class="fc" id="L791">        return Terms.prepareComponentLinks(componentLinks, this);</span>
    }

    final public void addTermsTo(final Collection&lt;Term&gt; c) {
<span class="fc" id="L795">        Collections.addAll(c, term);</span>
<span class="fc" id="L796">    }</span>



    @Override
    public int hashCode() {
<span class="fc" id="L802">        return name().hashCode();</span>
    }

    @Override
    public int compareTo(final AbstractTerm that) {
<span class="fc bfc" id="L807" title="All 2 branches covered.">        if (that==this) { </span>
<span class="fc" id="L808">            return 0;</span>
        }
<span class="fc" id="L810">        return super.compareTo(that);</span>
    }
    
    @Override
    public boolean equals(final Object that) {
<span class="fc bfc" id="L815" title="All 2 branches covered.">        if (that==this) return true;                </span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">        if (!(that instanceof Term))</span>
<span class="nc" id="L817">            return false;</span>
<span class="fc" id="L818">        return name().equals(((Term)that).name());</span>
    }   

    public void setNormalized(final boolean b) {
<span class="fc" id="L822">        this.normalized = b;</span>
<span class="fc" id="L823">    }</span>

    public boolean isNormalized() {
<span class="fc" id="L826">        return normalized;</span>
    }
    
    public Term[] cloneTermsReplacing(final Term from, final Term to) {
<span class="nc" id="L830">        final Term[] y = new Term[term.length];</span>
<span class="nc" id="L831">        int i = 0;</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">        for (Term x : term) {</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">            if (x.equals(from))</span>
<span class="nc" id="L834">                x = to;</span>
<span class="nc" id="L835">            y[i++] = x;</span>
        }
<span class="nc" id="L837">        return y;</span>
    }

    @Override
    public Iterator&lt;Term&gt; iterator() {
<span class="fc" id="L842">        return Iterators.forArray(term);</span>
    }

    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>