<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Terms.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS</a> &gt; <a href="index.source.html" class="el_package">org.opennars.language</a> &gt; <span class="el_source">Terms.java</span></div><h1>Terms.java</h1><pre class="source lang-java linenums">/* 
 * The MIT License
 *
 * Copyright 2018 The OpenNARS authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.opennars.language;

import org.opennars.entity.Sentence;
import org.opennars.entity.TermLink;
import org.opennars.inference.TemporalRules;
import org.opennars.io.Symbols;
import org.opennars.storage.Memory;

import java.util.*;

/**
 * Static utility class for static methods related to Terms
 *
 * @author Patrick Hammer
 */
<span class="nc" id="L39">public class Terms {</span>

    public static boolean equalSubTermsInRespectToImageAndProduct(final Term a, final Term b) {
<span class="pc bpc" id="L42" title="2 of 4 branches missed.">        if (a == null || b == null) {</span>
<span class="nc" id="L43">            return false;</span>
        }
<span class="fc bfc" id="L45" title="All 4 branches covered.">        if (!((a instanceof CompoundTerm) &amp;&amp; (b instanceof CompoundTerm))) {</span>
<span class="fc" id="L46">            return a.equals(b);</span>
        }
<span class="fc bfc" id="L48" title="All 4 branches covered.">        if (a instanceof Inheritance &amp;&amp; b instanceof Inheritance) {</span>
<span class="fc" id="L49">            return equalSubjectPredicateInRespectToImageAndProduct(a, b);</span>
        }
<span class="fc bfc" id="L51" title="All 4 branches covered.">        if (a instanceof Similarity &amp;&amp; b instanceof Similarity) {</span>
<span class="pc bpc" id="L52" title="1 of 4 branches missed.">            return equalSubjectPredicateInRespectToImageAndProduct(a, b) || equalSubjectPredicateInRespectToImageAndProduct(b, a);</span>
        }
<span class="fc" id="L54">        final Term[] A = ((CompoundTerm) a).term;</span>
<span class="fc" id="L55">        final Term[] B = ((CompoundTerm) b).term;</span>
<span class="fc bfc" id="L56" title="All 4 branches covered.">        if (A.length != B.length || !(a.operator().equals(b.operator()))) {</span>
<span class="fc" id="L57">            return false;</span>
        } else {
<span class="fc bfc" id="L59" title="All 2 branches covered.">            for (int i = 0; i &lt; A.length; i++) {</span>
<span class="fc" id="L60">                final Term x = A[i];</span>
<span class="fc" id="L61">                final Term y = B[i];</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">                if (!x.equals(y)) {</span>
<span class="fc bfc" id="L63" title="All 4 branches covered.">                    if (x instanceof Inheritance &amp;&amp; y instanceof Inheritance) {</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">                        if (!equalSubjectPredicateInRespectToImageAndProduct(x, y)) {</span>
<span class="fc" id="L65">                            return false;</span>
                        } else {
                            continue;
                        }
                    }
<span class="fc bfc" id="L70" title="All 4 branches covered.">                    if (x instanceof Similarity &amp;&amp; y instanceof Similarity) {</span>
<span class="pc bpc" id="L71" title="2 of 4 branches missed.">                        if (!equalSubjectPredicateInRespectToImageAndProduct(x, y) &amp;&amp; !equalSubjectPredicateInRespectToImageAndProduct(y, x)) {</span>
<span class="fc" id="L72">                            return false;</span>
                        } else {
                            continue;
                        }
                    }
<span class="fc" id="L77">                    return false;</span>
                }
            }
<span class="fc" id="L80">            return true;</span>
        }
    }

    public static Term reduceUntilLayer2(final CompoundTerm _itself, final Term replacement, final Memory memory) {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (_itself == null)</span>
<span class="nc" id="L86">            return null;</span>
        
<span class="nc" id="L88">        final Term reduced = reduceComponentOneLayer(_itself, replacement, memory);</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if (!(reduced instanceof CompoundTerm))</span>
<span class="nc" id="L90">            return null;</span>
        
<span class="nc" id="L92">        CompoundTerm itself = (CompoundTerm)reduced;</span>
<span class="nc" id="L93">        int j = 0;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">        for (final Term t : itself.term) {</span>
<span class="nc" id="L95">            final Term t2 = unwrapNegation(t);</span>
<span class="nc bnc" id="L96" title="All 8 branches missed.">            if (!(t2 instanceof Implication) &amp;&amp; !(t2 instanceof Equivalence) &amp;&amp; !(t2 instanceof Conjunction) &amp;&amp; !(t2 instanceof Disjunction)) {</span>
<span class="nc" id="L97">                j++;</span>
<span class="nc" id="L98">                continue;</span>
            }
<span class="nc" id="L100">            final Term ret2 = reduceComponentOneLayer((CompoundTerm) t2, replacement, memory);</span>
            
            //CompoundTerm itselfCompound = itself;
<span class="nc" id="L103">            Term replaced = null;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">            if (j &lt; itself.term.length  )</span>
<span class="nc" id="L105">                replaced = itself.setComponent(j, ret2, memory);</span>
            
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (replaced != null) {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">                if (replaced instanceof CompoundTerm)</span>
<span class="nc" id="L109">                    itself = (CompoundTerm)replaced;</span>
                else
<span class="nc" id="L111">                    return replaced;</span>
            }
<span class="nc" id="L113">            j++;</span>
        }
<span class="nc" id="L115">        return itself;</span>
    }

    /* static methods making new compounds, which may return null */
    /**
     * Try to make a compound term from a template and a list of term
     *
     * @param compound The template
     * @param components The term
     * @return A compound term or null
     */
    public static Term term(final CompoundTerm compound, final Term[] components) {
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (compound instanceof ImageExt) {</span>
<span class="fc" id="L128">            return new ImageExt(components, ((Image) compound).relationIndex);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        } else if (compound instanceof ImageInt) {</span>
<span class="fc" id="L130">            return ImageInt.make(components, ((Image) compound).relationIndex);</span>
        } else {
<span class="fc" id="L132">            return term(compound.operator(), components);</span>
        }
    }

    public static Term term(final CompoundTerm compound, final Collection&lt;Term&gt; components) {
<span class="fc" id="L137">        final Term[] c = components.toArray(new Term[0]);</span>
<span class="fc" id="L138">        return term(compound, c);</span>
    }
    

    /**
     * Try to make a compound term from an operator and a list of term
     * &lt;p&gt;
     * Called from StringParser
     *
     * @param copula Term operator
     * @param componentList Component list
     * @return A term or null
     */
    public static Term term(final Symbols.NativeOperator copula, final Term[] componentList) {
        
<span class="pc bpc" id="L153" title="2 of 24 branches missed.">        switch (copula) {</span>
            
            case SET_EXT_OPENER:
<span class="fc" id="L156">                return SetExt.make(componentList);</span>
            case SET_INT_OPENER:
<span class="fc" id="L158">                return SetInt.make(componentList);</span>
            case INTERSECTION_EXT:
<span class="fc" id="L160">                return IntersectionExt.make(componentList);</span>
            case INTERSECTION_INT:
<span class="fc" id="L162">                return IntersectionInt.make(componentList);</span>
            case DIFFERENCE_EXT:
<span class="fc" id="L164">                return DifferenceExt.make(componentList);</span>
            case DIFFERENCE_INT:
<span class="fc" id="L166">                return DifferenceInt.make(componentList);</span>
            case INHERITANCE:
<span class="fc" id="L168">                return Inheritance.make(componentList[0], componentList[1]);</span>
            case PRODUCT:
<span class="fc" id="L170">                return new Product(componentList);</span>
            case IMAGE_EXT:
<span class="fc" id="L172">                return ImageExt.make(componentList);</span>
            case IMAGE_INT:
<span class="fc" id="L174">                return ImageInt.make(componentList);</span>
            case NEGATION:
<span class="fc" id="L176">                return Negation.make(componentList);</span>
            case DISJUNCTION:
<span class="fc" id="L178">                return Disjunction.make(componentList);</span>
            case CONJUNCTION:
<span class="fc" id="L180">                return Conjunction.make(componentList);</span>
            case SEQUENCE:
<span class="fc" id="L182">                return Conjunction.make(componentList, TemporalRules.ORDER_FORWARD);</span>
            case SPATIAL:
<span class="fc" id="L184">                return Conjunction.make(componentList, TemporalRules.ORDER_FORWARD, true);</span>
            case PARALLEL:
<span class="fc" id="L186">                return Conjunction.make(componentList, TemporalRules.ORDER_CONCURRENT);</span>
            case IMPLICATION:
<span class="fc" id="L188">                return Implication.make(componentList[0], componentList[1]);</span>
            case IMPLICATION_AFTER:
<span class="fc" id="L190">                return Implication.make(componentList[0], componentList[1], TemporalRules.ORDER_FORWARD);</span>
            case IMPLICATION_BEFORE:
<span class="fc" id="L192">                return Implication.make(componentList[0], componentList[1], TemporalRules.ORDER_BACKWARD);</span>
            case IMPLICATION_WHEN:
<span class="fc" id="L194">                return Implication.make(componentList[0], componentList[1], TemporalRules.ORDER_CONCURRENT);</span>
            case EQUIVALENCE:
<span class="fc" id="L196">                return Equivalence.make(componentList[0], componentList[1]);</span>
            case EQUIVALENCE_WHEN:
<span class="nc" id="L198">                return Equivalence.make(componentList[0], componentList[1], TemporalRules.ORDER_CONCURRENT);</span>
            case EQUIVALENCE_AFTER:
<span class="fc" id="L200">                return Equivalence.make(componentList[0], componentList[1], TemporalRules.ORDER_FORWARD);</span>
            default:
<span class="nc" id="L202">                throw new IllegalStateException(&quot;Unknown Term operator: &quot; + copula + &quot; (&quot; + copula.name() + &quot;)&quot;);</span>
        }
    }

    /**
     * Try to remove a component from a compound
     *
     * @param compound The compound
     * @param component The component
     * @param memory Reference to the memory
     * @return The new compound
     */
    public static Term reduceComponents(final CompoundTerm compound, final Term component, final Memory memory) {
        final Term[] list;
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (compound.getClass() == component.getClass()) {</span>
<span class="fc" id="L217">            list = compound.cloneTermsExcept(true, ((CompoundTerm) component).term);</span>
        } else {
<span class="fc" id="L219">            list = compound.cloneTermsExcept(true, new Term[] { component });</span>
        }
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (list != null) {</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">            if (list.length &gt; 1) {</span>
<span class="fc" id="L223">                return term(compound, list);</span>
            }
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (list.length == 1) {</span>
<span class="fc bfc" id="L226" title="All 12 branches covered.">                if ((compound instanceof Conjunction) || (compound instanceof Disjunction) || (compound instanceof IntersectionExt) || (compound instanceof IntersectionInt) || (compound instanceof DifferenceExt) || (compound instanceof DifferenceInt)) {</span>
<span class="fc" id="L227">                    return list[0];</span>
                }
            }
        }
<span class="fc" id="L231">        return null;</span>
    }

    public static Term reduceComponentOneLayer(final CompoundTerm compound, final Term component, final Memory memory) {
        final Term[] list;
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (compound.getClass() == component.getClass()) {</span>
<span class="nc" id="L237">            list = compound.cloneTermsExcept(true, ((CompoundTerm) component).term);</span>
        } else {
<span class="nc" id="L239">            list = compound.cloneTermsExcept(true, new Term[] { component });</span>
        }
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (list != null) {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (list.length &gt; 1) {</span>
<span class="nc" id="L243">                return term(compound, list);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            } else if (list.length == 1) {</span>
<span class="nc" id="L245">                return list[0];</span>
            }
        }
<span class="nc" id="L248">        return compound;</span>
    }


    public static Term unwrapNegation(final Term T) {
<span class="nc bnc" id="L253" title="All 4 branches missed.">        if (T != null &amp;&amp; T instanceof Negation) {</span>
<span class="nc" id="L254">            return ((CompoundTerm) T).term[0];</span>
        }
<span class="nc" id="L256">        return T;</span>
    }

    public static boolean equalSubjectPredicateInRespectToImageAndProduct(final Term a, final Term b) {
        
<span class="pc bpc" id="L261" title="2 of 4 branches missed.">        if (a == null || b == null) {</span>
<span class="nc" id="L262">            return false;</span>
        }
        
<span class="pc bpc" id="L265" title="3 of 4 branches missed.">        if (!(a instanceof Statement) &amp;&amp; !(b instanceof Statement)) {</span>
<span class="nc" id="L266">            return false;</span>
        }
        
<span class="fc bfc" id="L269" title="All 2 branches covered.">        if (a.equals(b)) {</span>
<span class="fc" id="L270">            return true;</span>
        }
        
<span class="fc" id="L273">        final Statement A = (Statement) a;</span>
<span class="fc" id="L274">        final Statement B = (Statement) b;</span>
        
<span class="pc bpc" id="L276" title="3 of 8 branches missed.">        if (!(A instanceof Similarity &amp;&amp; B instanceof Similarity </span>
                || A instanceof Inheritance &amp;&amp; B instanceof Inheritance))
<span class="nc" id="L278">            return false;</span>
            
<span class="fc" id="L280">        final Term subjA = A.getSubject();</span>
<span class="fc" id="L281">        final Term predA = A.getPredicate();</span>
<span class="fc" id="L282">        final Term subjB = B.getSubject();</span>
<span class="fc" id="L283">        final Term predB = B.getPredicate();</span>

<span class="fc" id="L285">        Term ta = null, tb = null;</span>
<span class="fc" id="L286">        Term sa = null, sb = null;</span>

<span class="fc bfc" id="L288" title="All 4 branches covered.">        if ((subjA instanceof Product) &amp;&amp; (predB instanceof ImageExt)) {</span>
<span class="fc" id="L289">            ta = predA; sa = subjA;</span>
<span class="fc" id="L290">            tb = subjB; sb = predB;</span>
        }
<span class="fc bfc" id="L292" title="All 4 branches covered.">        if ((subjB instanceof Product) &amp;&amp; (predA instanceof ImageExt)) {</span>
<span class="fc" id="L293">            ta = subjA; sa = predA;</span>
<span class="fc" id="L294">            tb = predB; sb = subjB;                </span>
        }
<span class="fc bfc" id="L296" title="All 4 branches covered.">        if ((predA instanceof ImageExt) &amp;&amp; (predB instanceof ImageExt)) {</span>
<span class="fc" id="L297">            ta = subjA; sa = predA;</span>
<span class="fc" id="L298">            tb = subjB; sb = predB;                </span>
        }
<span class="fc bfc" id="L300" title="All 4 branches covered.">        if ((subjA instanceof ImageInt) &amp;&amp; (subjB instanceof ImageInt)) {</span>
<span class="fc" id="L301">            ta = predA; sa = subjA;</span>
<span class="fc" id="L302">            tb = predB; sb = subjB;</span>
        }
<span class="fc bfc" id="L304" title="All 4 branches covered.">        if ((predA instanceof Product) &amp;&amp; (subjB instanceof ImageInt)) {</span>
<span class="fc" id="L305">            ta = subjA; sa = predA;</span>
<span class="fc" id="L306">            tb = predB; sb = subjB;                </span>
        }
<span class="fc bfc" id="L308" title="All 4 branches covered.">        if ((predB instanceof Product) &amp;&amp; (subjA instanceof ImageInt)) {</span>
<span class="fc" id="L309">            ta = predA; sa = subjA;</span>
<span class="fc" id="L310">            tb = subjB; sb = predB;</span>
        }

<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (ta==null) {</span>
<span class="fc" id="L314">            return false;</span>
        }

<span class="fc" id="L317">        final Term[] sat = ((CompoundTerm)sa).term;</span>
<span class="fc" id="L318">        final Term[] sbt = ((CompoundTerm)sb).term;</span>

<span class="fc bfc" id="L320" title="All 4 branches covered.">        if(sa instanceof Image &amp;&amp; sb instanceof Image) {</span>
<span class="fc" id="L321">            final Image im1=(Image) sa;</span>
<span class="fc" id="L322">            final Image im2=(Image) sb;</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">            if(im1.relationIndex != im2.relationIndex) {</span>
<span class="fc" id="L324">                return false;</span>
            }
        }

<span class="fc" id="L328">        final Set&lt;Term&gt; componentsA = new LinkedHashSet(1+sat.length);</span>
<span class="fc" id="L329">        final Set&lt;Term&gt; componentsB = new LinkedHashSet(1+sbt.length);</span>

<span class="fc" id="L331">        componentsA.add(ta);</span>
<span class="fc" id="L332">        Collections.addAll(componentsA, sat);</span>

<span class="fc" id="L334">        componentsB.add(tb);</span>
<span class="fc" id="L335">        Collections.addAll(componentsB, sbt);</span>

<span class="fc bfc" id="L337" title="All 2 branches covered.">        for(final Term sA : componentsA) {</span>
<span class="fc" id="L338">            boolean had=false;</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            for(final Term sB : componentsB) {</span>
<span class="fc bfc" id="L340" title="All 4 branches covered.">                if(sA instanceof Variable &amp;&amp; sB instanceof Variable) {</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">                    if(sA.name().equals(sB.name())) {</span>
<span class="fc" id="L342">                        had=true;</span>
        }
                }
                else
<span class="fc bfc" id="L346" title="All 2 branches covered.">                if(sA.equals(sB)) {</span>
<span class="fc" id="L347">                    had=true;</span>
                }
<span class="fc" id="L349">            }</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            if(!had) {</span>
<span class="fc" id="L351">                return false;</span>
            }
<span class="fc" id="L353">        }</span>
            
<span class="fc" id="L355">        return true;</span>
    }

    /**
     * Collect TermLink templates into a list, go down one level except in
     * special cases
     * &lt;p&gt;
     *
     * @param componentLinks The list of TermLink templates built so far
     * @param type The type of TermLink to be built
     * @param term The CompoundTerm for which the links are built
     */
    public static List&lt;TermLink&gt; prepareComponentLinks(final List&lt;TermLink&gt; componentLinks, final short type, final CompoundTerm term) {
        
<span class="fc" id="L369">        final boolean tEquivalence = (term instanceof Equivalence);</span>
<span class="fc" id="L370">        final boolean tImplication = (term instanceof Implication);</span>
        
<span class="fc bfc" id="L372" title="All 2 branches covered.">        for (int i = 0; i &lt; term.size(); i++) {</span>
<span class="fc" id="L373">            Term t1 = term.term[i];</span>
<span class="fc" id="L374">            t1=new Sentence(</span>
                t1,
                Symbols.TERM_NORMALIZING_WORKAROUND_MARK,
                null,
                null).term;
            
            
<span class="fc bfc" id="L381" title="All 2 branches covered.">            if (!(t1 instanceof Variable)) {</span>
<span class="fc" id="L382">                componentLinks.add(new TermLink(type, t1, i));</span>
            }
<span class="fc bfc" id="L384" title="All 10 branches covered.">            if ((tEquivalence || (tImplication &amp;&amp; (i == 0))) &amp;&amp; ((t1 instanceof Conjunction) || (t1 instanceof Negation))) {</span>
<span class="fc" id="L385">                prepareComponentLinks(componentLinks, TermLink.COMPOUND_CONDITION, (CompoundTerm) t1);</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            } else if (t1 instanceof CompoundTerm) {</span>
<span class="fc" id="L387">                final CompoundTerm ct1 = (CompoundTerm)t1;</span>
<span class="fc" id="L388">                final int ct1Size = ct1.size(); //cache because this loop is critical</span>
<span class="fc bfc" id="L389" title="All 6 branches covered.">                final boolean t1ProductOrImage = (t1 instanceof Product) || (t1 instanceof ImageExt) || (t1 instanceof ImageInt);</span>
                
<span class="fc bfc" id="L391" title="All 2 branches covered.">                for (int j = 0; j &lt; ct1Size; j++) {</span>
<span class="fc" id="L392">                    Term t2 = ct1.term[j];</span>

<span class="fc" id="L394">                    t2 = new Sentence(</span>
                        t2,
                        Symbols.TERM_NORMALIZING_WORKAROUND_MARK,
                        null,
                        null).term;

<span class="fc bfc" id="L400" title="All 2 branches covered.">                    if (!t2.hasVar()) {</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                        if (t1ProductOrImage) {</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">                            if (type == TermLink.COMPOUND_CONDITION) {</span>
<span class="nc" id="L403">                                componentLinks.add(new TermLink(TermLink.TRANSFORM, t2, 0, i, j));</span>
                            } else {
<span class="fc" id="L405">                                componentLinks.add(new TermLink(TermLink.TRANSFORM, t2, i, j));</span>
                            }
                        } else {
<span class="fc" id="L408">                            componentLinks.add(new TermLink(type, t2, i, j));</span>
                        }
                    }
<span class="fc bfc" id="L411" title="All 6 branches covered.">                    if ((t2 instanceof Product) || (t2 instanceof ImageExt) || (t2 instanceof ImageInt)) {</span>
<span class="fc" id="L412">                        final CompoundTerm ct2 = (CompoundTerm)t2;</span>
<span class="fc" id="L413">                        final int ct2Size = ct2.size();</span>
                        
<span class="fc bfc" id="L415" title="All 2 branches covered.">                        for (int k = 0; k &lt; ct2Size; k++) {</span>
<span class="fc" id="L416">                            Term t3 = ct2.term[k];</span>

<span class="fc" id="L418">                            t3 = new Sentence(</span>
                                t3,
                                Symbols.TERM_NORMALIZING_WORKAROUND_MARK,
                                null,
                                null).term;

<span class="fc bfc" id="L424" title="All 2 branches covered.">                            if (!t3.hasVar()) {</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">                                if (type == TermLink.COMPOUND_CONDITION) {</span>
<span class="fc" id="L426">                                    componentLinks.add(new TermLink(TermLink.TRANSFORM, t3, 0, i, j, k));</span>
                                } else {
<span class="fc" id="L428">                                    componentLinks.add(new TermLink(TermLink.TRANSFORM, t3, i, j, k));</span>
                                }
                            }
                        }
                    }
                }
            }
        }
<span class="fc" id="L436">        return componentLinks;</span>
    }

   public  static List&lt;TermLink&gt; prepareComponentLinks(final List&lt;TermLink&gt; componentLinks, final CompoundTerm ct) {
<span class="fc bfc" id="L440" title="All 2 branches covered.">        final short type = (ct instanceof Statement) ? TermLink.COMPOUND_STATEMENT : TermLink.COMPOUND;   // default</span>
<span class="fc" id="L441">        return prepareComponentLinks(componentLinks, type, ct);</span>
    }

    //TODO move this to a utility method
    public static &lt;T&gt; int indexOf(final T[] array, final T v) {
        /*if (v == null) {
        for (final T e : array)
        if (e == null)
        return true;
        } else {*/
<span class="fc" id="L451">        int i = 0;</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">        for (final T e : array) {</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">            if (v.equals(e)) {</span>
<span class="fc" id="L454">                return i;</span>
            }
<span class="fc" id="L456">            i++;</span>
        }
<span class="fc" id="L458">        return -1;</span>
    }

    /** compres a set of terms (assumed to be unique) with another set to find if their
     * contents match. they can be in different order and still match.  this is useful for
     * comparing whether compound terms in which order doesn't matter (ex: conjunction)
     * are equivalent.
     */ 
    public static &lt;T&gt; boolean containsAll(final T[] a, final T[] b) {
<span class="fc bfc" id="L467" title="All 2 branches covered.">        for (final T ax : a) {</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">            if (!contains(b, ax))</span>
<span class="fc" id="L469">                return false;</span>
        }
<span class="fc" id="L471">        return true;</span>
    }
    
    /** a contains any of b  NOT TESTED YET */
    public static boolean containsAny(final Term[] a, final Collection&lt;Term&gt; b) {
<span class="nc bnc" id="L476" title="All 2 branches missed.">        for (final Term bx : b) {</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (contains(a, bx))</span>
<span class="nc" id="L478">                return true;</span>
<span class="nc" id="L479">        }</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        for (final Term ax : a) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (ax instanceof CompoundTerm)</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">                if (containsAny(((CompoundTerm)ax).term, b))</span>
<span class="nc" id="L483">                    return true;</span>
        }
        
<span class="nc" id="L486">        return false;</span>
    }

    public static &lt;T&gt; boolean contains(final T[] array, final T v) {
<span class="fc bfc" id="L490" title="All 2 branches covered.">        for (final T e : array) {</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (v.equals(e)) {</span>
<span class="fc" id="L492">                return true;</span>
            }
        }
<span class="fc" id="L495">        return false;</span>
    }

    static boolean equals(final Term[] a, final Term[] b) {
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (a.length!=b.length) return false;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">            if (!a[i].equals(b[i]))</span>
<span class="nc" id="L502">                return false;            </span>
        }
<span class="nc" id="L504">        return true;</span>
    }

    public static void verifyNonNull(final Collection t) {
<span class="nc bnc" id="L508" title="All 2 branches missed.">        for (final Object o : t)</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            if (o == null)</span>
<span class="nc" id="L510">                throw new IllegalStateException(&quot;Element null in: &quot; + t);</span>
<span class="nc" id="L511">    }</span>

    static void verifyNonNull(final Term... t) {
<span class="nc bnc" id="L514" title="All 2 branches missed.">        for (final Object o : t)</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            if (o == null)</span>
<span class="nc" id="L516">                throw new IllegalStateException(&quot;Element null in: &quot; + Arrays.toString(t));</span>
<span class="nc" id="L517">    }    </span>
    
    public static Term[] verifySortedAndUnique(final Term[] arg, final boolean allowSingleton) {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (arg.length == 0) {</span>
<span class="nc" id="L521">            throw new IllegalStateException(&quot;Needs &gt;0 components&quot;);</span>
        }
<span class="nc bnc" id="L523" title="All 4 branches missed.">        if (!allowSingleton &amp;&amp; (arg.length == 1)) {</span>
<span class="nc" id="L524">            throw new IllegalStateException(&quot;Needs &gt;1 components: &quot; + Arrays.toString(arg));</span>
        }
<span class="nc" id="L526">        final Term[] s = Term.toSortedSetArray(arg);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (arg.length!=s.length) {</span>
<span class="nc" id="L528">            throw new IllegalStateException(&quot;Contains duplicates: &quot; + Arrays.toString(arg));</span>
        }
<span class="nc" id="L530">        int j = 0;</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">        for (final Term t : s) {</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">            if (!t.equals(arg[j++]))</span>
<span class="nc" id="L533">                throw new IllegalStateException(&quot;Un-ordered: &quot; + Arrays.toString(arg) + &quot; , correct order=&quot; + Arrays.toString(s));</span>
        }        
<span class="nc" id="L535">        return s;</span>
    }    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>